<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3快速上手</title>
      <link href="/2022/11/11/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2022/11/11/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>#Vue3快速上手</p><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li>setup执行的时机<ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li>setup的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1</p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li></ul><ul><li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Demo&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">//自定义一个myRef</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer</span><br><span class="line">//通过customRef去实现自定义</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">return value</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue</span><br><span class="line">trigger() //告诉Vue去更新界面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">return &#123;</span><br><span class="line">keyword</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/childTest.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">&lt;Child/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:fallback&gt;</span><br><span class="line">&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>茶七网</title>
      <link href="/2022/11/10/%E8%8C%B6%E4%B8%83%E7%BD%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/10/%E8%8C%B6%E4%B8%83%E7%BD%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>一、路径上的配置</p><pre><code>    vue.config.js 配置了@代表src目录代码：    let path = require(&quot;path&quot;);    module.exports = &#123;        configureWebpack: (config) =&gt; &#123;            config.resolve = &#123;                   extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.vue&#39;],                  alias: &#123;                        &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),                  &#125;            &#125;          &#125;    &#125;</code></pre><p>二、定义tabbar</p><pre><code>跳转this.$router.xxx  判断：如果是当前路由切换，就不跳转(return)</code></pre><p>三、目录分配</p><pre><code>views         ===》 页面components  ===》页面中的组件（模块）</code></pre><p>四、头部topbar切换插件</p><pre><code>4.1 下载插件    npm install ly-tab -S    4.2 引入插件    import LyTab from &#39;ly-tab&#39;    Vue.use(LyTab)</code></pre><p>五、swiper插件</p><pre><code>5.1 下载    npm install vue-awesome-swiper@3.1.3 -S    </code></pre><p>六、better-scroll滚动插件</p><pre><code>6.1 下载插件        npm install better-scroll -S 6.2 引入配置    import BetterScroll from &#39;better-scroll&#39;    let bs = new BetterScroll(&#39;.wrapper&#39;, &#123;      movable: true,      zoom: true    &#125;)    子元素高度比父元素高度要高，必须添加在mounted中</code></pre><p>七、vue中的ref ： 获取dom</p><pre><code>设置：&lt;div ref=&#39;aaa&#39;&gt;&lt;/div&gt;获取：this.$refs.aaa</code></pre><p>八、当dom更新完在加载?</p><pre><code>this.$nextTick(()=&gt;&#123;    &#125;)</code></pre><p>九、mint-ui</p><pre><code>9.1 下载    npm install mint-ui -S9.2 引入    import MintUI from &#39;mint-ui&#39;    import &#39;mint-ui/lib/style.css&#39;    Vue.use(MintUI)    </code></pre><p>十、axios 二次封装 </p><pre><code>在企业的项目中，肯定会对于axios进行二次封装，提升方便性和维护性</code></pre><p>十一、引入sass</p><pre><code>11.1 安装下载        npm install node-sass@4.14.1 -S    npm install sass-loader@8.x -S    12.2 使用        &lt;style scoped lang=&#39;scss&#39;&gt;&lt;/style&gt;    </code></pre><p>十二、better-scroll默认取消click事件</p><pre><code>解决：    new BetterScroll(this.$refs.left,&#123;        click:true    &#125;);    </code></pre><p>十三、etter-scroll默认取消scroll事件</p><pre><code>probeType：默认为0建议修改成：2|3</code></pre><p>十四、路由传值</p><pre><code>显式：    this.$router.push(&#123;        path:&#39;/detail&#39;,        query:&#123;            id        &#125;    &#125;)隐式：    this.$router.push(&#123;        name:&#39;Detail&#39;,        params:&#123;            id        &#125;    &#125;)</code></pre><p>十五、keep-alive : 是一个vue的内置组件</p><pre><code>作用：缓存组件优势：提升性能只要用到keep-alive会再多俩个生命周期 : activated、deactivated</code></pre><p>十六、接入短信验证码 SDK</p><pre><code>api链接：https://github.com/qcloudsms/qcloudsms_js16.1 下载    npm install qcloudsms_js    </code></pre><p>十七、vant</p><pre><code>17.1 下载    npm i vant -S    17.2 引入    import Vant from &#39;vant&#39;;    import &#39;vant/lib/index.css&#39;;    Vue.use(Vant);</code></pre><p>十八、token（令牌）</p><pre><code>18.1 什么是token：token是一个令牌，用来验证用户的。18.2 作用（场景） ： 验证用户18.3 token是后端生成的 , 并且token是不能重复的    1. 下载            npm install jsonwebtoken            2. 引入            require(&#39;jsonwebtoken&#39;);            3. 生成token语法                jwt.sign( 用户信息 , 口令 , 过期时间)        4. 解析token           jwt.decode(token);18.4 token使用流程：    1.客户端使用用户名跟密码请求登录    2.服务端收到请求，去验证用户名与密码    3.验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端    4.客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里    5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token    6.服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</code></pre><p>十九、对接支付宝沙箱(进行支付)nodejs</p><pre><code>api链接：https://github.com/alipay/alipay-sdk-nodejs-allapi链接：https://www.yuque.com/chenqiu/alipay-node-sdk/config-sdk***测试支付，一定要用无痕浏览</code></pre><p>二十、真机测试</p><pre><code>20.1 电脑和手机是同一个wifi20.2 运行项目        - Local:   http://localhost:8080/         - Network: http://192.168.1.109:8080/        20.3 vue.config.js    windows : ipconfig     mac     : ifconfig     module.exports = &#123;       devServer: &#123;         host: &#39;192.168.43.217&#39;, //ip写在这里        &#125;,    &#125;;        http://这里是ip地址:8080/        注意：http://必须加    </code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目中 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>茶七网小坑</title>
      <link href="/2022/11/10/%E8%8C%B6%E4%B8%83%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/11/10/%E8%8C%B6%E4%B8%83%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h3 id="keep-alive导致轮播图切换后不播放的问题"><a href="#keep-alive导致轮播图切换后不播放的问题" class="headerlink" title="keep-alive导致轮播图切换后不播放的问题"></a>keep-alive导致轮播图切换后不播放的问题</h3><p> keep-alive缓存组件的是created钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点。destroyed钩子则在组件被销毁的时候清除cache缓存中的所有组件实例。由此猜想，从其他页面跳回来时，显示的页面可能只是vnode节点，还有渲染出html标签就执行了new了swiper实例，导致swiper的实例无法挂在到实际的html元素上，所以出现轮播无法播放的问题。<br> 解决方案：<br> keep-aive组件支持两个钩子，activated钩子在keep-alive组件中代替了created钩子每次初始化时调用activated，deactivated为销毁时的钩子，所以可以申明一个状态，让keep-alive组件渲染成html元素后再实例化swiper,就可以解决这个bug。</p><h3 id="nodejs执行sql语句返回undefined"><a href="#nodejs执行sql语句返回undefined" class="headerlink" title="nodejs执行sql语句返回undefined"></a>nodejs执行sql语句返回undefined</h3><p>报错信息：<br>  code: ‘ER_BAD_FIELD_ERROR’,<br>  errno: 1054,<br>  sqlMessage: “Unknown column ‘123456d’ in ‘where clause’”,<br>  sqlState: ‘42S22’,<br>  index: 0,<br>  sql: ‘select * from userInfo where tel=13333333333 and pwd=123456d’<br> 解决方法：<br>   <code>select * from userInfo where tel=&#39;$&#123;option.userTel&#125;&#39; and pwd=&#39;$&#123;option.userPwd&#125;&#39;</code></p><h3 id="接入短信验证码SDK"><a href="#接入短信验证码SDK" class="headerlink" title="接入短信验证码SDK"></a>接入短信验证码SDK</h3><p> 腾讯云短信Node..js SDK<br> api链接： <a href="https://github.com/qcloudsms/qcloudsms_js">https://github.com/qcloudsms/qcloudsms_js</a><br> 代码：</p><script> // 接收前端传递的用户手机号  let userTel=req.body.userTel  // 短信应用SDK AppID  var appid = 1400187558;  // SDK AppID是1400开头// 短信应用SDK AppKey  var appkey = "dc9dc3391896235ddc2325685047edc7";// 需要发送短信的手机号码  var phoneNumbers = [userTel];// 短信模板ID，需要在短信应用中申请  var templateId = 285590;  // NOTE: 这里的模板ID`7839`只是一个示例，真实的模板ID需要在短信控制台中申请// 签名  var smsSign = "三人行慕课";  // NOTE: 这里的签名只是示例，请使用真实的已申请的签名, 签名参数使用的是`签名内容`，而不是`签名ID`// 实例化QcloudSms  var qcloudsms = QcloudSms(appid, appkey);  var ssender = qcloudsms.SmsSingleSender();  //往手机发送的验证码内容(6位随机数)  let params= [ Math.floor(Math.random()*(999999-100000))+100000 ]  ssender.sendWithParam(86, phoneNumbers[0], templateId,    params, smsSign, "", "",(error,response,resData)=>{      if(error) throw error      res.send({        code:200,        data:{          success:true,          data:response.req.body.params[0],          msg:'成功'        }      })    });</script><h3 id="关于nodejs的暴露方式"><a href="#关于nodejs的暴露方式" class="headerlink" title="关于nodejs的暴露方式:"></a>关于nodejs的暴露方式:</h3><p> 1.分别暴露：<br>   export const a=0<br>   按需引入： import {a} from xxx<br>   全部引入:  import * as Demo from xxx<br>   引入并暴露:export * as Demo from xxx<br> 2.统一暴露:<br>   const a = 10<br>   const getApp = () =&gt; { }<br>  export {<br>      a,<br>    getApp<br>  }<br>  按需引入：<br>  import {a,getApp} from ‘./test’<br>   全部引入:<br>  import * as Dome from ‘./test’<br>  引入并暴露:<br>  export * as Dome from ‘./test’ 暴露的为一个模块,对外暴露的实质是： {Dome:{a,getApp}}<br>3.默认暴露:<br>  书写一:<br>  export default {<br>    a(){},<br>    b:20,<br>  }<br>  书写二:<br>  const a=10,<br>  const b(){}<br>  export default {a, b}<br>    // 对外暴露的实质是 ： {default:{a,getBpp}}<br>  引入:   简写形式import Dome from ‘./test’<br>          完整形式:import {default as Dome} from ‘./test’<br>  引入并暴露:export {default as Dome} from ‘./test’  暴露的实质是：{Dome:{a,getBpp}}<br>  注意:默认暴露在进行引入并暴露时不能进行简写    </p><h3 id="vue组件过渡效果"><a href="#vue组件过渡效果" class="headerlink" title="vue组件过渡效果"></a>vue组件过渡效果</h3><p>(0)使用场景<br>    搭配标签消失/出现(v-show、v-if)产生效果<br>    搭配动态组件<component :is='x'></component>产生效果<br>    搭配:key生成销毁元素产生效果</p><p>(1)避免动画消失元素恢复原样<br>    因为动画会消失,所以配合js触发动画时改变元素样式到和动画最后一帧相同,就能避免动画消失后元素恢复原样</p><p>(2)添加动画模式<br>    自定义动画加载方式,还可以避免视图重绘出现动画混乱,如一个离开过渡的时候另一个开始进入过渡<br>    <transition mode='out-in'><br>        …<br>    </transition><br>    在transition标签上添加 mode=’out-in / in-out’<br>        out-in:当前元素过渡,过度完后新元素过渡进入<br>        in-out:新元素过渡,过度完成后当前元素过渡离开</p><p>(2.5)设置动画过渡时间:<br>    默认情况下,Vue会等待其在过渡效果的根元素的第一个transitionend或animationend事件。<br>    <transition :duration="1000" ><br>        …<br>    </transition><br>        :duration=”1000”    设置入场/出场动画都为1秒<br>        :duration=”{ enter: 500, leave: 800 }”   分别设置入场/出场动画时间</p><p>(2.6)设置首屏加载动画:<br>    无论是appear还是@appear钩子都会生成初始渲染过渡<br>    &lt;transition<br>        appear<br>        自定义类名首屏过渡:<br>          appear-class=”custom-appear-class”<br>          appear-to-class=”custom-appear-to-class”<br>          appear-active-class=”custom-appear-active-class”<br>        首屏过渡钩子:<br>          @before-appear=”customBeforeAppearHook”<br>          @appear=”customAppearHook”<br>          @after-appear=”customAfterAppearHook”<br>          @appear-cancelled=”customAppearCancelledHook”<br>    &gt;<br>        …<br>    </transition></p><p>(2.7)监听动画/过渡结束<br>    transitionend:监听过渡<br>    animationend:监听animation帧动画</p><pre><code>    &lt;transition type=&#39;类型&#39;&gt;        &lt;h1 v-if=&quot;show&quot; @transitionend=&quot;f1&quot;&gt;过渡&lt;/h1&gt;    &lt;/transition&gt;        默认将自动检测出持续时间长的为过渡事件类型。        若同一个元素同时使用了以上动画,比如animation很快的被触发并完成了,而transition效果还没结束        type=&#39;animation&#39;或&#39;transition&#39;,来明确声明需要Vue监听的类型。</code></pre><p>1、设置单个组件动画<br>    如:<br>        多个节点，每次只渲染一个<br>        单个节点</p><pre><code>(1)在要过渡的标签外层包裹    &lt;transition name=&#39;x&gt;    若不指定name,则类名对应为v-enter,...        ...    &lt;/transition&gt;    例:    &lt;transition&gt;      &lt;button v-if=&quot;docState === &#39;saved&#39;&quot; key=&quot;saved&quot;&gt;        Edit      &lt;/button&gt;      &lt;button v-else-if=&quot;docState === &#39;edited&#39;&quot; key=&quot;edited&quot;&gt;        Save      &lt;/button&gt;      &lt;button v-else-if=&quot;docState === &#39;editing&#39;&quot; key=&quot;editing&quot;&gt;        Cancel      &lt;/button&gt;    &lt;/transition&gt;(1.5)单个组件过渡  &lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;  &lt;/transition&gt;(2)在style中:    方式一:        设置淡出,以及淡出时间        .x-enter,.x-leave-to&#123;            opacity:0;        &#125;                .x-enter-to,.x-leave&#123;            opacity:1;        &#125;        设置淡入过程        .x-enter-active,.x-leave-active&#123;            transition:opacity 3s        &#125;    方式二:        这两种实现效果相同,因为元素本身出现默认opacity:1,利用了删类名,会自动过渡相应属性到之前的状态        .x-enter-active, .x-leave-active &#123;          transition: opacity .5s;        &#125;        .x-enter, .x-leave-to &#123;          opacity: 0;        &#125;      出现过程        x-enter-from: 定义进入过渡的开始状态,在元素被插入之前生效,在元素被插入之后的下一帧移除。        x-enter-active: 定义进入过渡生效时的状态,在整个进入过渡的阶段中应用,在元素被插入之前生效,在过渡/动画完成之后移除,这个类可以被用来定义进入过渡的过程时间,延迟和曲线函数。        x-enter-to: 定义进入过渡的结束状态,在元素被插入之后下一帧生效(与此同时v-enter-from被移除),在过渡/动画完成之后移除。     消失过程        x-leave-from: 定义离开过渡的开始状态,在离开过渡被触发时立刻生效,下一帧被移除。        x-leave-active: 定义离开过渡生效时的状态,在整个离开过渡的阶段中应用,在离开过渡被触发时立刻生效,在过渡/动画完成之后移除,这个类可以被用来定义离开过渡的过程时间,延迟和曲线函数。        x-leave-to: 定义离开过渡的结束状态,在离开过渡被触发之后下一帧生效(与此同时v-leave-from被删除),在过渡/动画完成之后移除。(3)自定义类名过渡 他们的优先级高于普通的类名  &lt;transition    enter-from-class=&#39;类名&#39;    enter-active-class=&#39;animated bounceIn&#39;        可结合第三方动画库,如Animate.css使用    enter-to-class    leave-from-class    leave-active-class    leave-to-class  &gt;(4)过渡钩子    &lt;transition      @before-enter=&quot;beforeEnter&quot;      @enter=&quot;enter&quot;      @after-enter=&quot;afterEnter&quot;      @enter-cancelled=&quot;enterCancelled&quot;          @before-leave=&quot;beforeLeave&quot;      @leave=&quot;leave&quot;      @after-leave=&quot;afterLeave&quot;      @leave-cancelled=&quot;leaveCancelled&quot;     ,leaveCancelled只用于v-show中            :css=&quot;false&quot;    当只用js过渡(即在这些钩子中通过js设置过渡等动画),设置该属性跳过CSS的检测以及避免过渡过程中CSS规则的影响    &gt;      ...    &lt;/transition&gt;          beforeEnter:function (el) &#123;&#125;,      enter:function (el, done) &#123;       (1)当与CSS结合使用时,回调函数done是可选的       (2)当只用JavaScript过渡的时候,在enter和leave中必须使用done进行回调       (3)推荐对于仅使用JavaScript过渡的元素添加:css=&quot;false&quot;,Vue会跳过CSS的检测,这也可以避免过渡过程中 CSS 的影响。        done();                  &#125;,      afterEnter:function (el) &#123;&#125;,      enterCancelled:function (el) &#123;&#125;,      beforeLeave:function (el) &#123;&#125;,      leave:function (el, done) &#123;       (1)当与CSS结合使用时,回调函数done是可选的       (2)当只用JavaScript过渡的时候,在enter和leave中必须使用done进行回调       (3)推荐对于仅使用JavaScript过渡的元素添加:css=&quot;false&quot;,Vue会跳过CSS的检测,这也可以避免过渡过程中 CSS 的影响。        done();          &#125;,      afterLeave:function (el) &#123;&#125;,      leaveCancelled:function (el) &#123;          leaveCancelled只用于v-show中      &#125;</code></pre><p>2、过渡相同标签切换设置key来区分<br>    当有相同标签名的元素切换时,需要通过key设置唯一的值来标记以让Vue区分它们,否则为了效率只会替换相同标签内部的内容,即使在技术上没有必要,给在<transition>组件中的多个元素设置key是一个更好的实践。<br>    <transition><br>      <button v-if="isEditing" key="save">Save</button><br>      <button v-else key="edit">Edit</button><br>    </transition></p><p>3、列表过渡<br>    (1)效果:同时渲染整个列表,且列表的每个元素都具有动画</p><pre><code>(2)和transition区别:    不同于 &lt;transition&gt;,它会以一个真实元素呈现:默认为一个 &lt;span&gt;,指定tag更换为其他元素。    过渡模式mode不可用，因为我们不再相互切换特有的元素。    内部元素总是需要提供唯一的key值。    CSS过渡的类将会应用在内部的元素中,而不是这个组/容器本身。(3)钩子函数、过渡css、自定义类名、首屏加载和&lt;transition&gt;相同示例:    &lt;transition-group name=&#39;x&#39; tag=&#39;p&#39;&gt;            &lt;li v-for=&#39;xx in xxx&#39;  :key=&#39;唯一标识&#39;&gt;&#123;&#123;xx&#125;&#125;&lt;/li&gt;    &lt;/transition-group&gt;    (5)在元素从屏幕上的位置发生变化的过程中添加css类    .x-move&#123;        ...    &#125;    或    &lt;transition-group name=&#39;x&#39; tag=&#39;p&#39; move-class=&quot;类名&quot;&gt;        ...    &lt;/transition-group&gt;    示例：    .list-move, /* 对移动中的元素应用的过渡 */    .list-enter-active,    .list-leave-active &#123;      transition: all 0.5s ease;    &#125;        .list-enter-from,    .list-leave-to &#123;      opacity: 0;      transform: translateX(30px);    &#125;        /* 确保将离开的元素从布局流中删除      以便能够正确地计算移动的动画。 */    .list-leave-active &#123;      position: absolute;    &#125;(4)增删元素时,其他元素具有位移过渡    FLIP简单的动画队列使用transforms将元素从之前的位置平滑过渡新的位置。        .list-complete-item &#123;    列表每个元素的类,设置过渡时间和显示类型      transition: all 0.8s ease;      display: inline-block;    只能为display: inline-block或者放置于flex中    &#125;        .list-complete-enter-from,    .list-complete-leave-to &#123;      opacity: 0;      transform: translateY(30px);        &#125;        .list-complete-leave-active &#123;    必须在离开期间添加脱离文档流的定位(在删除元素时)      position: absolute;    &#125;</code></pre><h3 id="Token相关"><a href="#Token相关" class="headerlink" title="Token相关"></a>Token相关</h3><p>作用:验证用户<br>定义:Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。<br>目的:减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮<br>如何使用:<br>      1、用设备号/设备mac地址作为Token（推荐）<br>    客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。<br>    服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。<br>      2、用session值作为Token<br>    客户端：客户端只需携带用户名和密码登陆即可。<br>    服务端：服务端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。</p><p>npm install jsonwebtoken</p><h3 id="vuex数据问题"><a href="#vuex数据问题" class="headerlink" title="vuex数据问题"></a>vuex数据问题</h3><p>1.使用getters获取是否全选的数据时，使用this.$store.getters.isCheckedAll 数据为undefined<br>解决方法：this.$store.getters[“cart/isCheckedAll”]</p><h3 id="数组方法："><a href="#数组方法：" class="headerlink" title="数组方法："></a>数组方法：</h3><h2 id="indexOf的定义和使用"><a href="#indexOf的定义和使用" class="headerlink" title="indexOf的定义和使用"></a>indexOf的定义和使用</h2><p>indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。<br>stringObject.indexOf(searchvalue,fromindex)</p><p>searchvalue：必需。规定需要检索的字符串值<br>fromindex：可选的整数参数。规定字符串中开始检索的位置。它的合法取值是0到stringObject.length-1。如省略该参数，则将从字符串的首字符开始检索。<br>如果要检索的字符串值没有出现，则该方法返回-1</p><p>说明：该方法将从头到尾的检索字符串stringObject，看它是否含有子串searchvalue。开始检索的位置在字符串的fromindex处或字符串的开头（没有指定fromindex时）。如果找到一个searchvalue，则返回searchvalue的第一次出现的位置。<br>stringObject中的字符串位置是从0开始的。</p><p>具体应用说明<br>String类型的使用：<br>返回指定字符串在此字符串中第一次出现的索引。</p><p>let str = ‘apple’;<br>str.indexOf(‘a’); //0<br>str.indexOf(‘l’); //3</p><p>let str=’2016’;<br>str.indexOf(2); //0<br>str.indexOf(‘1’); //0<br>//说明indexOf会对字符串内的数字做简单的类型转换，把数字2转换成字符串’2’然后执行。<br>Number类型的使用：<br>indexOf不会对number类型做隐式转换，如下：</p><p>let num = 2016;<br>num.indexOf(2); //Uncaught TypeError: num.indexOf is not a function</p><p>所以，如果非要对number类型使用indexOf方法的话，可以将number转换成字符串然后使用：</p><p>let num = 2016;<br>num.toString().indexOf(2); //0<br>//或者<br>(‘’+num).indexOf(2); //0</p><p>Array类型的使用<br>let array = [‘hello’,’2017’,’coco’];<br>array.indexOf(‘hello’); //0<br>array.indexOf(‘o’); //-1<br>array.indexOf(‘2017’); //1<br>array.indexOf(2017); //-1</p><p>array.indexOf(‘hello’)输出0 是因为’hello’是数组的第0个因素，匹配到并返回下标。<br>array.indexOf(‘o’)输出-1 是因为indexOf方法不会在每一个元素的基础上再次执行indexOf匹配。<br>array.indexOf(‘2017’)输出1 是因为此方法从头匹配直到匹配到返回第一个数组元素的下标，而不是返回全部匹配的下标。<br>array.indexOf(2017) 输出-1 这里不会做隐式类型转换。</p><h3 id="路由路径传值问题"><a href="#路由路径传值问题" class="headerlink" title="路由路径传值问题"></a>路由路径传值问题</h3><p>问题：在路由传值时,起初没有对数据进行解析,导致下一个页面得到的值出现问题，页面刷新后数据丢失,格式变为字符串数组<br>解决方法：<br>        传值：<br>        this.$router.push({//跳转到订单页<br>             path:’/order’,<br>             query:{<br>               detail:JSON.stringify(this.selectList),<br>               goodsList:JSON.stringify(this.getList)  //选中的商品的相关信息<br>             }<br>           })<br>        接收：let data=JSON.parse(this.$route.query.goodList)   </p><h3 id="go-1-跳转携带参数"><a href="#go-1-跳转携带参数" class="headerlink" title="go(-1)跳转携带参数"></a>go(-1)跳转携带参数</h3><p>import Vue from ‘vue’</p><p>/**</p><ul><li>定义空的vue实例，作为 eventbus实现非父子组件之间的通信(vue2.x中去掉了broadcast)</li><li>/<br>var eventBus = new Vue({});<br>export default eventBus;</li></ul><p>传参给上一页面：<br>import eventBus from ‘../service/eventbus.js’;<br>methods:{<br>    //列表选中具体医院的点击事件<br>    goback(hospital){<br>        //传递一个map，choiceHospital是key，hospital是value<br>        eventBus.$emit(‘choiceHospital’,hospital);<br>        //调用router回退页面<br>        this.$router.go(-1);<br>    }<br>}<br>接收参数：<br>import eventBus from ‘../service/eventbus.js’;</p><p>//每次激活时（需要使用keep-alive）<br>activated(){<br>    //根据key名获取传递回来的参数，data就是map<br>    eventBus.$on(‘choiceHospital’, function(data){<br>        //赋值给首页的附近医院数据模型<br>        this.nearestOrg = data;<br>    }.bind(this));<br>},</p><h3 id="对接支付宝沙箱"><a href="#对接支付宝沙箱" class="headerlink" title="对接支付宝沙箱"></a>对接支付宝沙箱</h3><p> 1.进入网站<br> 2.登录支付宝<br> 3.填写信息<br> 4.进入沙箱环境<br> 5.下载支付宝开放平台开发助手<br> 6.生成密钥<br> 7.进入沙箱环境<br> 8.粘贴公钥<br> 9.对接支付宝沙箱nodejs<br> 创建js文件<br>  对象支付宝沙箱<br> 引入SDK<br>const AlipaySdk=require(‘alipay-sdk’).default<br>const alipaySdk=new AlipaySdk({<br>  appId:’2021000121669905’,<br>  signType:’RSA2’,//签名算法<br>  gateway:’<a href="https://openapi.alipaydev.com/gateway.do&#39;,//%E6%94%AF%E4%BB%98%E5%AE%9D%E7%BD%91%E5%85%B3">https://openapi.alipaydev.com/gateway.do&#39;,//支付宝网关</a><br>  alipayPublicKey:’’//支付宝公钥<br>  privateKey:’, // 应用私钥<br>})<br>module.exports=alipaySdk</p><p>//引入：</p><script>    // 引入沙箱配置const  alipaySdk=require('../db/alipay')const AlipayFormData=require('alipay-sdk/lib/form').default // 对接支付宝api  const formData=new AlipayFormData()  // 调用并传入get,会返回可以跳转到支付页面的url  formData.setMethod('get')  // 支付时的信息  formData.addField('bizContent',{    outTradeNo:'', //订单号    productCode:'FAST_INSTANT_TRADE_PAY', //写死    totalAmount:totalPrice,//商品总价    subject:nameArr,//商品名称  })  // 支付成功或失败跳转的链接  formData.addField('returnUrl','http://localhost:8080/payment')  const result=alipaySdk.exec(    'alipay.trade.page.pay',    {},    {formData:formData},  )  // 对接支付宝成功,支付宝返回的数据  result.then(response=>{    res.send({      data:{        code:200,        success:true,        msg:'支付中',        paymentUrl:response      }    })  })</script><h3 id="未登录页面的拦截"><a href="#未登录页面的拦截" class="headerlink" title="未登录页面的拦截"></a>未登录页面的拦截</h3><p>问题：在未登录状态下,让页面跳转到登录页面<br>方法：在路由配置中,创建router之后</p><script>    // 路由守卫    router.beforeEach((to,from,next)=>{  let nextRoutes=['order','payment','Cart','addressIndex','addAddress'] //需要拦截的路由的name值  // 是否是登录状态(在本地存储中找)  let userInfo=JSON.parse(localStorage.getItem('teaUserInfo'))  // 当前进入的页面,是否需要进行验证  if(nextRoutes.indexOf(to.name)>=0){    if(!userInfo){      router.push('/login')    }  }  next()  //必须使用next,否则页面无法加载})</script><h3 id="报错Avoided-redundant-navigation-to-current-location"><a href="#报错Avoided-redundant-navigation-to-current-location" class="headerlink" title="报错Avoided redundant navigation to current location"></a>报错Avoided redundant navigation to current location</h3><p>原因：重复路由跳转<br>解决方法：1.npm i <a href="mailto:&#x76;&#x75;&#x65;&#x2d;&#114;&#111;&#x75;&#116;&#x65;&#x72;&#64;&#51;&#46;&#x30;">&#x76;&#x75;&#x65;&#x2d;&#114;&#111;&#x75;&#116;&#x65;&#x72;&#64;&#51;&#46;&#x30;</a> -S<br>          2.修改VueRouter原型对象上的push和replace方法，在router文件夹下的index.js中加入如下代码：</p><script>                  //获取原型对象上的push函数        const originalPush = VueRouter.prototype.push        const originalReplace=VueRouter.prototype.replace        //修改原型对象中的push方法        VueRouter.prototype.push = function push(location) {          return originalPush.call(this, location).catch(err => err)        }        VueRouter.prototype.replace = function replace(location) {          return originalReplace.call(this, location).catch(err => err)        }</script><p>原理：location对象保存当前跳转路径<br>      call()函数改变调用的同时改变this指向<br>      第一个参数this:由于call处于原型对象内部，所以此处this指向的是当前VueRouter的实例对象。而originalPush指向的是VueRouter.prototype.push。旨在于调用当前VueRouter实例对象中的push方法<br>      第二个参数location:在方法调用时传入获取到的location。<br>      catch:链式调用catch方法,捕获错误并抛出</p><pre><code>  this指向复习：1.一般情况下，谁调用了函数，this就指向谁。2.普通函数就指向了window。3.构造函数和原型对象里面的this都是指向实例对象。4.绑定事件的函数就是事件绑定的对象。5.定时器的函数this指向的也是window。6.立即执行函数指向的也是window。</code></pre><h3 id="同一页面多次搜索不刷新页面"><a href="#同一页面多次搜索不刷新页面" class="headerlink" title="同一页面多次搜索不刷新页面"></a>同一页面多次搜索不刷新页面</h3><p>问题描述：茶七网项目中,搜索模块进入搜索页面后，再次输入关键词搜索页面不刷新内容(地址栏发生变化)<br>解决方案：监听路由的参数,当关键词改变时，重新发送ajax请求数据</p><script>                 watch:{                    $route(to,from){                      if(to.name==='searchList'){                        // console.log(to.query.key,from.query.key)                        let value=to.query.key//传递的参数                        this.getData(value)//请求数据的方法,实参为传递的参数                      }                    }</script>]]></content>
      
      
      <categories>
          
          <category> 小问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5配置</title>
      <link href="/2022/10/26/webpack5%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/10/26/webpack5%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack5基本配置"><a href="#webpack5基本配置" class="headerlink" title="webpack5基本配置"></a>webpack5基本配置</h1><h2 id="为什么需要打包工具？"><a href="#为什么需要打包工具？" class="headerlink" title="为什么需要打包工具？"></a>为什么需要打包工具？</h2><blockquote><p>开发时，我们会使用框架（React、Vue），ES6 模块化语法，Less/Sass 等 css 预处理器等语法进行开发。这样的代码要想在浏览器运行必须经过编译成浏览器能识别的 JS、Css 等语法，才能运行。所以我们需要打包工具帮我们做完这些事。除此之外，打包工具还能压缩代码、做兼容性处理、提升代码性能等。</p></blockquote><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>1.资源目录</p><p>它会以一个或多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或多个文件输出出去。</p><p>输出的文件就是编译好的文件，就可以在浏览器段运行了。</p><p>我们将 <code>Webpack</code> 输出的文件叫做 <code>bundle</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpack_code # 项目根目录（所有指令必须在这个目录运行）</span><br><span class="line">    └── src # 项目源码目录</span><br><span class="line">        ├── js # js文件目录</span><br><span class="line">        │   ├── count.<span class="property">js</span></span><br><span class="line">        │   └── sum.<span class="property">js</span></span><br><span class="line">        └── main.<span class="property">js</span> # 项目主文件</span><br></pre></td></tr></table></figure><ol start="2"><li>下载依赖</li></ol><blockquote><p>打开终端，来到项目根目录。运行以下指令：</p></blockquote><ul><li>初始化<code>package.json</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>此时会生成一个package.json文件,注意里面的name字段不能为webpack,否则会报错</p><blockquote><p>下载开发者依赖</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>4.启用webpack</p><ul><li><p>开发模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.<span class="property">js</span> --mode=development</span><br></pre></td></tr></table></figure></li><li><p>生产模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.<span class="property">js</span> --mode=production</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>npx webpack</code>: 用来运行本地安装 <code>Webpack</code> 包。</p></blockquote><blockquote><p><code>./src/main.js</code>: 指定 <code>Webpack</code> 从 <code>main.js</code> 文件开始打包，不但会打包 <code>main.js</code>，还会将其依赖也一起打包进来。</p></blockquote><blockquote><p><code>--mode=xxx</code>：指定模式（环境）。</p></blockquote><ol start="5"><li>观察输出文件</li></ol><p>默认 <code>Webpack</code> 会将文件打包输出到 <code>dist</code> 目录下，我们查看 <code>dist</code> 目录下文件情况就好了</p><h2 id="五大核心概念"><a href="#五大核心概念" class="headerlink" title="五大核心概念"></a>五大核心概念</h2><p> 1.entry（入口）：指示 Webpack 从哪个文件开始打包</p><p> 2.output（输出）指示 Webpack 打包完的文件输出到哪里去，如何命名等</p><p>3.loader（加载器）：webpack 本身只能处理 js、json 等资源，其他资源需要借助  loader，Webpack 才能解析</p><p>4.plugins（插件）：扩展 Webpack 的功能</p><p>5.mode（模式）:- 开发模式：development（）- 生产模式：productio</p><blockquote><p>（1）开发者模式：<br>这个模式下我们主要做两件事：</p></blockquote><p>(1)编译代码，使浏览器能识别运行<br>开发时我们有样式资源、字体图标、图片资源、html 资源等，webpack 默认都不能处理这些资源，所以我们要加载配置来编译这些资源</p><p>(2)代码质量检查，树立代码规范<br>提前检查代码的一些隐患，让代码运行时能更加健壮。<br>提前检查代码规范和格式，统一团队编码风格，让代码更优雅美观。</p><blockquote><p>(2)生产模式:</p></blockquote><p>开发完成代码后，我们需要得到代码将来部署上线。这个模式下我们主要对代码进行优化，让其运行性能更好。</p><p>这个模式我们主要做：</p><p>(1)优化代码运行性能</p><p>(2)优化代码打包速度</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><blockquote><p>webpack.config.js中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&quot;./src/main.js&quot;</span>,<span class="comment">//相对路径</span></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="comment">// __dirname nodejs的变量,代表当前文件的文件夹目录</span></span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;dist&quot;</span>),<span class="comment">//所有文件的输出目录，绝对路径</span></span><br><span class="line">        <span class="comment">// filename:&quot;main.js&quot;,//文件名</span></span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 入口文件输出文件名</span></span><br><span class="line">        <span class="attr">clean</span>:<span class="literal">true</span>,<span class="comment">//打包前将dist目录整个清空</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            <span class="comment">// loader配置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,<span class="comment">//只检测css结尾的文件</span></span><br><span class="line">                <span class="attr">use</span>:[</span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,<span class="comment">//将js中的css通过创建style标签添加的html中</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>, <span class="comment">//将css资源编译为commonjs的模块到js中</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.less$/</span>,<span class="comment">//只检测less结尾的文件</span></span><br><span class="line">                <span class="attr">use</span>:[</span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;less-loader&quot;</span><span class="comment">//less编译为css文件</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.s[ac]ss$/</span>,<span class="comment">//只检测.sass/.scss结尾的文件</span></span><br><span class="line">                <span class="attr">use</span>:[</span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sass-loader&quot;</span><span class="comment">//sass编译为css文件</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.styl$/</span>,<span class="comment">//只检测.sass/.scss结尾的文件</span></span><br><span class="line">                <span class="attr">use</span>:[</span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;stylus-loader&quot;</span><span class="comment">//stylus编译为css文件</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.ts$/</span>,<span class="comment">//只检测.ts结尾的文件</span></span><br><span class="line">                <span class="attr">use</span>:[<span class="string">&quot;ts-loader&quot;</span>],<span class="comment">//将ts文件编译为js文件</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/\.(png|jpe?g|gif|webp|svg)$/</span>,<span class="comment">//只检测图片文件</span></span><br><span class="line">                <span class="attr">type</span>:<span class="string">&quot;asset&quot;</span>,<span class="comment">//将ts文件编译为js文件</span></span><br><span class="line">                <span class="attr">parser</span>:&#123;</span><br><span class="line">                    <span class="attr">dataUrlCondition</span>:&#123;</span><br><span class="line">                        <span class="comment">// 小于10kb的图片转base64</span></span><br><span class="line">                        <span class="comment">// 优点：减少请求数量 缺点：体积更大</span></span><br><span class="line">                        <span class="attr">maxSize</span>:<span class="number">10</span>*<span class="number">1024</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//输出文件对应的名称</span></span><br><span class="line">                <span class="attr">generator</span>:&#123;</span><br><span class="line">                    <span class="attr">filename</span>:<span class="string">&quot;static/images/[hash:10][ext][query]&quot;</span>,<span class="comment">//hash:图片id（唯一）,ext:扩展名，query:携带参数</span></span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 扩展</span></span><br><span class="line">    <span class="attr">plugins</span>:[],</span><br><span class="line">    <span class="comment">// 模式</span></span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&quot;development&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动清空上次打包资源"><a href="#自动清空上次打包资源" class="headerlink" title="自动清空上次打包资源"></a>自动清空上次打包资源</h2><p>1.配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">// 自动将上次打包目录资源清空</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="处理字体图标以及音视频文件资源"><a href="#处理字体图标以及音视频文件资源" class="headerlink" title="处理字体图标以及音视频文件资源"></a>处理字体图标以及音视频文件资源</h2><p>1.下载字体图标资源到src下的fonts目录下</p><p>2.在src下main.js中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/iconfont.css&quot;</span>;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>在public下index.<span class="property">html</span>中使用字体图标</span><br><span class="line"><span class="string">``</span><span class="string">`html</span></span><br><span class="line"><span class="string"> &lt;i class=&quot;iconfont icon-arrow-down&quot;&gt;&lt;/i&gt;</span></span><br></pre></td></tr></table></figure><p>4.添加配置webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?|map4|map3|avi)$/</span>,<span class="comment">//处理音频视频以及字体图标</span></span><br><span class="line"><span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>注意此处asset与asset/resource的区别：</p></blockquote><blockquote><p>type: “asset/resource” 相当于file-loader, 将文件转化成 Webpack 能识别的资源，其他不做处理</p></blockquote><blockquote><p>type: “asset” 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式</p></blockquote><p>5.npx webpack 查看打包结果</p><h2 id="处理js资源"><a href="#处理js资源" class="headerlink" title="处理js资源"></a>处理js资源</h2><p>有人可能会问，js 资源 Webpack 不能已经处理了吗，为什么我们还要处理呢？</p><p> 1.Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编他语法所以需要做一些兼容性处理</p><p> 2.其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。</p><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><blockquote><p>简介：可组装的 JavaScript 和 JSX 检查工具。</p></blockquote><p>这句话意思就是：它是用来检测 js 和 jsx 语法的工具，可以配置各项功能,我们使用 Eslint，关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查</p><h5 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h5><blockquote><p>1）.eslintrc.* ：新建文件，位于项目根目录.eslintrc.*，eslintrc.js，.eslintrc.json</p></blockquote><blockquote><p>2）<code>package.json</code>中配置<code>eslintConfig</code>:无需创建文件,在原有文件基础上写</p></blockquote><h5 id="2-具体配置"><a href="#2-具体配置" class="headerlink" title="2.具体配置"></a>2.具体配置</h5><p>以<code>.eslintrc.js</code>为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 解析选项</span></span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">     <span class="attr">ecmaVersion</span>: <span class="number">6</span>, <span class="comment">// ES 语法版本</span></span><br><span class="line">     <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">// ES 模块化</span></span><br><span class="line">     <span class="attr">ecmaFeatures</span>: &#123; <span class="comment">// ES 其他特性</span></span><br><span class="line">     <span class="attr">jsx</span>: <span class="literal">true</span> <span class="comment">// 如果是 React 项目，就需要开启 jsx 语法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 具体检查规则:off/0关闭规则，warn/1开启规则(警告级别错误),error/2开启规则（错误级别错误,处罚时程序退出）更多rules规则：【规则文档】(https://eslint.bootcss.com/docs/rules/)</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="attr">semi</span>: <span class="string">&quot;error&quot;</span>, <span class="comment">// 禁止使用分号</span></span><br><span class="line">        <span class="string">&#x27;array-callback-return&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>, <span class="comment">// 强制数组方法的回调函数中   有 return 语句，否则警告</span></span><br><span class="line">        <span class="string">&#x27;default-case&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;warn&#x27;</span>, <span class="comment">// 要求 switch 语句中有 default 分支，否则警告</span></span><br><span class="line">         &#123; <span class="attr">commentPattern</span>: <span class="string">&#x27;^no default$&#x27;</span> &#125; <span class="comment">// 允许在最后注释 no     default, 就不会有警告了</span></span><br><span class="line">         ],</span><br><span class="line">         <span class="attr">eqeqeq</span>: [</span><br><span class="line">        <span class="string">&#x27;warn&#x27;</span>, <span class="comment">// 强制使用 === 和 !==，否则警告</span></span><br><span class="line">         <span class="string">&#x27;smart&#x27;</span> <span class="comment">// https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 继承其他规则</span></span><br><span class="line">  <span class="attr">extends</span>: [],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>extends 继承</p><p>开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。</p><blockquote><p>Eslint 官方的规则：eslint:recommended</p></blockquote><blockquote><p>Vue Cli 官方的规则：plugin:vue/essential</p></blockquote><blockquote><p>React Cli 官方的规则：react-app</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如在React项目中，我们可以这样写配置</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;react-app&quot;</span>],</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 我们的规则会覆盖掉react-app的规则</span></span><br><span class="line">    <span class="comment">// 所以想要修改规则直接改就是了</span></span><br><span class="line">    <span class="attr">eqeqeq</span>: [<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;smart&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="在webpack中使用Eslint"><a href="#在webpack中使用Eslint" class="headerlink" title="在webpack中使用Eslint"></a>在webpack中使用Eslint</h5><p>1.下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-webpack-plugin eslint -D</span><br></pre></td></tr></table></figure><p>2.创建配置文件 <code>.eslintrc.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 继承 Eslint 规则</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>, <span class="comment">// 启用node中全局变量</span></span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>, <span class="comment">// 启用浏览器中全局变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">6</span>,<span class="comment">//es版本</span></span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span>, <span class="comment">// 不能使用 var 定义变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.配置webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);<span class="comment">//引入扩展</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>4.vscode下载 Eslint插件</p><blockquote><p>下载插件后可以不编译就看到错误,此时默认会对项目所有文件默认进行 Eslint 检查了，我们 dist 目录下的打包后文件就会报错。但是我们只需要检查 src 下面的文件，不需要检查 dist 下面的文件。所以需要创建忽略文件:<code>.eslintignore</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#忽略dist目录下所有文件</span><br><span class="line">dist</span><br></pre></td></tr></table></figure><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><blockquote><p>简介：主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中</p></blockquote><h5 id="1-配置文件-1"><a href="#1-配置文件-1" class="headerlink" title="1.配置文件"></a>1.配置文件</h5><p>1).新建 <code>babel.config.js/json</code> 位于项目根目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="comment">// 预设</span></span><br><span class="line">    <span class="attr">presets</span>:[],</span><br><span class="line">    <span class="comment">// 预设简单理解就是一组babel插件，用来扩展babel功能</span></span><br><span class="line">    <span class="comment">//@babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript。</span></span><br><span class="line">    <span class="comment">//@babel/preset-react：一个用来编译 React jsx 语法的预设</span></span><br><span class="line">    <span class="comment">//@babel/preset-typescript：一个用来编译 TypeScript 语法的预设</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2).新建 <code>.babelrc.js/json</code>  位于项目根目录</p><p>3).package.json中配置<code>babel</code> </p><h5 id="2-在webpack中使用babel"><a href="#2-在webpack中使用babel" class="headerlink" title="2.在webpack中使用babel"></a>2.在webpack中使用babel</h5><p>1.下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure><p>2.配置babel.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.配置webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">             <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules代码不编译</span></span><br><span class="line">             <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理Html资源"><a href="#处理Html资源" class="headerlink" title="处理Html资源"></a>处理Html资源</h2><p>1.下载扩展</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>2.配置webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span>=<span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">        <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">       <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;public/index.html&quot;</span>),</span><br><span class="line">    &#125;) </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>3.去掉public下index.html文件中引入的js文件,HtmlwebPackPlugin会自动引入</p><h2 id="webpack开发服务器-amp-自动化"><a href="#webpack开发服务器-amp-自动化" class="headerlink" title="webpack开发服务器&amp;自动化"></a>webpack开发服务器&amp;自动化</h2><p>1.配置webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&quot;src/main.js&quot;</span>,<span class="comment">//入口文件</span></span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">reslove</span>(__dirname,<span class="string">&quot;dist&quot;</span>),<span class="comment">//输出目录</span></span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;static/js/main.js&quot;</span>,<span class="comment">//js文件输出目录</span></span><br><span class="line">        <span class="attr">clean</span>:<span class="literal">true</span>,<span class="comment">//打包前删除dist目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">            <span class="attr">parser</span>: &#123;</span><br><span class="line">                  <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                      <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">                  &#125;,</span><br><span class="line">             &#125;,</span><br><span class="line">            <span class="attr">generator</span>: &#123;</span><br><span class="line">                 <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">                 <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">                 <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">                  <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">                  <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">                  <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">                       &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugin</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">             <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">             <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;src&quot;</span>),</span><br><span class="line">         &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">             <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">            <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;public/index.html&quot;</span>),</span><br><span class="line">         &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 开发服务器</span></span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">        <span class="attr">host</span>:<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="attr">port</span>:<span class="string">&quot;3000&quot;</span>,</span><br><span class="line">        <span class="attr">open</span>:<span class="literal">true</span>,<span class="comment">//是否自动打开浏览器</span></span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&quot;development&quot;</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.运行开发服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve</span><br></pre></td></tr></table></figure><blockquote><p>注意:当使用开发服务器时,所有代码都会在内存中编译打包，不会输出到dist目录下，我们只需要关注代码是否有效果即可</p></blockquote><h2 id="生产模式准备"><a href="#生产模式准备" class="headerlink" title="生产模式准备"></a>生产模式准备</h2><p>1.创建两个配置文件分别存放不同模式的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── webpack-test (项目根目录)</span><br><span class="line">    ├── config (Webpack配置文件目录)</span><br><span class="line">    │    ├── webpack.dev.js(开发模式配置文件)</span><br><span class="line">    │    └── webpack.prod.js(生产模式配置文件)</span><br><span class="line">    ├── node_modules (下载包存放目录)</span><br><span class="line">    ├── src (项目源码目录，除了html其他都在src里面)</span><br><span class="line">    │    └── 略</span><br><span class="line">    ├── public (项目html文件)</span><br><span class="line">    │    └── index.html</span><br><span class="line">    ├── .eslintrc.js(Eslint配置文件)</span><br><span class="line">    ├── babel.config.js(Babel配置文件)</span><br><span class="line">    └── package.json (包的依赖管理配置文件)</span><br></pre></td></tr></table></figure><p>2.修改webpack.dev.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="literal">undefined</span>, <span class="comment">// 开发模式没有输出，不需要指定输出目录</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="comment">// clean: true, // 开发模式没有输出，不需要清空输出结果</span></span><br><span class="line">&#125;,</span><br><span class="line"> <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),<span class="comment">//路径改变</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),<span class="comment">//路径改变</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>运行开发模式命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve --config ./config/webpack.dev.js</span><br></pre></td></tr></table></figure><p>3.修改webpack.prod.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">   <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">   <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">   <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">//生产模式不用开发服务器</span></span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line"> <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line"> <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line"> <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line"> <span class="comment">// &#125;,</span></span><br></pre></td></tr></table></figure><p>运行生产模式命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --config ./config/webpack.prod.js</span><br></pre></td></tr></table></figure><p>4.为了方便在不同模式下运行，我们将指令定义在<code>package.json</code>中的<code>scripts</code>中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx webpack serve --config ./config/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx webpack --config ./config/webpack.prod.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>开发模式启动命令：npm start 或 npm run dev</p></blockquote><blockquote><p>生产模式启动命令：npm run build</p></blockquote><h2 id="Css资源处理"><a href="#Css资源处理" class="headerlink" title="Css资源处理"></a>Css资源处理</h2><h3 id="提取css单独文件"><a href="#提取css单独文件" class="headerlink" title="提取css单独文件"></a>提取css单独文件</h3><blockquote><p>Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式，这样对于网站来说，会出现闪屏现象，用户体验不好，我们应该是单独的 Css 文件，通过 link 标签加载性能才好</p></blockquote><p>1.下载扩展 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>2.配置webback.prod.js(生产模式配置文件)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span>=<span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">         &#123;</span><br><span class="line">        <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">plugin</span>:[</span><br><span class="line">     <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">mode</span>:<span class="string">&quot;production&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="css兼容性处理"><a href="#css兼容性处理" class="headerlink" title="css兼容性处理"></a>css兼容性处理</h3><p>1.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-loader postcss postcss-preset-env -D</span><br></pre></td></tr></table></figure><p>2.配置<code>webpack.prod.js</code></p><p>在module的rules给css(less,sass,stylu)相关规则添加配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="comment">// 用来匹配 .css 结尾的文件(同理，其他lee,sass,styl都需要配置)</span></span><br><span class="line">       <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">       <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">       <span class="attr">use</span>: [</span><br><span class="line">         <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">         <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">         <span class="comment">//更改配置形式</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">           <span class="attr">options</span>: &#123;</span><br><span class="line">             <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">               <span class="attr">plugins</span>: [</span><br><span class="line">                 <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">               ],</span><br><span class="line">             &#125;,</span><br><span class="line">           &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">       ],</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p>3.控制兼容性</p><p>在<code>package.json</code>中添加<code>browserslist</code>来控制兼容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ie &gt;= 8&quot;</span><span class="punctuation">]</span> <span class="comment">//兼容ie8以上</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>更多<code>browserslist</code>配置请参考【官方文档】(<a href="https://github.com/browserslist/browserslist">https://github.com/browserslist/browserslist</a>)</p><p>实际开发中我们一般不考虑旧版本浏览器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;last 2 version&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&gt; 1%&quot;</span><span class="punctuation">,</span> <span class="string">&quot;not dead&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>4.合并配置 <code>webpack.prod.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取处理样式的Loaders</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">                 <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                 <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">                  <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">            &#125;,</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//sass,less等配置相同，使用use:getStyleLoaders()替换之前的配置</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h3><p>1.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>2.配置<code>webpack.prod.js</code></p><p>```js<br>const CssMinimizerPlugin = require(“css-minimizer-webpack-plugin”);<br>…</p><p>plugins:[<br>    …<br>    new CssMinimizerPlugin()//css压缩<br>]</p><blockquote><p>注意：生产模式默认开启了html压缩和js压缩，不需要额外进行配置哦</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript使用</title>
      <link href="/2022/10/26/TypeScript%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/26/TypeScript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、TypeScript安装"><a href="#一、TypeScript安装" class="headerlink" title="一、TypeScript安装"></a>一、TypeScript安装</h1><p>TypeScript 的命令行工具安装方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line">//使用ts的node</span><br><span class="line">npm i -g ts-node</span><br></pre></td></tr></table></figure><p>以上命令会在全局环境下安装 <code>tsc</code> 命令，安装完成之后，我们就可以在任何地方执行 <code>tsc</code> 命令了。</p><p>编译一个 TypeScript 文件很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>我们约定使用 TypeScript 编写的文件以 <code>.ts</code> 为后缀，用 TypeScript 编写 React 时，以 <code>.tsx</code> 为后缀。</p><h1 id="二、Hello-TypeScript"><a href="#二、Hello-TypeScript" class="headerlink" title="二、Hello TypeScript"></a>二、Hello TypeScript</h1><p>我们从一个简单的例子开始。</p><p>将以下代码复制到 <code>hello.ts</code> 中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>这时候会生成一个编译好的文件 <code>hello.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，我们使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以。</p><p>上述例子中，我们用 <code>:</code> 指定 <code>person</code> 参数类型为 <code>string</code>。但是编译为 js 之后，并没有什么检查的代码被插入进来。</p><p>这是因为 <strong>TypeScript 只会在编译时对类型进行静态检查，如果发现有错误，编译的时候就会报错</strong>。而在运行时，与普通的 JavaScript 文件一样，不会对类型进行检查。</p><p>如果我们需要保证运行时的参数类型，还是得手动对类型进行判断：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> person === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;person is not a string&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure><blockquote><p><code>let</code> 是 ES6 中的关键字，和 <code>var</code> 类似，用于定义一个局部变量，可以参阅 <a href="http://es6.ruanyifeng.com/#docs/let">let 和 const 命令</a>。</p></blockquote><p>下面尝试把这段代码编译一下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure><p>编辑器中会提示错误，编译的时候也会出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:6:22 - error TS2345: Argument of <span class="built_in">type</span> <span class="string">&#x27;number[]&#x27;</span> is not assignable to parameter of <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>.</span><br></pre></td></tr></table></figure><p>但是还是生成了 js 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure><p>这是因为 <strong>TypeScript 编译的时候即使报错了，还是会生成编译结果</strong>，我们仍然可以使用这个编译之后的文件。</p><p>如果要在报错的时候终止 js 文件的生成，可以在 <code>tsconfig.json</code> 中配置 <code>noEmitOnError</code> 即可。关于 <code>tsconfig.json</code>，请参阅<a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官方手册</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">中文版</a>）。</p><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a><code>基础部分</code></h1><h1 id="一、原始数据类型"><a href="#一、原始数据类型" class="headerlink" title="一、原始数据类型"></a>一、原始数据类型</h1><blockquote><p>JavaScript 的类型分为两种：原始数据类型（<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">Primitive data types</a>）和对象类型（Object types）。</p><p>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <a href="http://es6.ruanyifeng.com/#docs/symbol"><code>Symbol</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a>。</p><p>本节主要介绍<strong>前五种</strong>原始数据类型在 TypeScript 中的应用。</p></blockquote><h2 id="1、布尔值"><a href="#1、布尔值" class="headerlink" title="1、布尔值"></a>1、布尔值</h2><p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <code>boolean</code> 定义布尔值类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="comment">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span></span><br></pre></td></tr></table></figure><p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">createdByNewBoolean</span>: <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.</span></span><br><span class="line"><span class="comment">//   &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible.</span></span><br></pre></td></tr></table></figure><p>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">createdByNewBoolean</span>: <span class="title class_">Boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">createdByBoolean</span>: <span class="built_in">boolean</span> = <span class="title class_">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，<code>boolean</code> 是 JavaScript 中的基本类型，而 <code>Boolean</code> 是 JavaScript 中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样，不再赘述。</p><h2 id="二、数值"><a href="#二、数值" class="headerlink" title="二、数值"></a>二、数值</h2><p>使用 <code>number</code> 定义数值类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">notANumber</span>: <span class="built_in">number</span> = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">infinityNumber</span>: <span class="built_in">number</span> = <span class="title class_">Infinity</span>;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="title class_">Infinity</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>0b1010</code> 和 <code>0o744</code> 是 <a href="http://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p><h2 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h2><p>使用 <code>string</code> 定义字符串类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myName</span>: <span class="built_in">string</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAge</span>: <span class="built_in">number</span> = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.</span></span><br><span class="line"><span class="string">I&#x27;ll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> myAge = <span class="number">25</span>;</span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">var</span> sentence = <span class="string">&quot;Hello, my name is &quot;</span> + myName + <span class="string">&quot;.</span></span><br><span class="line"><span class="string">I&#x27;ll be &quot;</span> + (myAge + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure><p>其中 ``` 用来定义 <a href="http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2">ES6 中的模板字符串</a>，<code>$&#123;expr&#125;</code> 用来在模板字符串中嵌入表达式。</p><h2 id="四、空值"><a href="#四、空值" class="headerlink" title="四、空值"></a>四、空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alertName</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;My name is Tom&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h2 id="五、Null-和-Undefined"><a href="#五、Null-和-Undefined" class="headerlink" title="五、Null 和 Undefined"></a>五、Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 这样也不会报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = u;</span><br></pre></td></tr></table></figure><p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><h1 id="二、任意值"><a href="#二、任意值" class="headerlink" title="二、任意值"></a>二、任意值</h1><blockquote><p>任意值（Any）用来表示允许赋值为任意类型。</p></blockquote><h2 id="1、什么是任意值类型"><a href="#1、什么是任意值类型" class="headerlink" title="1、什么是任意值类型"></a>1、什么是任意值类型</h2><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><blockquote><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">any</span> = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h2 id="2、任意值的属性和方法"><a href="#2、任意值的属性和方法" class="headerlink" title="2、任意值的属性和方法"></a>2、任意值的属性和方法</h2><blockquote><p>在任意值上访问任何属性都是允许的：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">anyThing</span>: <span class="built_in">any</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anyThing.<span class="property">myName</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anyThing.<span class="property">myName</span>.<span class="property">firstName</span>);</span><br></pre></td></tr></table></figure><blockquote><p>也允许调用任何方法：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">anyThing</span>: <span class="built_in">any</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">anyThing.<span class="title function_">setName</span>(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line">anyThing.<span class="title function_">setName</span>(<span class="string">&#x27;Jerry&#x27;</span>).<span class="title function_">sayHello</span>();</span><br><span class="line">anyThing.<span class="property">myName</span>.<span class="title function_">setFirstName</span>(<span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p></blockquote><h2 id="3、未声明类型的变量"><a href="#3、未声明类型的变量" class="headerlink" title="3、未声明类型的变量"></a>3、未声明类型的变量</h2><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.<span class="title function_">setName</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">something</span>: <span class="built_in">any</span>;</span><br><span class="line">something = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.<span class="title function_">setName</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="三、类型推论"><a href="#三、类型推论" class="headerlink" title="三、类型推论"></a>三、类型推论</h1><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p><h2 id="1、什么是类型推论"><a href="#1、什么是类型推论" class="headerlink" title="1、什么是类型推论"></a>1、什么是类型推论</h2><blockquote><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><blockquote><p>事实上，它等价于：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><blockquote><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h1 id="四、联合类型"><a href="#四、联合类型" class="headerlink" title="四、联合类型"></a>四、联合类型</h1><blockquote><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p></blockquote><h2 id="1、简单的例子"><a href="#1、简单的例子" class="headerlink" title="1、简单的例子"></a>1、简单的例子</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>联合类型使用 <code>|</code> 分隔每个类型。</p><p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p><h2 id="2、访问联合类型的属性或方法"><a href="#2、访问联合类型的属性或方法" class="headerlink" title="2、访问联合类型的属性或方法"></a>2、访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myFavoriteNumber.<span class="property">length</span>); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myFavoriteNumber.<span class="property">length</span>); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p><p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p><h1 id="五、对象的类型——接口"><a href="#五、对象的类型——接口" class="headerlink" title="五、对象的类型——接口"></a>五、对象的类型——接口</h1><blockquote><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p></blockquote><h2 id="1、什么是接口"><a href="#1、什么是接口" class="headerlink" title="1、什么是接口"></a>1、什么是接口</h2><blockquote><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述</p></blockquote><h2 id="2、简单的例子"><a href="#2、简单的例子" class="headerlink" title="2、简单的例子"></a>2、简单的例子</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p><blockquote><p>接口一般首字母大写。<a href="https://msdn.microsoft.com/en-us/library/8bc1fexb(v=vs.71).aspx">有的编程语言中会建议接口的名称加上 <code>I</code> 前缀</a>。</p></blockquote><p>定义的变量比接口少了一些属性是不允许的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span></span><br></pre></td></tr></table></figure><p>多一些属性也是不允许的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span></span><br><span class="line"><span class="comment">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span></span><br></pre></td></tr></table></figure><p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p><h2 id="3、可选属性"><a href="#3、可选属性" class="headerlink" title="3、可选属性"></a>3、可选属性</h2><blockquote><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>可选属性的含义是该属性可以不存在。</p></blockquote><p>这时<strong>仍然不允许添加未定义的属性</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examples/playground/index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span></span><br><span class="line"><span class="comment">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span></span><br></pre></td></tr></table></figure><h2 id="4、任意属性"><a href="#4、任意属性" class="headerlink" title="4、任意属性"></a>4、任意属性</h2><blockquote><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 前面key值取的string任意属性     后面值取的any任意值,并不是任意属性</span></span><br><span class="line">    <span class="comment">//或者取这个类型string | number值  确定属性和可选属性必须为任意属性的子集</span></span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p></blockquote><p>需要注意的是，<code>**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集**</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">//任意属性为string     值为string</span></span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span></span><br><span class="line"><span class="comment">//   Index signatures are incompatible.</span></span><br><span class="line"><span class="comment">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p><p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p></blockquote><p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5、只读属性"><a href="#5、只读属性" class="headerlink" title="5、只读属性"></a>5、只读属性</h2><blockquote><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">89757</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.<span class="property">id</span> = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p></blockquote><p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.<span class="property">id</span> = <span class="number">89757</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.</span></span><br><span class="line"><span class="comment">// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure><blockquote><p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p><p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p></blockquote><h1 id="六、数组的类型"><a href="#六、数组的类型" class="headerlink" title="六、数组的类型"></a>六、数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p><h2 id="1、「类型-方括号」表示法"><a href="#1、「类型-方括号」表示法" class="headerlink" title="1、「类型 + 方括号」表示法"></a>1、「类型 + 方括号」表示法</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>数组的项中<strong>不允许</strong>出现其他的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">fibonacci.<span class="title function_">push</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line"><span class="comment">// Argument of type &#x27;&quot;8&quot;&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p><h2 id="2、数组泛型"><a href="#2、数组泛型" class="headerlink" title="2、数组泛型"></a>2、数组泛型</h2><p>我们也可以使用数组泛型（Array Generic） <code>Array&lt;elemType&gt;</code> 来表示数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>关于泛型，可以参考<a href="">泛型</a>一章。</p><h2 id="3、用接口表示数组"><a href="#3、用接口表示数组" class="headerlink" title="3、用接口表示数组"></a>3、用接口表示数组</h2><p>接口也可以用来描述数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberArray</span> &#123;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="title class_">NumberArray</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure><blockquote><p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p><p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p><p>不过有一种情况例外，那就是它常用来表示类数组。</p></blockquote><h2 id="4、类数组"><a href="#4、类数组" class="headerlink" title="4、类数组"></a>4、类数组</h2><p>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">args</span>: <span class="built_in">number</span>[] = <span class="variable language_">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span></span><br></pre></td></tr></table></figure><p>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">args</span>: &#123;</span><br><span class="line">        [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">        <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">        <span class="attr">callee</span>: <span class="title class_">Function</span>;</span><br><span class="line">    &#125; = <span class="variable language_">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p><p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">args</span>: <span class="title class_">IArguments</span> = <span class="variable language_">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IArguments</span> &#123;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">callee</span>: <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、any-在数组中的应用"><a href="#5、any-在数组中的应用" class="headerlink" title="5、any 在数组中的应用"></a>5、any 在数组中的应用</h2><p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="string">&#x27;xcatliu&#x27;</span>, <span class="number">25</span>, &#123; <span class="attr">website</span>: <span class="string">&#x27;http://xcatliu.com&#x27;</span> &#125;];</span><br></pre></td></tr></table></figure><h1 id="七、函数的类型"><a href="#七、函数的类型" class="headerlink" title="七、函数的类型"></a>七、函数的类型</h1><blockquote><p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html">函数是 JavaScript 中的一等公民</a></p></blockquote><h2 id="1、函数声明"><a href="#1、函数声明" class="headerlink" title="1、函数声明"></a>1、函数声明</h2><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明（Function Declaration）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式（Function Expression）</span></span><br><span class="line"><span class="keyword">let</span> mySum = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span></span><br></pre></td></tr></table></figure><h2 id="2、函数表达式"><a href="#2、函数表达式" class="headerlink" title="2、函数表达式"></a>2、函数表达式</h2><p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mySum</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p><p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">ES6 中的箭头函数</a>。</p><h2 id="3、用接口定义函数的形状"><a href="#3、用接口定义函数的形状" class="headerlink" title="3、用接口定义函数的形状"></a>3、用接口定义函数的形状</h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">    (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> source.<span class="title function_">search</span>(subString) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><h2 id="4、可选参数"><a href="#4、可选参数" class="headerlink" title="4、可选参数"></a>4、可选参数</h2><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p><p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = <span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = <span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = <span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = <span class="title function_">buildName</span>(<span class="literal">undefined</span>, <span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure><h2 id="5、参数默认值"><a href="#5、参数默认值" class="headerlink" title="5、参数默认值"></a>5、参数默认值</h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = <span class="string">&#x27;Cat&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = <span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = <span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = <span class="string">&#x27;Tom&#x27;</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = <span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="comment">//此处是赋了初始值,所以可以传入undefined</span></span><br><span class="line"><span class="keyword">let</span> cat = <span class="title function_">buildName</span>(<span class="literal">undefined</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>关于默认参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">ES6 中函数参数的默认值</a>。</p></blockquote><h2 id="6、剩余参数"><a href="#6、剩余参数" class="headerlink" title="6、剩余参数"></a>6、剩余参数</h2><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        array.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: any[] = [];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        array.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"><span class="title function_">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0">ES6 中的 rest 参数</a>。</p><h2 id="7、重载"><a href="#7、重载" class="headerlink" title="7、重载"></a>7、重载</h2><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p><p>利用联合类型，我们可以这么实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p><p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><h1 id="八、类型断言"><a href="#八、类型断言" class="headerlink" title="八、类型断言"></a>八、类型断言</h1><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p><h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 <span class="keyword">as</span> 类型</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br></pre></td></tr></table></figure><p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 <code>值 as 类型</code>。</p><p>形如 <code>&lt;Foo&gt;</code> 的语法在 tsx 中表示的是一个 <code>ReactNode</code>，在 ts 中除了表示类型断言之外，也可能是表示一个<a href="">泛型</a>。</p><p>故建议大家在使用类型断言时，统一使用 <code>值 as 类型</code> 这样的语法。</p><h2 id="2、类型断言的用途"><a href="#2、类型断言的用途" class="headerlink" title="2、类型断言的用途"></a>2、类型断言的用途</h2><p>类型断言的常见用途有以下几种：</p><h3 id="2-1、将一个联合类型断言为其中一个类型"><a href="#2-1、将一个联合类型断言为其中一个类型" class="headerlink" title="2.1、将一个联合类型断言为其中一个类型"></a>2.1、将一个联合类型断言为其中一个类型</h3><p>之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> animal.<span class="property">swim</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:11:23 - error TS2339: Property &#x27;swim&#x27; does not exist on type &#x27;Cat | Fish&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;swim&#x27; does not exist on type &#x27;Cat&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p><p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 值 as 类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (animal <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p><p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swim</span>(<span class="params">animal: Cat | Fish</span>) &#123;</span><br><span class="line">    (animal <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="title function_">swim</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">swim</span>(tom);</span><br><span class="line"><span class="comment">// Uncaught TypeError: animal.swim is not a function`</span></span><br></pre></td></tr></table></figure><p>上面的例子编译时不会报错，但在运行时会报错：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: animal.swim is <span class="literal">not</span> a function`</span><br></pre></td></tr></table></figure><p>原因是 <code>(animal as Fish).swim()</code> 这段代码隐藏了 <code>animal</code> 可能为 <code>Cat</code> 的情况，将 <code>animal</code> 直接断言为 <code>Fish</code> 了，而 TypeScript 编译器信任了我们的断言，故在调用 <code>swim()</code> 时没有编译错误。</p><p>可是 <code>swim</code> 函数接受的参数是 <code>Cat | Fish</code>，一旦传入的参数是 <code>Cat</code> 类型的变量，由于 <code>Cat</code> 上没有 <code>swim</code> 方法，就会导致运行时错误了。</p><p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p><h3 id="2-2、将一个父类断言为更加具体的子类"><a href="#2-2、将一个父类断言为更加具体的子类" class="headerlink" title="2.2、将一个父类断言为更加具体的子类"></a>2.2、将一个父类断言为更加具体的子类</h3><p>当类之间有继承关系时，类型断言也是很常见的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="attr">statusCode</span>: <span class="built_in">number</span> = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (error <span class="keyword">as</span> <span class="title class_">ApiError</span>).<span class="property">code</span> === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们声明了函数 <code>isApiError</code>，它用来判断传入的参数是不是 <code>ApiError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比较抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p><p>但是由于父类 <code>Error</code> 中没有 <code>code</code> 属性，故直接获取 <code>error.code</code> 会报错，需要使用类型断言获取 <code>(error as ApiError).code</code>。</p><p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>ApiError</code>，那就是使用 <code>instanceof</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="attr">statusCode</span>: <span class="built_in">number</span> = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">ApiError</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>ApiError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p><p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HttpError</span> <span class="keyword">extends</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="attr">statusCode</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">ApiError</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:9:26 - error TS2693: &#x27;ApiError&#x27; only refers to a type, but is being used as a value here.</span></span><br></pre></td></tr></table></figure><p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code> 了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HttpError</span> <span class="keyword">extends</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="attr">statusCode</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isApiError</span>(<span class="params">error: <span class="built_in">Error</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (error <span class="keyword">as</span> <span class="title class_">ApiError</span>).<span class="property">code</span> === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、将任何一个类型断言为-any"><a href="#2-3、将任何一个类型断言为-any" class="headerlink" title="2.3、将任何一个类型断言为 any"></a>2.3、将任何一个类型断言为 <code>any</code></h3><p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p><p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">foo.<span class="property">length</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:2:5 - error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p><p>这种错误提示显然是非常有用的。</p><p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">foo</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:1:8 - error TS2339: Property &#x27;foo&#x27; does not exist on type &#x27;Window &amp; typeof globalThis&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p><p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">foo</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p><p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p><p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p><p>上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 <code>foo</code> 属性，<code>as any</code> 会更加方便。</p><p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals">TypeScript 的设计理念</a>之一），才能发挥出 TypeScript 最大的价值。</p><h3 id="2-4、将-any-断言为一个具体的类型"><a href="#2-4、将-any-断言为一个具体的类型" class="headerlink" title="2.4、将 any 断言为一个具体的类型"></a>2.4、将 <code>any</code> 断言为一个具体的类型</h3><p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p><p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p><p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p><p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>上面的例子中，我们调用完 <code>getCacheData</code> 之后，立即将它断言为 <code>Cat</code> 类型。这样的话明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的访问时就有了代码补全，提高了代码的可维护性。</p><h2 id="3、类型断言的限制"><a href="#3、类型断言的限制" class="headerlink" title="3、类型断言的限制"></a>3、类型断言的限制</h2><blockquote><p>本小结的前置知识点：[结构类型系统（TODO）][]、[类型兼容性（TODO）][]</p></blockquote><p>从上面的例子中，我们可以总结出：</p><ul><li>联合类型可以被断言为其中一个类型</li><li>父类可以被断言为子类</li><li>任何类型都可以被断言为 any</li><li>any 可以被断言为任何类型</li></ul><p>那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？</p><p>答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。</p><p>具体来说，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p><p>下面我们通过一个简化的例子，来理解类型断言的限制：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = tom;</span><br></pre></td></tr></table></figure><p>我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p><p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。TypeScript 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 <code>Cat extends Animal</code> 是等价的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。</p><p>我们把它换成 TypeScript 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p><p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以互相进行类型断言了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testAnimal</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (animal <span class="keyword">as</span> <span class="title class_">Cat</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testCat</span>(<span class="params">cat: Cat</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (cat <span class="keyword">as</span> <span class="title class_">Animal</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的设计其实也很容易就能理解：</p><ul><li>允许 <code>animal as Cat</code> 是因为「父类可以被断言为子类」，这个前面已经学习过了</li><li>允许 <code>cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li></ul><p>需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。</p><p>总之，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p><p>同理，若 <code>B</code> 兼容 <code>A</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p><p>所以这也可以换一种说法：</p><p>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。</p><p>综上所述：</p><ul><li>联合类型可以被断言为其中一个类型</li><li>父类可以被断言为子类</li><li>任何类型都可以被断言为 any</li><li>any 可以被断言为任何类型</li><li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可</li></ul><p>其实前四种情况都是最后一个的特例。</p><h2 id="4、双重断言"><a href="#4、双重断言" class="headerlink" title="4、双重断言"></a>4、双重断言</h2><p>既然：</p><ul><li>任何类型都可以被断言为 any</li><li>any 可以被断言为任何类型</li></ul><p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="title function_">swim</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testCat</span>(<span class="params">cat: Cat</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (cat <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> <span class="title class_">Fish</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 互相都不兼容。</p><p>但是若使用双重断言，则可以打破「要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可」的限制，将任何一个类型断言为任何另一个类型。</p><p>若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。</p><p><code>**除非迫不得已，千万别用双重断言。</code>**</p><h2 id="5、类型断言-vs-类型转换"><a href="#5、类型断言-vs-类型转换" class="headerlink" title="5、类型断言 vs 类型转换"></a>5、类型断言 vs 类型转换</h2><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toBoolean</span>(<span class="params">something: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> something <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toBoolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toBoolean</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toBoolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 1</span></span><br></pre></td></tr></table></figure><p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p><p>若要进行类型转换，需要直接调用类型转换的方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toBoolean</span>(<span class="params">something: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Boolean</span>(something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">toBoolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回值为 true</span></span><br></pre></td></tr></table></figure><h2 id="6、类型断言-vs-类型声明"><a href="#6、类型断言-vs-类型声明" class="headerlink" title="6、类型断言 vs 类型声明"></a>6、类型断言 vs 类型声明</h2><p>在这个例子中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>我们使用 <code>as Cat</code> 将 <code>any</code> 类型断言为了 <code>Cat</code> 类型。</p><p>但实际上还有其他方式可以解决这个问题：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 声明为 <code>Cat</code>，然后再将 <code>any</code> 类型的 <code>getCacheData(&#39;tom&#39;)</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p><p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——<code>tom</code> 在接下来的代码中都变成了 <code>Cat</code> 类型。</p><p>它们的区别，可以通过这个例子来理解：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> tom = animal <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>animal</code> 断言为 <code>Cat</code> 赋值给 <code>tom</code>。</p><p>但是若直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts:12:5 - error TS2741: Property &#x27;run&#x27; is missing in type &#x27;Animal&#x27; but required in type &#x27;Cat&#x27;.</span></span><br></pre></td></tr></table></figure><p>则会报错，不允许将 <code>animal</code> 赋值为 <code>Cat</code> 类型的 <code>tom</code>。</p><p>这很容易理解，<code>Animal</code> 可以看作是 <code>Cat</code> 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p><p>深入的讲，它们的核心区别就在于：</p><ul><li><code>animal</code> 断言为 <code>Cat</code>，只需要满足 <code>Animal</code> 兼容 <code>Cat</code> 或 <code>Cat</code> 兼容 <code>Animal</code> 即可</li><li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行</li></ul><p>但是 <code>Cat</code> 并不兼容 <code>Animal</code>。</p><p>而在前一个例子中，由于 <code>getCacheData(&#39;tom&#39;)</code> 是 <code>any</code> 类型，<code>any</code> 兼容 <code>Cat</code>，<code>Cat</code> 也兼容 <code>any</code>，故</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Cat</span> = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。</p><p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加优雅。</p><h2 id="7、类型断言-vs-泛型"><a href="#7、类型断言-vs-泛型" class="headerlink" title="7、类型断言 vs 泛型"></a>7、类型断言 vs 泛型</h2><blockquote><p>本小结的前置知识点：<a href="">泛型</a></p></blockquote><p>还是这个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCacheData</span>(<span class="params">key: <span class="built_in">string</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = <span class="title function_">getCacheData</span>(<span class="string">&#x27;tom&#x27;</span>) <span class="keyword">as</span> <span class="title class_">Cat</span>;</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>我们还有第三种方式可以解决这个问题，那就是泛型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getCacheData&lt;T&gt;(<span class="attr">key</span>: <span class="built_in">string</span>): T &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).<span class="property">cache</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tom = getCacheData&lt;<span class="title class_">Cat</span>&gt;(<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line">tom.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p><h1 id="九、声明文件"><a href="#九、声明文件" class="headerlink" title="九、声明文件"></a>九、声明文件</h1><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><h2 id="1、新语法索引"><a href="#1、新语法索引" class="headerlink" title="1、新语法索引"></a>1、新语法索引</h2><ul><li><a href=""><code>declare var</code></a> 声明全局变量</li><li><a href=""><code>declare function</code></a> 声明全局方法</li><li><a href=""><code>declare class</code></a> 声明全局类</li><li><a href=""><code>declare enum</code></a> 声明全局枚举类型</li><li><a href=""><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li><li><a href=""><code>interface</code> 和 <code>type</code></a> 声明全局类型</li><li><a href=""><code>export</code></a> 导出变量</li><li><a href=""><code>export namespace</code></a> 导出（含有子属性的）对象</li><li><a href="t"><code>export default</code></a> ES6 默认导出</li><li><a href=""><code>export =</code></a> commonjs 导出模块</li><li><a href=""><code>export as namespace</code></a> UMD 库声明全局变量</li><li><a href=""><code>declare global</code></a> 扩展全局变量</li><li><a href=""><code>declare module</code></a> 扩展模块</li><li><a href=""><code>/// </code></a> 三斜线指令</li></ul><h2 id="2、什么是声明语句"><a href="#2、什么是声明语句" class="headerlink" title="2、什么是声明语句"></a>2、什么是声明语句</h2><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p><p>我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>但是在 ts 中，编译器并不知道 <code>$</code> 或 <code>jQuery</code> 是什么东西<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery">1</a>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"><span class="comment">// ERROR: Cannot find name &#x27;jQuery&#x27;.</span></span><br></pre></td></tr></table></figure><p>这时，我们需要使用 <code>declare var</code> 来定义它的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var">2</a>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上例中，<code>declare var</code> 并没有真的定义一个变量，只是定义了全局变量 <code>jQuery</code> 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>除了 <code>declare var</code> 之外，还有其他很多种声明语句，将会在后面详细介绍。</p><h2 id="3、什么是声明文件"><a href="#3、什么是声明文件" class="headerlink" title="3、什么是声明文件"></a>3、什么是声明文件</h2><p>通常我们会把声明语句放到一个单独的文件（<code>jQuery.d.ts</code>）中，这就是声明文件<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts">3</a>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>声明文件必需以 <code>.d.ts</code> 为后缀。</p><p>一般来说，ts 会解析项目中所有的 <code>*.ts</code> 文件，当然也包含以 <code>.d.ts</code> 结尾的文件。所以当我们将 <code>jQuery.d.ts</code> 放到项目中时，其他所有 <code>*.ts</code> 文件就都可以获得 <code>jQuery</code> 的类型定义了。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  ├── index.ts</span><br><span class="line">|  └── jQuery.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p><p>这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。</p><h3 id="3-1、第三方声明文件"><a href="#3-1、第三方声明文件" class="headerlink" title="3.1、第三方声明文件"></a>3.1、第三方声明文件</h3><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts">jQuery in DefinitelyTyped</a>。</p><p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p><p><code>@types</code> 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure><p>可以在<a href="https://microsoft.github.io/TypeSearch/">这个页面</a>搜索你需要的声明文件。</p><h2 id="4、书写声明文件"><a href="#4、书写声明文件" class="headerlink" title="4、书写声明文件"></a>4、书写声明文件</h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p><p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p><p>库的使用场景主要有以下几种：</p><ul><li><a href="">全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量</li><li><a href="">npm 包</a>：通过 <code>import foo from &#39;foo&#39;</code> 导入，符合 ES6 模块规范</li><li><a href="">UMD 库</a>：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入</li><li><a href="">直接扩展全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</li><li><a href="">在 npm 包或 UMD 库中扩展全局变量</a>：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li><li><a href="">模块插件</a>：通过 <code>&lt;script&gt;</code> 或 <code>import</code> 导入后，改变另一个模块的结构</li></ul><h2 id="5、全局变量"><a href="#5、全局变量" class="headerlink" title="5、全局变量"></a>5、全局变量</h2><p>全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 <code>$</code> 和 <code>jQuery</code>。</p><p>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 <code>src</code> 目录下（或者对应的源码目录下）：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  ├── index.ts</span><br><span class="line">|  └── jQuery.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p><h4 id="5-1、declare-var"><a href="#5-1、declare-var" class="headerlink" title="5.1、declare var"></a>5.1、<code>declare var</code></h4><p>在所有的声明语句中，<code>declare var</code> 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 <code>declare let</code> 和 <code>declare const</code>，使用 <code>let</code> 与使用 <code>var</code> 没有什么区别：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量</span></span><br><span class="line">jQuery = <span class="keyword">function</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们使用 <code>const</code> 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量</span></span><br><span class="line">jQuery = <span class="keyword">function</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ERROR: Cannot assign to &#x27;jQuery&#x27; because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure><p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 <code>const</code> 而不是 <code>var</code> 或 <code>let</code>。</p><p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> jQuery = <span class="keyword">function</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ERROR: An implementation cannot be declared in ambient contexts.</span></span><br></pre></td></tr></table></figure><h4 id="5-2、declare-function"><a href="#5-2、declare-function" class="headerlink" title="5.2、declare function"></a>5.2、<code>declare function</code></h4><p><code>declare function</code> 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 <code>function</code> 来定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在函数类型的声明语句中，函数重载也是支持的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">jQuery</span>(<span class="params">domReadyCallback: () =&gt; <span class="built_in">any</span></span>): <span class="built_in">any</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"><span class="title function_">jQuery</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Dom Ready!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-3、declare-class"><a href="#5-3、declare-class" class="headerlink" title="5.3、declare class"></a>5.3、<code>declare class</code></h4><p>当全局变量是一个类的时候，我们用 <code>declare class</code> 来定义它的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Animal.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>同样的，<code>declare class</code> 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 <code>sayHi</code> 方法的具体实现则会报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Animal.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ERROR: An implementation cannot be declared in ambient contexts.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4、declare-enum"><a href="#5-4、declare-enum" class="headerlink" title="5.4、declare enum"></a>5.4、<code>declare enum</code></h4><p>使用 <code>declare enum</code> 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Directions.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br></pre></td></tr></table></figure><p>与其他全局变量的类型声明一致，<code>declare enum</code> 仅用来定义类型，而不是具体的值。</p><p><code>Directions.d.ts</code> 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br></pre></td></tr></table></figure><p>其中 <code>Directions</code> 是由第三方库定义好的全局变量。</p><h4 id="5-5、declare-namespace"><a href="#5-5、declare-namespace" class="headerlink" title="5.5、declare namespace"></a>5.5、<code>declare namespace</code></h4><p><code>namespace</code> 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。</p><p>由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 <code>module</code> 关键字表示内部模块。但由于后来 ES6 也使用了 <code>module</code> 关键字，ts 为了兼容 ES6，使用 <code>namespace</code> 替代了自己的 <code>module</code>，更名为命名空间。</p><p>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 <code>namespace</code>，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 <code>namespace</code> 的使用了。</p><p><code>namespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p><p>比如 <code>jQuery</code> 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.<span class="title function_">ajax</span>(<span class="string">&#x27;/api/get_something&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意，在 <code>declare namespace</code> 内部，我们直接使用 <code>function ajax</code> 来声明函数，而不是使用 <code>declare function ajax</code>。类似的，也可以使用 <code>const</code>, <code>class</code>, <code>enum</code> 等语句<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace">9</a>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">version</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">        <span class="title function_">blur</span>(<span class="attr">eventType</span>: <span class="title class_">EventType</span>): <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">EventType</span> &#123;</span><br><span class="line">        <span class="title class_">CustomClick</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.<span class="title function_">ajax</span>(<span class="string">&#x27;/api/get_something&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jQuery.<span class="property">version</span>);</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> jQuery.<span class="title class_">Event</span>();</span><br><span class="line">e.<span class="title function_">blur</span>(jQuery.<span class="property">EventType</span>.<span class="property">CustomClick</span>);</span><br></pre></td></tr></table></figure><h5 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h5><p>如果对象拥有深层的层级，则需要用嵌套的 <code>namespace</code> 来声明深层的属性的类型<a href="https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting">10</a>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">namespace</span> fn &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params"><span class="built_in">object</span>: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.<span class="title function_">ajax</span>(<span class="string">&#x27;/api/get_something&#x27;</span>);</span><br><span class="line">jQuery.<span class="property">fn</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">check</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假如 <code>jQuery</code> 下仅有 <code>fn</code> 这一个属性（没有 <code>ajax</code> 等其他属性或方法），则可以不需要嵌套 <code>namespace</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery.fn &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params"><span class="built_in">object</span>: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.<span class="property">fn</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">check</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-6、interface-和-type"><a href="#5-6、interface-和-type" class="headerlink" title="5.6、interface 和 type"></a>5.6、<code>interface</code> 和 <code>type</code></h4><p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 <code>interface</code> 或 <code>type</code> 来声明一个全局的接口或类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AjaxSettings</span> &#123;</span><br><span class="line">    method?: <span class="string">&#x27;GET&#x27;</span> | <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">    data?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: AjaxSettings</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，在其他文件中也可以使用这个接口或类型了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">settings</span>: <span class="title class_">AjaxSettings</span> = &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.<span class="title function_">ajax</span>(<span class="string">&#x27;/api/post_something&#x27;</span>, settings);</span><br></pre></td></tr></table></figure><p><code>type</code> 与 <code>interface</code> 类似，不再赘述。</p><h5 id="防止命名冲突"><a href="#防止命名冲突" class="headerlink" title="防止命名冲突"></a>防止命名冲突</h5><p>暴露在最外层的 <code>interface</code> 或 <code>type</code> 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 <code>namespace</code> 下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">AjaxSettings</span> &#123;</span><br><span class="line">        method?: <span class="string">&#x27;GET&#x27;</span> | <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">        data?: <span class="built_in">any</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: AjaxSettings</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在使用这个 <code>interface</code> 的时候，也应该加上 <code>jQuery</code> 前缀：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">settings</span>: jQuery.<span class="property">AjaxSettings</span> = &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.<span class="title function_">ajax</span>(<span class="string">&#x27;/api/post_something&#x27;</span>, settings);</span><br></pre></td></tr></table></figure><h5 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h5><p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery(&#39;#foo&#39;)</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/jQuery.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">jQuery</span>(<span class="params">selector: <span class="built_in">string</span></span>): <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> jQuery &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url: <span class="built_in">string</span>, settings?: <span class="built_in">any</span></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line">jQuery.<span class="title function_">ajax</span>(<span class="string">&#x27;/api/get_something&#x27;</span>);</span><br></pre></td></tr></table></figure><p>关于声明合并的更多用法，可以查看[声明合并]章节。</p><h2 id="6、npm-包-导入与导出"><a href="#6、npm-包-导入与导出" class="headerlink" title="6、npm 包 导入与导出"></a>6、npm 包 导入与导出</h2><p>一般我们通过 <code>import foo from &#39;foo&#39;</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p><p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p><ol><li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li><li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li></ol><p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p><ol><li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li><li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li></ol><p>目录结构：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── src</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── types</span><br><span class="line">|  └── foo</span><br><span class="line">|     └── index.d.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p><code>tsconfig.json</code> 内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;types/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p><p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p><p>不管采用了以上两种方式中的哪一种，我都<strong>强烈建议</strong>大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 <code>@types</code> 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p><h4 id="6-1、export"><a href="#6-1、export" class="headerlink" title="6.1、export"></a>6.1、<code>export</code></h4><p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code> 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p><p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的导入和使用模块应该是这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; name, getName, <span class="title class_">Animal</span>, <span class="title class_">Directions</span>, <span class="title class_">Options</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="keyword">let</span> myName = <span class="title function_">getName</span>();</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">options</span>: <span class="title class_">Options</span> = &#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="混用-declare-和-export"><a href="#混用-declare-和-export" class="headerlink" title="混用 declare 和 export"></a>混用 <code>declare</code> 和 <code>export</code></h5><p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出。上例的声明文件可以等价的改写为</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">sayHi</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, getName, <span class="title class_">Animal</span>, <span class="title class_">Directions</span>, <span class="title class_">Options</span> &#125;;</span><br></pre></td></tr></table></figure><p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p><h4 id="6-2、export-namespace"><a href="#6-2、export-namespace" class="headerlink" title="6.2、export namespace"></a>6.2、<code>export namespace</code></h4><p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">namespace</span> bar &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>);</span><br><span class="line">foo.<span class="property">bar</span>.<span class="title function_">baz</span>();</span><br></pre></td></tr></table></figure><h4 id="6-3、export-default"><a href="#6-3、export-default" class="headerlink" title="6.3、export default"></a>6.3、<code>export default</code></h4><p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from &#39;foo&#39;</code> 而不是 <code>import &#123; foo &#125; from &#39;foo&#39;</code> 来导入这个默认值。</p><p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line"><span class="comment">// ERROR: Expression expected.</span></span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Directions</span>;</span><br></pre></td></tr></table></figure><p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Directions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4、export"><a href="#6-4、export" class="headerlink" title="6.4、export ="></a>6.4、<code>export =</code></h4><p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = foo;</span><br><span class="line"><span class="comment">// 单个导出</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bar</span> = bar;</span><br></pre></td></tr></table></figure><p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">bar</span>;</span><br></pre></td></tr></table></figure><p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br></pre></td></tr></table></figure><p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> bar = foo.<span class="property">bar</span>;</span><br></pre></td></tr></table></figure><p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> = foo;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export &#123; bar &#125;</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code> 来将 <code>bar</code> 合并到 <code>foo</code> 里。</p><p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看<a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require">官方文档</a>。</p><p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p><h2 id="7、UMD-库-export-as-namespace"><a href="#7、UMD-库-export-as-namespace" class="headerlink" title="7、UMD 库 export as namespace"></a>7、UMD 库 <code>export as namespace</code></h2><p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p><h3 id="7-1、export-as-namespace"><a href="#7-1、export-as-namespace" class="headerlink" title="7.1、export as namespace"></a>7.1、<code>export as namespace</code></h3><p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line">export = foo;</span><br><span class="line">declare function foo(): string;</span><br><span class="line">declare <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然它也可以与 <code>export default</code> 一起使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> <span class="keyword">namespace</span> foo;</span><br><span class="line">export default foo;</span><br><span class="line">declare function foo(): string;</span><br><span class="line">declare <span class="keyword">namespace</span> foo &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2、直接扩展全局变量"><a href="#7-2、直接扩展全局变量" class="headerlink" title="7.2、直接扩展全局变量"></a>7.2、直接扩展全局变量</h3><p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">prependHello</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span>.<span class="title function_">prependHello</span>();</span><br></pre></td></tr></table></figure><p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p><p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> <span class="title class_">JQuery</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">CustomOptions</span> &#123;</span><br><span class="line">        <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">JQueryStatic</span> &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="attr">options</span>: <span class="title class_">JQuery</span>.<span class="property">CustomOptions</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line">jQuery.<span class="title function_">foo</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-3、在-npm-包或-UMD-库中扩展全局变量"><a href="#7-3、在-npm-包或-UMD-库中扩展全局变量" class="headerlink" title="7.3、在 npm 包或 UMD 库中扩展全局变量"></a>7.3、在 npm 包或 UMD 库中扩展全局变量</h3><p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p><h4 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a><code>declare global</code></h4><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">        <span class="title function_">prependHello</span>(): <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;bar&#x27;</span>.<span class="title function_">prependHello</span>();</span><br></pre></td></tr></table></figure><p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p><h3 id="7-4、模块插件"><a href="#7-4、模块插件" class="headerlink" title="7.4、模块插件"></a>7.4、模块插件</h3><p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p><h4 id="declare-module"><a href="#declare-module" class="headerlink" title="declare module"></a><code>declare module</code></h4><p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): moment.<span class="property">CalendarKey</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;moment-plugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line">moment.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/foo-bar.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;foo&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;bar&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Foo</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">f</span>: <span class="title class_">Foo</span>;</span><br><span class="line">bar.<span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure><h3 id="7-5、声明文件中的依赖"><a href="#7-5、声明文件中的依赖" class="headerlink" title="7.5、声明文件中的依赖"></a>7.5、声明文件中的依赖</h3><p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/moment-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;moment&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): moment.<span class="property">CalendarKey</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p><h4 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h4><p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p><p>但是在声明文件中，它还是有一定的用武之地。</p><p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p><ul><li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li><li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li></ul><h5 id="书写一个全局变量的声明文件§"><a href="#书写一个全局变量的声明文件§" class="headerlink" title="书写一个全局变量的声明文件§"></a><strong>书写</strong>一个全局变量的声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6">§</a></h5><p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/jquery-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;jquery&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">options: JQuery.AjaxSettings</span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure><p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p><p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p><h5 id="依赖一个全局变量的声明文件§"><a href="#依赖一个全局变量的声明文件§" class="headerlink" title="依赖一个全局变量的声明文件§"></a><strong>依赖</strong>一个全局变量的声明文件<a href="https://ts.xcatliu.com/basics/declaration-files.html#%E4%BE%9D%E8%B5%96%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6">§</a></h5><p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/node-plugin/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;node&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p: NodeJS.Process</span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;node-plugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="variable language_">global</span>.<span class="property">process</span>);</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p><p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p><p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p><h5 id="拆分声明文件"><a href="#拆分声明文件" class="headerlink" title="拆分声明文件"></a>拆分声明文件</h5><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/@types/jquery/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = jQuery;</span><br></pre></td></tr></table></figure><p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是：<code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p><p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p><h5 id="其他三斜线指令"><a href="#其他三斜线指令" class="headerlink" title="其他三斜线指令"></a>其他三斜线指令</h5><p>除了这两种三斜线指令之外，还有其他的三斜线指令，比如 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code>, <code>/// &lt;amd-module /&gt;</code> 等，但它们都是废弃的语法，故这里就不介绍了，详情可见<a href="http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html">官网</a>。</p><h3 id="7-6、自动生成声明文件"><a href="#7-6、自动生成声明文件" class="headerlink" title="7.6、自动生成声明文件"></a>7.6、自动生成声明文件</h3><p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，添加 <code>declaration</code> 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p><p>我们可以在命令行中添加 <code>--declaration</code>（简写 <code>-d</code>），或者在 <code>tsconfig.json</code> 中添加 <code>declaration</code> 选项。这里以 <code>tsconfig.json</code> 为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>上例中我们添加了 <code>outDir</code> 选项，将 ts 文件的编译结果输出到 <code>lib</code> 目录下，然后添加了 <code>declaration</code> 选项，设置为 <code>true</code>，表示将会由 ts 文件自动生成 <code>.d.ts</code> 声明文件，也会输出到 <code>lib</code> 目录下。</p><p>运行 <code>tsc</code> 之后，目录结构如下</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/project</span><br><span class="line">├── lib</span><br><span class="line">|  ├── bar</span><br><span class="line">|  |  ├── index.d.ts</span><br><span class="line">|  |  └── index.js</span><br><span class="line">|  ├── index.d.ts</span><br><span class="line">|  └── index.js</span><br><span class="line">├── src</span><br><span class="line">|  ├── bar</span><br><span class="line">|  |  └── index.ts</span><br><span class="line">|  └── index.ts</span><br><span class="line">├── package.json</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>src</code> 目录下有两个 ts 文件，分别是 <code>src/index.ts</code> 和 <code>src/bar/index.ts</code>，它们被编译到 <code>lib</code> 目录下的同时，也会生成对应的两个声明文件 <code>lib/index.d.ts</code> 和 <code>lib/bar/index.d.ts</code>。它们的内容分别是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/bar/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lib/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// lib/bar/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>): <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><p>可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。</p><p>使用 <code>tsc</code> 自动生成声明文件时，每个 ts 文件都会对应一个 <code>.d.ts</code> 声明文件。这样的好处是，使用方不仅可以在使用 <code>import foo from &#39;foo&#39;</code> 导入默认的模块时获得类型提示，还可以在使用 <code>import bar from &#39;foo/lib/bar&#39;</code> 导入一个子模块时，也获得对应的类型提示。</p><p>除了 <code>declaration</code> 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：</p><ul><li><code>declarationDir</code> 设置生成 <code>.d.ts</code> 文件的目录</li><li><code>declarationMap</code> 对每个 <code>.d.ts</code> 文件，都生成对应的 <code>.d.ts.map</code>（sourcemap）文件</li><li><code>emitDeclarationOnly</code> 仅生成 <code>.d.ts</code> 文件，不生成 <code>.js</code> 文件</li></ul><h3 id="7-7、发布声明文件"><a href="#7-7、发布声明文件" class="headerlink" title="7.7、发布声明文件"></a>7.7、发布声明文件</h3><p>当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。</p><p>此时有两种方案：</p><ol><li>将声明文件和源码放在一起</li><li>将声明文件发布到 <code>@types</code> 下</li></ol><p>这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。</p><p>仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 <code>@types</code> 下。</p><h5 id="将声明文件和源码放在一起"><a href="#将声明文件和源码放在一起" class="headerlink" title="将声明文件和源码放在一起"></a>将声明文件和源码放在一起</h5><p>如果声明文件是通过 <code>tsc</code> 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。</p><p>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：</p><ul><li>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址</li><li>在项目根目录下，编写一个 <code>index.d.ts</code> 文件</li><li>针对入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件），编写一个同名不同后缀的 <code>.d.ts</code> 文件</li></ul><p>第一种方式是给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib/index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo.d.ts&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>指定了 <code>types</code> 为 <code>foo.d.ts</code> 之后，导入此库的时候，就会去找 <code>foo.d.ts</code> 作为此库的类型声明文件了。</p><p><code>typings</code> 与 <code>types</code> 一样，只是另一种写法。</p><p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件，将它视为此库的类型声明文件。</p><p>如果没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件）是否存在对应同名不同后缀的 <code>.d.ts</code> 文件。</p><p>比如 <code>package.json</code> 是这样时：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lib/index.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>就会先识别 <code>package.json</code> 中是否存在 <code>types</code> 或 <code>typings</code> 字段。发现不存在，那么就会寻找是否存在 <code>index.d.ts</code> 文件。如果还是不存在，那么就会寻找是否存在 <code>lib/index.d.ts</code> 文件。假如说连 <code>lib/index.d.ts</code> 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。</p><p>有的库为了支持导入子模块，比如 <code>import bar from &#39;foo/lib/bar&#39;</code>，就需要额外再编写一个类型声明文件 <code>lib/bar.d.ts</code> 或者 <code>lib/bar/index.d.ts</code>，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。</p><h3 id="7-8、将声明文件发布到-types-下"><a href="#7-8、将声明文件发布到-types-下" class="headerlink" title="7.8、将声明文件发布到 @types 下"></a>7.8、将声明文件发布到 <code>@types</code> 下</h3><p>如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 <code>@types</code> 下。</p><p>与普通的 npm 模块不同，<code>@types</code> 是统一由 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped</a> 管理的。要将声明文件发布到 <code>@types</code> 下，就需要给 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。</p><p>pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 <code>@types</code> 下。</p><p>在 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped</a> 中创建一个新的类型声明，需要用到一些工具，<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">DefinitelyTyped</a> 的文档中已经有了<a href="https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package">详细的介绍</a>，这里就不赘述了，以官方文档为准。 `</p><h1 id="十、内置对象"><a href="#十、内置对象" class="headerlink" title="十、内置对象"></a>十、内置对象</h1><p>JavaScript 中有很多<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">内置对象</a>，它们可以直接在 TypeScript 中当做定义好了的类型。</p><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p><h2 id="1、ECMAScript-的内置对象"><a href="#1、ECMAScript-的内置对象" class="headerlink" title="1、ECMAScript 的内置对象"></a>1、ECMAScript 的内置对象</h2><p>ECMAScript 标准提供的内置对象有：</p><p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p><p>我们可以在 TypeScript 中将变量定义为这些类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">Boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: <span class="title class_">Error</span> = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error occurred&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>: <span class="title class_">RegExp</span> = <span class="regexp">/[a-z]/</span>;</span><br></pre></td></tr></table></figure><p>更多的内置对象，可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN 的文档</a>。</p><p>而他们的定义文件，则在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中。</p><h2 id="2、DOM-和-BOM-的内置对象"><a href="#2、DOM-和-BOM-的内置对象" class="headerlink" title="2、DOM 和 BOM 的内置对象"></a>2、DOM 和 BOM 的内置对象</h2><p>DOM 和 BOM 提供的内置对象有：</p><p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p><p>TypeScript 中会经常用到这些类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">body</span>: <span class="title class_">HTMLElement</span> = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">allDiv</span>: <span class="title class_">NodeList</span> = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e: MouseEvent</span>) &#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它们的定义文件同样在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中。</p><h2 id="3、TypeScript-核心库的定义文件"><a href="#3、TypeScript-核心库的定义文件" class="headerlink" title="3、TypeScript 核心库的定义文件"></a>3、TypeScript 核心库的定义文件</h2><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p><p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,14): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of a base expression taken to a specified power.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x The base value of the expression.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y The exponent value of the expression.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pow</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举一个 DOM 中的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">targetCurrent</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,17): error TS2339: Property &#x27;targetCurrent&#x27; does not exist on type &#x27;MouseEvent&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Document</span> <span class="keyword">extends</span> <span class="title class_">Node</span>, <span class="title class_">GlobalEventHandlers</span>, <span class="title class_">NodeSelector</span>, <span class="title class_">DocumentEvent</span> &#123;</span><br><span class="line">    <span class="title function_">addEventListener</span>(<span class="attr">type</span>: <span class="built_in">string</span>, <span class="attr">listener</span>: <span class="function">(<span class="params">ev: MouseEvent</span>) =&gt;</span> <span class="built_in">any</span>, useCapture?: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p><p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p><h2 id="4、用-TypeScript-写-Node-js"><a href="#4、用-TypeScript-写-Node-js" class="headerlink" title="4、用 TypeScript 写 Node.js"></a>4、用 TypeScript 写 Node.js</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><code>进阶</code></h1><h1 id="一、类型别名type"><a href="#一、类型别名type" class="headerlink" title="一、类型别名type"></a>一、类型别名<code>type</code></h1><p>类型别名用来给一个类型起个新名字。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameResolver</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrResolver</span> = <span class="title class_">Name</span> | <span class="title class_">NameResolver</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">n</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><p>类型别名常用于联合类型。</p><h1 id="二、字符串字面量类型type"><a href="#二、字符串字面量类型type" class="headerlink" title="二、字符串字面量类型type"></a>二、字符串字面量类型<code>type</code></h1><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><h2 id="简单的例子-1"><a href="#简单的例子-1" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventNames</span> = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hello&#x27;</span>), <span class="string">&#x27;scroll&#x27;</span>);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;world&#x27;</span>), <span class="string">&#x27;dblclick&#x27;</span>); <span class="comment">// 报错，event 不能为 &#x27;dblclick&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dblclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p><p>注意，<strong>类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</strong></p><h1 id="三、元组"><a href="#三、元组" class="headerlink" title="三、元组"></a>三、元组</h1><blockquote><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p><p>元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。</p></blockquote><h2 id="简单的例子-2"><a href="#简单的例子-2" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>];</span><br></pre></td></tr></table></figure><p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">tom[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">tom[<span class="number">0</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">tom[<span class="number">1</span>].<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>也可以只赋值其中一项：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom[<span class="number">0</span>] = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">&#x27;Tom&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Property &#x27;1&#x27; is missing in type &#x27;[string]&#x27; but required in type &#x27;[string, number]&#x27;.</span></span><br></pre></td></tr></table></figure><h2 id="越界的元素"><a href="#越界的元素" class="headerlink" title="越界的元素"></a>越界的元素</h2><p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">tom = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>];</span><br><span class="line">tom.<span class="title function_">push</span>(<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line">tom.<span class="title function_">push</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Argument of type &#x27;true&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.</span></span><br></pre></td></tr></table></figure><h1 id="四、枚举enum"><a href="#四、枚举enum" class="headerlink" title="四、枚举enum"></a>四、枚举<code>enum</code></h1><blockquote><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p></blockquote><h2 id="简单的例子-3"><a href="#简单的例子-3" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>枚举使用 <code>enum</code> 关键字来定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br></pre></td></tr></table></figure><p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="number">0</span>] === <span class="string">&quot;Sun&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="number">1</span>] === <span class="string">&quot;Mon&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="number">2</span>] === <span class="string">&quot;Tue&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="number">6</span>] === <span class="string">&quot;Sat&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>事实上，上面的例子会被编译为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Days</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Days</span>) &#123;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Sun&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tue&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wed&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Thu&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thu&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Fri&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Fri&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Sat&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Days</span> || (<span class="title class_">Days</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="手动赋值"><a href="#手动赋值" class="headerlink" title="手动赋值"></a>手动赋值</h2><p>我们也可以给枚举项手动赋值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">7</span>, <span class="title class_">Mon</span> = <span class="number">1</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>未手动赋值的枚举项会接着上一个枚举项递增。</code></p><p>如果<code>未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">3</span>, <span class="title class_">Mon</span> = <span class="number">1</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] === <span class="number">3</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="number">3</span>] === <span class="string">&quot;Sun&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="number">3</span>] === <span class="string">&quot;Wed&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 TypeScript 并没有报错，导致 <code>Days[3]</code> 的值先是 <code>&quot;Sun&quot;</code>，而后又被 <code>&quot;Wed&quot;</code> 覆盖了。编译的结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Days</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Days</span>) &#123;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Sun&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Tue&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Wed&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Thu&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Thu&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Fri&quot;</span>] = <span class="number">5</span>] = <span class="string">&quot;Fri&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] = <span class="number">6</span>] = <span class="string">&quot;Sat&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Days</span> || (<span class="title class_">Days</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p><p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">7</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span> = &lt;<span class="built_in">any</span>&gt;<span class="string">&quot;S&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Days</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Days</span>) &#123;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] = <span class="number">7</span>] = <span class="string">&quot;Sun&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] = <span class="number">8</span>] = <span class="string">&quot;Mon&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] = <span class="number">9</span>] = <span class="string">&quot;Tue&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Wed&quot;</span>] = <span class="number">10</span>] = <span class="string">&quot;Wed&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Thu&quot;</span>] = <span class="number">11</span>] = <span class="string">&quot;Thu&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Fri&quot;</span>] = <span class="number">12</span>] = <span class="string">&quot;Fri&quot;</span>;</span><br><span class="line">    <span class="title class_">Days</span>[<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] = <span class="string">&quot;S&quot;</span>] = <span class="string">&quot;Sat&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Days</span> || (<span class="title class_">Days</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span> = <span class="number">7</span>, <span class="title class_">Mon</span> = <span class="number">1.5</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">7</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1.5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2.5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6.5</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="常数项和计算所得项"><a href="#常数项和计算所得项" class="headerlink" title="常数项和计算所得项"></a>常数项和计算所得项</h2><p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</p><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span> = <span class="string">&quot;blue&quot;</span>.<span class="property">length</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p><p>上面的例子不会报错，但是<strong>如果紧接在<code>计算所得项后面的是未手动赋值的项</code>，那么它就会因为无法获得初始值而报错</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="string">&quot;red&quot;</span>.<span class="property">length</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,33): error TS1061: Enum member must have initializer.</span></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1061: Enum member must have initializer.</span></span><br></pre></td></tr></table></figure><p>下面是常数项和计算所得项的完整定义，部分引用自<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html">中文手册 - 枚举</a>：</p><p>当满足以下条件时，枚举成员被当作是常数：</p><ul><li>不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 <code>1</code>。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li><li>枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：<ul><li>数字字面量</li><li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用</li><li>带括号的常数枚举表达式</li><li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错</li></ul></li></ul><p>所有其它情况的枚举成员被当作是需要计算得出的值。</p><h2 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h2><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br></pre></td></tr></table></figure><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p><p>上例的编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure><p>假如包含了计算成员，则会在编译阶段报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span> = <span class="string">&quot;blue&quot;</span>.<span class="property">length</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.</span></span><br></pre></td></tr></table></figure><h2 id="外部枚举§"><a href="#外部枚举§" class="headerlink" title="外部枚举§"></a>外部枚举<a href="https://ts.xcatliu.com/advanced/enum.html#%E5%A4%96%E9%83%A8%E6%9E%9A%E4%B8%BE">§</a></h2><p>外部枚举（Ambient Enums）是使用 <code>declare enum</code> 定义的枚举类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br></pre></td></tr></table></figure><p>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</p><p>上例的编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br></pre></td></tr></table></figure><p>外部枚举与声明语句一样，常出现在声明文件中。</p><p>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Directions</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [<span class="title class_">Directions</span>.<span class="property">Up</span>, <span class="title class_">Directions</span>.<span class="property">Down</span>, <span class="title class_">Directions</span>.<span class="property">Left</span>, <span class="title class_">Directions</span>.<span class="property">Right</span>];</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure><blockquote><p>TypeScript 的枚举类型的概念<a href="https://msdn.microsoft.com/zh-cn/library/sbbt4032.aspx">来源于 C#</a>。</p></blockquote><h1 id="五、类"><a href="#五、类" class="headerlink" title="五、类"></a>五、类</h1><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p><p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p><h2 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h2><p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p><ul><li>类（Class）：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 <code>new</code> 生成</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h2 id="ES6-中类的用法"><a href="#ES6-中类的用法" class="headerlink" title="ES6 中类的用法"></a>ES6 中类的用法</h2><p>下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 <a href="http://es6.ruanyifeng.com/#docs/class">ECMAScript 6 入门 - Class</a>。</p><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p><p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    public name;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sayHi</span>()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name); <span class="comment">// 调用父类的 constructor(name)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Meow, &#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">sayHi</span>(); <span class="comment">// 调用父类的 sayHi()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="title function_">sayHi</span>()); <span class="comment">// Meow, My name is Tom</span></span><br></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Kitty&#x27;</span>); <span class="comment">// setter: Kitty</span></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>; <span class="comment">// setter: Tom</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>使用 <code>static</code> 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isAnimal</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">instanceof</span> <span class="title class_">Animal</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">isAnimal</span>(a); <span class="comment">// true</span></span><br><span class="line">a.<span class="title function_">isAnimal</span>(a); <span class="comment">// TypeError: a.isAnimal is not a function</span></span><br></pre></td></tr></table></figure><h2 id="ES7-中类的用法"><a href="#ES7-中类的用法" class="headerlink" title="ES7 中类的用法"></a>ES7 中类的用法</h2><p>ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>ES6 中实例的属性只能通过构造函数中的 <code>this.xxx</code> 来定义，ES7 提案中可以直接在类里面定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>ES7 提案中，可以使用 <code>static</code> 定义一个静态属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Animal</span>.<span class="property">num</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><h2 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法"></a>TypeScript 中类的用法</h2><h3 id="public-private-和-protected"><a href="#public-private-和-protected" class="headerlink" title="public private 和 protected"></a>public private 和 protected</h3><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><p>下面举一些例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p><p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br><span class="line"><span class="comment">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 <code>private</code> 属性在外部的可访问性。</p><p>上面的例子编译后的代码是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Animal</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Animal</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>);</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,19): TS2675: Cannot extend a class &#x27;Animal&#x27;. Class constructor is marked as private.</span></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2673: Constructor of class &#x27;Animal&#x27; is private and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure><p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2674: Constructor of class &#x27;Animal&#x27; is protected and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// public name: string;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>) &#123;</span><br><span class="line">    <span class="comment">// this.name = name;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure><p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// public readonly name;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name</span>) &#123;</span><br><span class="line">    <span class="comment">// this.name = name;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p><p>什么是抽象类？</p><p>首先，抽象类是不允许被实例化的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">sayHi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p><p>其次，抽象类中的抽象方法必须被子类实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">sayHi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p><p>下面是一个正确使用抽象类的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">sayHi</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p><p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends =</span><br><span class="line">  (<span class="variable language_">this</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">__extends</span>) ||</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">d, b</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.<span class="title function_">hasOwnProperty</span>(p)) d[p] = b[p];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">__</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">constructor</span> = d;</span><br><span class="line">    &#125;</span><br><span class="line">    d.<span class="property"><span class="keyword">prototype</span></span> = b === <span class="literal">null</span> ? <span class="title class_">Object</span>.<span class="title function_">create</span>(b) : ((__.<span class="property"><span class="keyword">prototype</span></span> = b.<span class="property"><span class="keyword">prototype</span></span>), <span class="keyword">new</span> <span class="title function_">__</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Animal</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Animal</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Cat</span> = (<span class="keyword">function</span> (<span class="params">_super</span>) &#123;</span><br><span class="line">  <span class="title function_">__extends</span>(<span class="title class_">Cat</span>, _super);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    _super.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Meow, My name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Cat</span>;</span><br><span class="line">&#125;)(<span class="title class_">Animal</span>);</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h2><p>给类加上 TypeScript 的类型很简单，与接口类似：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sayHi</span>()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure><h1 id="六、类与接口"><a href="#六、类与接口" class="headerlink" title="六、类与接口"></a>六、类与接口</h1><p>接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。</p><p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p><h2 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h2><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Door</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecurityDoor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Door</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SecurityDoor alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现多个接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="title function_">lightOn</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">lightOff</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">lightOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light on&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">lightOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light off&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p><h2 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h2><p>接口与接口之间可以是继承关系：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LightableAlarm</span> <span class="keyword">extends</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="title function_">lightOn</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">lightOff</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这很好理解，<code>LightableAlarm</code> 继承了 <code>Alarm</code>，除了拥有 <code>alert</code> 方法之外，还拥有两个新方法 <code>lightOn</code> 和 <code>lightOff</code>。</p><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3</span>d <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">point3d</span>: <span class="title class_">Point3</span>d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>为什么 TypeScript 会支持接口继承类呢？</p><p>实际上，当我们在声明 <code>class Point</code> 时，除了会创建一个名为 <code>Point</code> 的类之外，同时也创建了一个名为 <code>Point</code> 的类型（实例的类型）。</p><p>所以我们既可以将 <code>Point</code> 当做一个类来用（使用 <code>new Point</code> 创建它的实例）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>也可以将 <code>Point</code> 当做一个类型来用（使用 <code>: Point</code> 表示参数的类型）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">p: Point</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">x</span>, p.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>这个例子实际上可以等价于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointInstanceType</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">p: PointInstanceType</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">x</span>, p.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printPoint</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>上例中我们新声明的 <code>PointInstanceType</code> 类型，与声明 <code>class Point</code> 时创建的 <code>Point</code> 类型是等价的。</p><p>所以回到 <code>Point3d</code> 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointInstanceType</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 interface Point3d extends PointInstanceType</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point3</span>d <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">point3d</span>: <span class="title class_">Point3</span>d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>当我们声明 <code>interface Point3d extends Point</code> 时，<code>Point3d</code> 继承的实际上是类 <code>Point</code> 的实例的类型。</p><p>换句话说，可以理解为定义了一个接口 <code>Point3d</code> 继承另一个接口 <code>PointInstanceType</code>。</p><p>所以「接口继承类」和「接口继承接口」没有什么本质的区别。</p><p>值得注意的是，<code>PointInstanceType</code> 相比于 <code>Point</code>，缺少了 <code>constructor</code> 方法，这是因为声明 <code>Point</code> 类时创建的 <code>Point</code> 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。</p><p>换句话说，声明 <code>Point</code> 类时创建的 <code>Point</code> 类型只包含其中的实例属性和实例方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">/** 静态属性，坐标系原点 */</span></span><br><span class="line">    <span class="keyword">static</span> origin = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/** 静态方法，计算与原点距离 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">distanceToOrigin</span>(<span class="params">p: Point</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(p.<span class="property">x</span> * p.<span class="property">x</span> + p.<span class="property">y</span> * p.<span class="property">y</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 实例属性，x 轴的值 */</span></span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 实例属性，y 轴的值 */</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">/** 构造函数 */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 实例方法，打印此点 */</span></span><br><span class="line">    <span class="title function_">printPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PointInstanceType</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">printPoint</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p1</span>: <span class="title class_">Point</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">p2</span>: <span class="title class_">PointInstanceType</span>;</span><br></pre></td></tr></table></figure><p>上例中最后的类型 <code>Point</code> 和类型 <code>PointInstanceType</code> 是等价的。</p><p>同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。</p><h1 id="七、泛型"><a href="#七、泛型" class="headerlink" title="七、泛型"></a>七、泛型</h1><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><h2 id="简单的例子-4"><a href="#简单的例子-4" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">length: <span class="built_in">number</span>, value: <span class="built_in">any</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createArray</span>(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>上例中，我们使用了<a href="">之前提到过的数组泛型</a>来定义返回值的类型。</p><p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：</p><p><code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code> 的类型。</p><p>这时候，泛型就派上用场了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;<span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p><p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createArray</span>(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h2><p>定义泛型的时候，可以一次定义多个类型参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap&lt;T, U&gt;(<span class="attr">tuple</span>: [T, U]): [U, T] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">swap</span>([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br></pre></td></tr></table></figure><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span></span><br></pre></td></tr></table></figure><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p><p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loggingIdentity</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span></span><br></pre></td></tr></table></figure><p>多个类型参数之间也可以互相约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> copyFields&lt;T <span class="keyword">extends</span> U, U&gt;(<span class="attr">target</span>: T, <span class="attr">source</span>: U): T &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copyFields</span>(x, &#123; <span class="attr">b</span>: <span class="number">10</span>, <span class="attr">d</span>: <span class="number">20</span> &#125;);</span><br></pre></td></tr></table></figure><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>可以使用接口的方式来定义一个函数需要符合的形状：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> source.<span class="title function_">search</span>(subString) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用含有泛型的接口来定义函数的形状：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CreateArrayFunc</span> &#123;</span><br><span class="line">    &lt;T&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">createArray</span>: <span class="title class_">CreateArrayFunc</span>;</span><br><span class="line">createArray = <span class="keyword">function</span>&lt;T&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createArray</span>(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>进一步，我们可以把泛型参数提前到接口名上：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CreateArrayFunc</span>&lt;T&gt; &#123;</span><br><span class="line">    (<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">createArray</span>: <span class="title class_">CreateArrayFunc</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">createArray = <span class="keyword">function</span>&lt;T&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createArray</span>(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: T;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h2 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h2><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: T[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、声明合并"><a href="#八、声明合并" class="headerlink" title="八、声明合并"></a>八、声明合并</h1><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：</p><h2 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h2><p>我们可以使用重载定义多个函数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">//重载需要合并 否则报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span><span class="comment">//这里必须加上一个return 数字或者字符串,否则报错没有返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h2><p>接口中的属性在合并时会简单的合并到一个接口中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>合并的属性的类型必须是唯一的</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;  <span class="comment">// 虽然重复了，但是类型都是 `number`，所以不会报错</span></span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">string</span>;  <span class="comment">// 类型不一致，会报错</span></span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure><p>接口中方法的合并，与函数的合并一样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="attr">s</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="attr">s</span>: <span class="built_in">string</span>, <span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">weight</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="attr">s</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="attr">s</span>: <span class="built_in">string</span>, <span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的合并"><a href="#类的合并" class="headerlink" title="类的合并"></a>类的合并</h2><p>类的合并与接口的合并规则一致。</p><h1 id="九、扩展阅读"><a href="#九、扩展阅读" class="headerlink" title="九、扩展阅读"></a>九、扩展阅读</h1><p>此处记录了<a href="http://www.typescriptlang.org/docs/handbook/basic-types.html">官方手册</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/">中文版</a>）中包含，但是本次整理未涉及的概念,主要用来Mark,后期再去学习。</p><blockquote><ul><li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html#never">Never</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic</a> Types.html#never)）：永远不存在值的类型，一般用于错误处理函数</li><li><a href="http://www.typescriptlang.org/docs/handbook/variable-declarations.html">Variable Declarations</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Variable">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Variable</a> Declarations.html)）：使用 <code>let</code> 和 <code>const</code> 替代 <code>var</code>，这是 <a href="http://es6.ruanyifeng.com/#docs/let">ES6 的知识</a></li><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html#this"><code>this</code></a>：箭头函数的运用，这是 <a href="http://es6.ruanyifeng.com/#docs/function">ES6 的知识</a></li><li><a href="http://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics">Using Class Types in Generics</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Generics.html#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E9%87%8C%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%B1%BB%E5%9E%8B">中文版</a>）：创建工厂函数时，需要引用构造函数的类类型</li><li><a href="http://www.typescriptlang.org/docs/handbook/type-inference.html#best-common-type">Best common type</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type</a> Inference.html#最佳通用类型)）：数组的类型推论</li><li><a href="http://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-type">Contextual Type</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type</a> Inference.html#上下文类型)）：函数输入的类型推论</li><li><a href="http://www.typescriptlang.org/docs/handbook/type-compatibility.html">Type Compatibility</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Type</a> Compatibility.html)）：允许不严格符合类型，只需要在一定规则下兼容即可</li><li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types">Advanced Types</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#交叉类型（intersection-types）)）：使用 <code>&amp;</code> 将多种类型的共有部分叠加成一种类型</li><li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types">Type Guards and Differentiating Types</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）：联合类型在一些情况下被识别为特定的类型</li><li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions">Discriminated Unions</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#可辨识联合（discriminated-unions）)）：使用 <code>|</code> 联合多个接口的时候，通过一个共有的属性形成可辨识联合</li><li><a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types">Polymorphic <code>this</code> types</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#多态的this类型)）：父类的某个方法返回 <code>this</code>，当子类继承父类后，子类的实例调用此方法，返回的 <code>this</code> 能够被 TypeScript 正确的识别为子类的实例。</li><li><a href="http://www.typescriptlang.org/docs/handbook/symbols.html">Symbols</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Symbols.html">中文版</a>）：新原生类型，这是 <a href="http://es6.ruanyifeng.com/#docs/symbol">ES6 的知识</a></li><li><a href="http://www.typescriptlang.org/docs/handbook/iterators-and-generators.html">Iterators and Generators</a>（[中文版](<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Iterators">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Iterators</a> and Generators.html)）：迭代器，这是 <a href="http://es6.ruanyifeng.com/#docs/iterator">ES6 的知识</a></li><li><a href="http://www.typescriptlang.org/docs/handbook/namespaces.html">Namespaces</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Namespaces.html">中文版</a>）：避免全局污染，现在已被 <a href="http://es6.ruanyifeng.com/#docs/module">ES6 Module</a> 替代</li><li><a href="http://www.typescriptlang.org/docs/handbook/decorators.html">Decorators</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Decorators.html">中文版</a>）：修饰器，这是 <a href="http://es6.ruanyifeng.com/#docs/decorator">ES7 的一个提案</a></li><li><a href="http://www.typescriptlang.org/docs/handbook/mixins.html">Mixins</a>（<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Mixins.html">中文版</a>）：一种编程模式，与 TypeScript 没有直接关系，可以参考 <a href="http://es6.ruanyifeng.com/#docs/class#Mixin%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">ES6 中 Mixin 模式的实现</a></li></ul></blockquote><h1 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a><code>补充知识点</code></h1><h2 id="1、箭头函数写法"><a href="#1、箭头函数写法" class="headerlink" title="1、箭头函数写法"></a>1、箭头函数写法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jiantouhanshu : <span class="function">()=&gt;</span><span class="keyword">void</span> =<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;箭头函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、剩余参数、type、类与继承实现-相关"><a href="#2、剩余参数、type、类与继承实现-相关" class="headerlink" title="2、剩余参数、type、类与继承实现 相关"></a>2、剩余参数、type、类与继承实现 相关</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">stringArr</span>:<span class="built_in">string</span>[]=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;222&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">undefinedArr</span>:<span class="literal">undefined</span>[]=[<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br><span class="line"><span class="comment">//开发过程中的代码,当编译成代码后这些代码将不存在</span></span><br><span class="line"><span class="comment">//接口的定义</span></span><br><span class="line"><span class="keyword">interface</span>  <span class="title class_">InterType</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">say</span>():<span class="built_in">void</span>;</span><br><span class="line">    [<span class="attr">propname</span>:<span class="built_in">string</span>]:<span class="built_in">any</span></span><br><span class="line">    select?:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的继承</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TeacherType</span> <span class="keyword">extends</span> <span class="title class_">InterType</span>&#123;</span><br><span class="line">    <span class="title function_">teach</span>():<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的实现</span></span><br><span class="line"><span class="comment">// class implementsInter implements InterType  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">implementsInter</span> <span class="keyword">implements</span> <span class="title class_">TeacherType</span>&#123;</span><br><span class="line">    name=<span class="string">&quot;洪jl&quot;</span></span><br><span class="line">    age=<span class="number">18</span></span><br><span class="line">    select=<span class="number">666</span></span><br><span class="line">    <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="string">&quot;implementsInter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">teach</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;实现接口升级成了老师 implementsInter&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> arrs=(<span class="built_in">number</span>|<span class="built_in">string</span>)</span><br><span class="line"><span class="comment">//剩余参数声明方式   其中声明了say(),所以必须要有say()方法  这个声明方式并不是元组声明方式,与顺序不一样也可以</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lady</span>=&#123;<span class="attr">name</span>:<span class="built_in">string</span>,<span class="attr">age</span>:<span class="built_in">number</span>,<span class="title function_">say</span>():<span class="built_in">void</span>,[<span class="attr">propname</span>:<span class="built_in">string</span>]:<span class="built_in">any</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newPro=<span class="keyword">new</span> <span class="title function_">implementsInter</span>()</span><br><span class="line"></span><br><span class="line">newPro.<span class="title function_">say</span>()                                                       <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPro.<span class="title function_">teach</span>())                                        <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr :(arrs) []=[<span class="number">1</span>,<span class="string">&#x27;string&#x27;</span>,<span class="number">111</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">ceshi</span>:<span class="title class_">Lady</span>[]=[</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&quot;xx&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="title function_">say</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&quot;第二个名字&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">x</span>:<span class="number">20</span>,<span class="title function_">say</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>:<span class="string">&quot;第三个名字&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">s</span>:<span class="string">&quot;zz&quot;</span>,<span class="attr">x</span>:<span class="string">&quot;aa&quot;</span>,<span class="attr">disan</span>:<span class="literal">true</span>,<span class="title function_">say</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">screenResume</span>=(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span>,bust:<span class="built_in">number</span></span>)=&gt;&#123;</span><br><span class="line">    age&lt;<span class="number">24</span>&amp;&amp; bust &gt;=<span class="number">90</span> ?<span class="variable language_">console</span>.<span class="title function_">log</span>(name+<span class="string">&quot;进入面试&quot;</span>):<span class="variable language_">console</span>.<span class="title function_">log</span>(name+<span class="string">&quot;你被淘汰了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ceshi)<span class="comment">//3</span></span><br><span class="line">ceshi[<span class="number">2</span>].<span class="title function_">say</span>()<span class="comment">//4</span></span><br><span class="line"><span class="comment">/**打印结果</span></span><br><span class="line"><span class="comment">1、 洪jl implementsInter</span></span><br><span class="line"><span class="comment">2、 实现接口升级成了老师 implementsInter</span></span><br><span class="line"><span class="comment">3、 [</span></span><br><span class="line"><span class="comment">  &#123; name: &#x27;xx&#x27;, age: 18, say: [Function: say] &#125;,</span></span><br><span class="line"><span class="comment">  &#123; name: &#x27;第二个名字&#x27;, age: 18, x: 20, say: [Function: say] &#125;,</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    name: &#x27;第三个名字&#x27;,</span></span><br><span class="line"><span class="comment">    age: 18,</span></span><br><span class="line"><span class="comment">    s: &#x27;zz&#x27;,</span></span><br><span class="line"><span class="comment">    x: &#x27;aa&#x27;,</span></span><br><span class="line"><span class="comment">    disan: true,</span></span><br><span class="line"><span class="comment">    say: [Function: say]</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">4、 第三个名字</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="3、public与private"><a href="#3、public与private" class="headerlink" title="3、public与private"></a>3、public与private</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的内部和类的外部</span></span><br><span class="line"><span class="comment">//public private </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="attr">name</span>:<span class="built_in">string</span>=<span class="string">&quot;私有的属性名字&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">sayHello</span>():<span class="built_in">void</span>&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="string">&quot;  公有打印私有属性方法&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span>  <span class="title function_">setName</span>(<span class="attr">name</span>:<span class="built_in">string</span>):<span class="built_in">void</span>&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">sayBye</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//只有父类的prblic公有属性才可以子类访问到,所以这里我直接调用父类的打印</span></span><br><span class="line">        <span class="comment">// console.log(super.name,&quot;继承类的公有方法&quot;)</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;  这是子类调用的&quot;</span>)</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sayHello</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Teacher</span>()</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br><span class="line">person.<span class="title function_">sayBye</span>()</span><br><span class="line">person.<span class="title function_">setName</span>(<span class="string">&quot;洪吉林&quot;</span>)</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br><span class="line">person.<span class="title function_">sayBye</span>()</span><br></pre></td></tr></table></figure><h2 id="4、get-set-readonly-与静态方法-抽象类"><a href="#4、get-set-readonly-与静态方法-抽象类" class="headerlink" title="4、get set readonly 与静态方法  抽象类"></a>4、get set readonly 与静态方法  抽象类</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Xiaojiejie</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> _age:<span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">    <span class="comment">/***********  get set  *************/</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">getage</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">setage</span>(<span class="params">age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_age</span>=age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lili=<span class="keyword">new</span> <span class="title class_">Xiaojiejie</span>(<span class="number">18</span>)</span><br><span class="line">lili.<span class="property">setage</span>=<span class="number">18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lili.<span class="property">getage</span>)</span><br><span class="line"><span class="comment">//************static后可以不声明对象直接调用*************/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sayLove</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I love you&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Girl</span>.<span class="title function_">sayLove</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">/******       readonly    ******/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="attr">_name</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"> name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span>=name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//报错 只读属性不能赋值,除了构造函数刚开始一次</span></span><br><span class="line">    <span class="comment">// set setname(name:string)&#123;</span></span><br><span class="line">    <span class="comment">//     this._name=name</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********        抽象类     *******************/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Girls</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">skill</span>():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waiter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Girls</span>&#123;</span><br><span class="line">    <span class="title function_">skill</span>(<span class="params"></span>)&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;继承抽象类&quot;</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、tsconfig相关"><a href="#5、tsconfig相关" class="headerlink" title="5、tsconfig相关"></a>5、tsconfig相关</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// &quot;include&quot;:[&quot;demo1.ts&quot;] //什么文件生效,而且只是编译这里面对应js文件</span></span><br><span class="line">    <span class="comment">// &quot;files&quot;: [&quot;demo.ts&quot;],//与include相似功能</span></span><br><span class="line">  <span class="comment">// &quot;exclude&quot;:[&quot;demo.ts&quot;],//除了什么文件生效</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                     /* 打开后t(true)生成.map文件   &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./build/page.js&quot;</span><span class="punctuation">,</span>      <span class="comment">//生成单个文件 但是这个选项一开 module不支持commonjs 需要改成amd</span></span><br><span class="line">    <span class="comment">// &quot;outDir&quot;: &quot;.build/&quot;,                     /*  输出文件路径 即生成的js文件*/</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./src&quot;,                        /* 入口文件路径,即ts文件夹 */</span></span><br><span class="line">                 </span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                   <span class="comment">/*去掉注释*/</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">/* 是否严格按照ts标准,如果为true,下面的配置将不生效 只有为false,下面的配置才可以生效 **/</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitAny&quot;: false,                 /* 当你设置为false时允许你的注解类型any不用特意标明 */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: false,              /* 设为false允许所有类型赋值null. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                /* 不与上面的strict相关  打开后,只要是出现没有使用的变量,会进行提示错误 */</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6、类型守护-断言"><a href="#6、类型守护-断言" class="headerlink" title="6、类型守护(断言)"></a>6、类型守护(断言)</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Waiter</span> &#123;</span><br><span class="line">    <span class="attr">anjiao</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">says</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="attr">anjiao</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">skill</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类型守护 类型断言 </span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">jushi</span>(<span class="params">animal: Waiter | Teacher</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (animal.<span class="property">anjiao</span>) (animal <span class="keyword">as</span> <span class="title class_">Teacher</span>).<span class="title function_">skill</span>()</span><br><span class="line">     <span class="keyword">else</span> (animal <span class="keyword">as</span> <span class="title class_">Waiter</span>).<span class="title function_">says</span>()</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 类型守护  类的断言  有错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jushi1</span>(<span class="params">animal: (Waiter | Teacher)</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;skill&quot;</span> <span class="keyword">in</span> animal) &#123; animal.<span class="title function_">skill</span>(); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; animal.<span class="title function_">says</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jushi1</span>(&#123; </span><br><span class="line">    <span class="attr">anjiao</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="title function_">skill</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> &#123;&#125; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">first: <span class="built_in">string</span> | <span class="built_in">number</span>, second: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> first === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> second === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;first&#125;</span><span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入类的类型守护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberOgj</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">number</span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addObj</span>(<span class="params">first: <span class="built_in">object</span> | NumberOgj, second: <span class="built_in">object</span> | NumberOgj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first <span class="keyword">instanceof</span> <span class="title class_">NumberOgj</span> &amp;&amp; second <span class="keyword">instanceof</span> <span class="title class_">NumberOgj</span>)</span><br><span class="line">        <span class="keyword">return</span> first.<span class="property">count</span> + second.<span class="property">count</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、枚举类型"><a href="#7、枚举类型" class="headerlink" title="7、枚举类型"></a>7、枚举类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型用于使用0 1 2 此类状态标志</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    hong=<span class="number">1</span>, <span class="comment">//可以改变开始的下标 默认从0开始</span></span><br><span class="line">    ji,</span><br><span class="line">    lin</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">status: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Status</span>.<span class="property">hong</span>:</span><br><span class="line">            <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Status</span>.<span class="property">ji</span>:</span><br><span class="line">            <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Status</span>.<span class="property">lin</span>:</span><br><span class="line">            <span class="keyword">return</span> status</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>(<span class="title class_">Status</span>.<span class="property">hong</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="title class_">Status</span>.<span class="property">ji</span>))</span><br></pre></td></tr></table></figure><h2 id="8、泛型"><a href="#8、泛型" class="headerlink" title="8、泛型"></a>8、泛型</h2><h3 id="1、泛型基础使用"><a href="#1、泛型基础使用" class="headerlink" title="1、泛型基础使用"></a>1、泛型基础使用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型</span></span><br><span class="line"><span class="keyword">function</span> join&lt;T&gt;(<span class="attr">firts</span>: T, <span class="attr">second</span>: T) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firts&#125;</span><span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(join&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;s&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(join&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>, <span class="number">2</span>))<span class="comment">//尖括号定义的类型,后面将会使用这个类型</span></span><br><span class="line"><span class="comment">//泛型在数组中的使用</span></span><br><span class="line"><span class="keyword">function</span> myFun&lt;T&gt;(<span class="attr">params</span>: T[]) &#123;</span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myFun&lt;<span class="built_in">string</span>&gt;([<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456x&quot;</span>]))</span><br><span class="line"><span class="comment">//多个泛型的定义</span></span><br><span class="line"><span class="keyword">function</span> join1&lt;T,P&gt;(<span class="attr">firts</span>: T, <span class="attr">second</span>: P) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firts&#125;</span><span class="subst">$&#123;second&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(join1&lt;<span class="built_in">string</span>,<span class="built_in">number</span>&gt;(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//泛型支持类型推断</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">join1</span>(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="2、泛型使用-泛型继承-泛型约束"><a href="#2、泛型使用-泛型继承-泛型约束" class="headerlink" title="2、泛型使用 泛型继承 泛型约束"></a>2、泛型使用 泛型继承 泛型约束</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通泛型使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectGirl</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> girls: T[]</span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">getGirl</span>(<span class="attr">index</span>: <span class="built_in">number</span>): T &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">girls</span>[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> selectGirl = <span class="keyword">new</span> <span class="title class_">SelectGirl</span>([<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(selectGirl.<span class="title function_">getGirl</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型继承 这边的值需要有name</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Girl</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectEx</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Girl</span>&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> girls: T[]</span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">getGirl</span>(<span class="attr">index</span>: <span class="built_in">number</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">girls</span>[index].<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> selectEx = <span class="keyword">new</span> <span class="title class_">SelectEx</span>([</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;洪&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;吉&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;林&quot;</span> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(selectEx.<span class="title function_">getGirl</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型约束</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectGirl1</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span>|<span class="built_in">string</span>&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> girls: T[]</span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">getGirl</span>(<span class="attr">index</span>: <span class="built_in">number</span>): T &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">girls</span>[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> selectGirl1 = <span class="keyword">new</span> <span class="title class_">SelectGirl1</span>([<span class="string">&quot;约束&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(selectGirl1.<span class="title function_">getGirl</span>(<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9、命名空间namespace"><a href="#9、命名空间namespace" class="headerlink" title="9、命名空间namespace"></a>9、命名空间<code>namespace</code></h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Comments</span> &#123;</span><br><span class="line"><span class="comment">//子命名空间</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Sub</span> &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//暴露出去类</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Header</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> elem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">            elem.<span class="property">innerText</span> = <span class="string">&quot;This is Header&quot;</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Comments</span>.<span class="property">sub</span>.<span class="property">Test</span> <span class="comment">//使用</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/10/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81/"/>
      <url>/2022/10/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="一、正则基础概述"><a href="#一、正则基础概述" class="headerlink" title="一、正则基础概述"></a>一、正则基础概述</h1><blockquote><p>首先给出正则最基础的知识点概述,好让同学们能回想起一些之前学过的知识点,能更好地进行阅读</p><p>这里分享一个在线练习正则的网站,同学们可以在这里进行练习  –&gt; [ <a href="https://regex101.com/">在线练习</a> ]</p><p>笔记中例子中如特殊没有指出,则默认使用 <code>/g</code> 标志(修饰符)全局搜索作为示范</p></blockquote><h2 id="1、什么是正则表达式"><a href="#1、什么是正则表达式" class="headerlink" title="1、什么是正则表达式?"></a>1、什么是正则表达式?</h2><blockquote><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。<strong>通俗的讲就是按照某种规则去匹配符合条件的字符串</strong></p></blockquote><p>一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等</p></blockquote><h2 id="2、基础语法图表"><a href="#2、基础语法图表" class="headerlink" title="2、基础语法图表"></a>2、基础语法图表</h2><h3 id="Ⅰ-基础语法表格"><a href="#Ⅰ-基础语法表格" class="headerlink" title="Ⅰ -  基础语法表格"></a>Ⅰ -  基础语法表格</h3><blockquote><p>首先先给出最最基础部分的匹配规则,这个是肯定要会的</p><table><thead><tr><th>single char (单字符)</th><th>quantifiers(数量)</th><th>position(位置)</th></tr></thead><tbody><tr><td>\d   匹配数字</td><td>* 0个或者更多</td><td>^一行的开头</td></tr><tr><td>\w  匹配word(数字、字母)</td><td>+ 1个或更多，至少1个</td><td>$一行的结尾</td></tr><tr><td>\W 匹配<strong>非</strong>word(数字、字母)</td><td>? 0个或1个,一个Optional</td><td>\b 单词”结界”(word bounds)</td></tr><tr><td>\s  匹配white space(包括空格、tab等)</td><td>{min,max}出现次数在一个范围内</td><td></td></tr><tr><td>\S  匹配<strong>非</strong>white space(包括空格、tab等)</td><td>{n}匹配出现n次的</td><td></td></tr><tr><td>.    匹配任何，任何的字符</td><td></td><td></td></tr></tbody></table></blockquote><h3 id="Ⅱ-常用语法示例图解析"><a href="#Ⅱ-常用语法示例图解析" class="headerlink" title="Ⅱ -  常用语法示例图解析"></a>Ⅱ -  常用语法示例图解析</h3><blockquote><p>此处暂时看不懂没关系,后面会进行详细的语法介绍,此处只是让我们对正则表达式更有概念,感觉不好理解可以跳过,学完再回来看</p><p>此示例图解析部分主要摘录自 <code>comer的60分钟正则从入门到深入</code>,本人觉得其图画的挺好的,且确实刚开始可以稍微看下正则具体应用,方便后续理解,便摘录下来</p></blockquote><h4 id="a-通用正则表达式"><a href="#a-通用正则表达式" class="headerlink" title="a)  通用正则表达式"></a>a)  通用正则表达式</h4><blockquote><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823160637803.png" alt="image-20210823160637803"> </p></blockquote><h4 id="b-手机号正则"><a href="#b-手机号正则" class="headerlink" title="b)  手机号正则"></a>b)  手机号正则</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^1[34578][0-9]&#123;9&#125;$/</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823160443209.png" alt="image-20210823160443209"> </p></blockquote><h4 id="c-日期匹配与分组替换"><a href="#c-日期匹配与分组替换" class="headerlink" title="c) 日期匹配与分组替换"></a>c) 日期匹配与分组替换</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\d&#123;4&#125;[/-]d&#123;1,2&#125;[/-]\d&#123;1,2&#125;$/</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825152404114.png" alt="image-20210825152404114"> </p><p>这个正则比较复杂，画符念咒的地方太多了，一一分析：</p><ul><li>Start of line 是由^生效的表示以此开头</li><li>对应结尾End of line 由$生效表示以此结尾</li><li>接着看digit 由 d 生效表示数字</li><li>3times 由{4} 生效表示重复4次，开始的时候有疑问，为什么不是 4times 。后来明白作者的用意，正则表达式是一个规则，用这个规则去从字符串开始匹配到结束（注意计算机读字符串可是不会分行的，都是一个串，我们看到的多行，人家会认为是个 t ）这里设计好像小火车的轨道一直开到末尾。digit 传过一次，3times表示再来三次循环，共4次，后面的once同理。 自己被自己啰嗦到了。</li><li>接下来，是 one of 在手机正则里面已经出现了。表示什么都行。只要符合这两个都让通过。</li></ul><blockquote><p>好了这个正则解释完了，接下来用它做什么呢？</p></blockquote><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825152632978.png" alt="image-20210825152632978"> </p><p>我们可以验证日期的合法性<br>结合URL分组替换所用到的分组特性，我们可以轻松写出日期格式化的方法</p><blockquote><p>改造下这个正则</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^(\d&#123;4&#125;)[/-](\d&#123;1,2&#125;)[/-](\d&#123;1,2&#125;)$/</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825152705104.png" alt="image-20210825152705104"> </p><p>轻松的可以拿到 group#1 #2 #3 的内容，对应 $1 $2 $3</p><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825152720265.png" alt="image-20210825152720265"> </p></blockquote><h2 id="3、基本匹配"><a href="#3、基本匹配" class="headerlink" title="3、基本匹配"></a>3、基本匹配</h2><blockquote><p>正则表达式其实就是在执行搜索时的格式，它由一些字母(也可以是汉字)和数字组合而成。</p><p>例如：一个正则表达式 <code>学习的汪 H</code>，它表示一个规则：由<code>学</code>开始，接着是<code>习</code>,…最后<code>H</code>。它是组个字符与输入的正则表达式作比较,同时大小写敏感</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习的汪 H&quot;</span> =&gt;</span><br><span class="line">&gt;努力学习的汪 hongjilin <span class="comment">//无符合匹配字符串</span></span><br><span class="line">&gt;努力学习的汪 <span class="title class_">Hongjilin</span>   <span class="comment">//其中的 [ 学习的汪 H ] 高亮</span></span><br></pre></td></tr></table></figure><p>结果示例:  这里分享一个在线练习正则的网站,同学们可以在这里进行练习  –&gt; [ <a href="https://regex101.com/">在线练习</a> ]<img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823163759857.png" alt="image-20210823163759857"></p></blockquote><h1 id="二、元字符"><a href="#二、元字符" class="headerlink" title="二、元字符"></a>二、元字符</h1><blockquote><p>正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。<strong>一些元字符写在方括号中的时候有一些特殊的意思</strong></p></blockquote><h2 id="1、元字符列举"><a href="#1、元字符列举" class="headerlink" title="1、元字符列举"></a>1、元字符列举</h2><blockquote><p>以下是一些元字符的列举：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table></blockquote><h2 id="2、点运算符-–-gt"><a href="#2、点运算符-–-gt" class="headerlink" title="2、点运算符 –&gt;  ."></a>2、点运算符 –&gt;  <code>.</code></h2><blockquote><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式 [<code>...o</code> ] 匹配3个(几个点就几位)任意字符后面跟着是 [ <code>o</code> ] 的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;...o&#x27;</span> =&gt;  <span class="comment">//此处给出三个点 就是前三位为任意</span></span><br><span class="line">&gt;努力学习的汪 hongjilin   <span class="comment">//其中的 [ 汪 ho ] 高亮</span></span><br><span class="line">&gt;努力学习的汪 <span class="title class_">Hongjilin</span>   <span class="comment">//其中的 [ 汪 Ho ] 高亮</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823165209675.png" alt="image-20210823165209675"> </p><p>这时,某个认真看笔记的同学提问: <code>.</code> 用来匹配任意字符  那么字符串中的<code>句号.</code>,我们又怎么匹配呢?别急,带着这个疑问继续往下看,答案就在下方字符集中</p></blockquote><h2 id="3、字符集"><a href="#3、字符集" class="headerlink" title="3、字符集"></a>3、字符集</h2><blockquote><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式 [ <code>学习的汪 [Hh]</code> ] 匹配 [ <code>学习的汪 h</code> ]   和 [ <code>学习的汪 H</code> ] 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习的汪 [Hh]&quot;</span> =&gt;</span><br><span class="line">&gt;努力学习的汪 hongjilin   <span class="comment">//其中的 [ 学习的汪 h ] 高亮</span></span><br><span class="line">&gt;努力学习的汪 <span class="title class_">Hongjilin</span>   <span class="comment">//其中的 [ 学习的汪 H ] 高亮</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823165618928.png" alt="image-20210823165618928"> </p></blockquote><h3 id="Ⅰ-字符集中匹配句号-–-gt-gt"><a href="#Ⅰ-字符集中匹配句号-–-gt-gt" class="headerlink" title="Ⅰ- 字符集中匹配句号.   –&gt;&gt;  [.]"></a>Ⅰ- 字符集中匹配句号.   –&gt;&gt;  <code>[.]</code></h3><blockquote><p>前面我们说过<code>点运算符</code>,那同学们是否会有个疑惑, <code>.</code> 被用来匹配任意字符,那么作为字符串中的<code>句号.</code>,又该用什么匹配呢?</p><p>方括号的句号就表示句号。 表达式 <code>lin[.]</code> 匹配 <code>lin.</code>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;lin[.]&quot;</span> =&gt;</span><br><span class="line">&gt;努力学习的汪 hongjilins </span><br><span class="line">&gt;努力学习的汪 <span class="title class_">Hongjilin</span>.  </span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823170252598.png" alt="image-20210823170252598"> </p></blockquote><h3 id="Ⅱ-否定字符集-–-gt-gt"><a href="#Ⅱ-否定字符集-–-gt-gt" class="headerlink" title="Ⅱ -  否定字符集   –&gt;&gt;  [^]"></a>Ⅱ -  否定字符集   –&gt;&gt;  <code>[^]</code></h3><blockquote><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^地]学习的[^帅]</code> 匹配一个字符串为 [ 学习的 ]的, 同时前面一位字符串不能为<code>地</code>,后面一位字符串不能为<code>帅</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;[^地]学习的[^帅]&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 hongjilins  <span class="comment">//只有此处高亮</span></span><br><span class="line">&gt;努力学习的帅汪 <span class="title class_">Hongjilin</span>. </span><br><span class="line">&gt;帅气地学习的</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823171609152.png" alt="image-20210823171609152">  </p></blockquote><h4 id="a-一个特殊的用法"><a href="#a-一个特殊的用法" class="headerlink" title="a) 一个特殊的用法"></a>a) 一个特殊的用法</h4><blockquote><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p><p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p><ul><li>U+000A 换行符（<code>\n</code>）</li><li>U+000D 回车符（<code>\r</code>）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为<code>.</code>不匹配<code>\n</code>，所以正则表达式返回<code>false</code>。</p><p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo[^]bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当然,这种解决方案毕竟不太符合直觉， <a href="https://github.com/tc39/proposal-regexp-dotall-flag">ES2018</a> 引入<code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>s.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>详见ES系列笔记正则部分  –&gt;   <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%8F%8A%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ES6及后续版本学习笔记</a></strong> </p></blockquote><h3 id="Ⅲ-重复次数-–-gt-gt-、-、"><a href="#Ⅲ-重复次数-–-gt-gt-、-、" class="headerlink" title="Ⅲ - 重复次数  –&gt;&gt; *、+、?"></a>Ⅲ - 重复次数  –&gt;&gt; <code>*、+、?</code></h3><blockquote><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p></blockquote><h4 id="a-号"><a href="#a-号" class="headerlink" title="a)  * 号"></a>a)  <code>*</code> 号</h4><blockquote><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;[a-z]*&quot;</span> =&gt;</span><br><span class="line">&gt;<span class="title class_">Hong</span> ji lin <span class="variable constant_">VERY</span> shuai <span class="comment">//部分高亮</span></span><br><span class="line">&gt;<span class="variable constant_">HONGJILINHAOSHUAI</span>  <span class="comment">//全部不亮</span></span><br><span class="line">&gt;hongjilinhaoshuai  <span class="comment">//全部高亮</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210823174207663.png" alt="image-20210823174207663"> </p><blockquote><p><code>*</code>号搭配 <code>.</code>号</p></blockquote><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*学习\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;\s*学习\s*&quot;</span> =&gt;   <span class="comment">//0~无限次,所以只要有[ 学习 ]都会被匹配,同时会被匹配的还有其紧靠的无限次的空格</span></span><br><span class="line">&gt;努力 学习的汪 hongjilins      <span class="comment">//[ 学习 ]前一个空格,后面无空格</span></span><br><span class="line">&gt;努力      学习       的汪hongjilins    <span class="comment">//[ 学习 ]前后多个空格</span></span><br><span class="line">&gt;努力学习的帅汪 <span class="title class_">Hongjilin</span>.    <span class="comment">//[ 学习 ] 前后无空格 </span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824150118740.png" alt="image-20210824150118740"> </p></blockquote><h4 id="b-号"><a href="#b-号" class="headerlink" title="b) +号"></a>b) <code>+</code>号</h4><blockquote><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。 例如表达式<code>学习.+汪</code> 匹配以中文(也可以是字母)<code>学习</code>开头以 [汪] 结尾，中间跟着至少一个字符的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习.+汪&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 hongjilins   </span><br><span class="line">&gt;努力学习的帅汪 <span class="title class_">Hongjilin</span>. </span><br><span class="line">&gt;努力学习 <span class="number">66</span> 汪 <span class="title class_">Hongjilin</span>. </span><br><span class="line">&gt;努力的学习汪   <span class="comment">//此行无匹配结果</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824152745988.png" alt="image-20210824152745988"> </p></blockquote><h4 id="c-号"><a href="#c-号" class="headerlink" title="c) ? 号"></a>c) <code>?</code> 号</h4><blockquote><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 <code>学习的[帅]?汪</code> 匹配字符串 <code>学习的汪</code> 和 <code>学习的帅汪</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习的[帅]?汪&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 hongjilins</span><br><span class="line">&gt;努力学习的帅汪 <span class="title class_">Hongjilin</span>. </span><br><span class="line">&gt;努力的学习汪 <span class="comment">//无匹配结果</span></span><br><span class="line">&gt;努力学习的帅气汪 <span class="title class_">Hongjilin</span>. <span class="comment">//无匹配结果</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824155021720.png" alt="image-20210824155021720"></p></blockquote><h3 id="Ⅳ-量词-–-gt-gt"><a href="#Ⅳ-量词-–-gt-gt" class="headerlink" title="Ⅳ -  量词  –&gt;&gt; {}"></a>Ⅳ -  量词  –&gt;&gt; <code>&#123;&#125;</code></h3><h4 id="a-正常使用示例"><a href="#a-正常使用示例" class="headerlink" title="a) 正常使用示例"></a>a) 正常使用示例</h4><blockquote><p>在正则表达式中 <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;[0-9]&#123;2,3&#125;&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的<span class="number">1</span>汪<span class="number">1</span></span><br><span class="line">&gt;努力学习的<span class="number">233</span>汪</span><br><span class="line">&gt;努力学习的<span class="number">4</span>个<span class="number">4444</span>汪</span><br><span class="line">&gt;努力学习的<span class="number">5</span>个<span class="number">55555</span>汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824160335439.png" alt="image-20210824160335439"></p></blockquote><h4 id="b-省略第二个参数-带逗号"><a href="#b-省略第二个参数-带逗号" class="headerlink" title="b) 省略第二个参数,带逗号"></a>b) 省略第二个参数,带逗号</h4><blockquote><p>我们可以省略第二个参数。 例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;[0-9]&#123;2,&#125;&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的<span class="number">1</span>汪<span class="number">1</span></span><br><span class="line">&gt;努力学习的<span class="number">233</span>汪</span><br><span class="line">&gt;努力学习的<span class="number">4</span>个<span class="number">4444</span>汪</span><br><span class="line">&gt;努力学习的<span class="number">5</span>个<span class="number">55555</span>汪</span><br></pre></td></tr></table></figure><p><a href="https://regex101.com/r/Gdy4w5/1"><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824174620834.png" alt="image-20210824174620834">  </a></p></blockquote><h4 id="c-逗号也省略"><a href="#c-逗号也省略" class="headerlink" title="c) 逗号也省略"></a>c) 逗号也省略</h4><blockquote><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]&#123;2&#125;</code> 匹配2位数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;[0-9]&#123;2&#125;&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的<span class="number">1</span>汪<span class="number">1</span></span><br><span class="line">&gt;努力学习的<span class="number">233</span>汪</span><br><span class="line">&gt;努力学习的<span class="number">4</span>个<span class="number">4444</span>汪</span><br><span class="line">&gt;努力学习的<span class="number">5</span>个<span class="number">55555</span>汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824175027635.png" alt="image-20210824175027635"> </p></blockquote><h3 id="Ⅴ-特征标群-–-gt-gt"><a href="#Ⅴ-特征标群-–-gt-gt" class="headerlink" title="Ⅴ-  特征标群  –&gt;&gt;  (...)"></a>Ⅴ-  特征标群  –&gt;&gt;  <code>(...)</code></h3><blockquote><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(学习|打工)的汪</code> 匹配 <code>学习的汪</code> 或 <code>打工的汪</code> .</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;(学习|打工)的汪 (hong)&#123;2&#125;&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 hongjilins</span><br><span class="line">&gt;努力学习打工的汪 hongjilins</span><br><span class="line">&gt;努力打工的汪 honghongjilins</span><br><span class="line">&gt;努力学习打工的汪 honghongjilins</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210824183619120.png" alt="image-20210824183619120"></p></blockquote><h3 id="Ⅵ-或运算符-–-gt-gt"><a href="#Ⅵ-或运算符-–-gt-gt" class="headerlink" title="Ⅵ - 或运算符   –&gt;&gt;  |"></a>Ⅵ - 或运算符   –&gt;&gt;  <code>|</code></h3><blockquote><p>或运算符就表示或，用作判断条件。</p><p>举个栗子:  <code>(学习|打工)的(汪|打工人)</code> 进行匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;(学习|打工)的(汪|打工人)&quot;</span> =&gt;</span><br><span class="line">&gt;努力打工的汪 hongjilins</span><br><span class="line">&gt;努力学习的打工人 honghongjilins</span><br><span class="line">&gt;努力学习打工的打工人汪 hongjilins</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825100913892.png" alt="image-20210825100913892"> </p></blockquote><h3 id="Ⅶ-转码特殊字符-–-gt-gt"><a href="#Ⅶ-转码特殊字符-–-gt-gt" class="headerlink" title="Ⅶ -  转码特殊字符   –&gt;&gt;  \"></a>Ⅶ -  转码特殊字符   –&gt;&gt;  <code>\</code></h3><blockquote><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;(学习|打工)的汪\.? hong\??&quot;</span> =&gt;</span><br><span class="line">&gt;努力打工的汪. hong</span><br><span class="line">&gt;努力学习的汪? hong</span><br><span class="line">&gt;努力学习的汪 hong?</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825102613183.png" alt="image-20210825102613183"> </p></blockquote><h3 id="Ⅷ-锚点-边界-–-gt-gt-、-、-b、-B"><a href="#Ⅷ-锚点-边界-–-gt-gt-、-、-b、-B" class="headerlink" title="Ⅷ -  锚点(边界)  –&gt;&gt;  ^、$、\b、\B"></a>Ⅷ -  锚点(边界)  –&gt;&gt;  <code>^、$、\b、\B</code></h3><blockquote><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><p>通常也会搭配<code>标志</code>(修饰符)相关知识点使用</p><p>由于还未说到<code>标志</code>相关知识,此处例子仍使用 [ /g ]全局搜索,如果对此有疑惑的可以留着疑问看下方的 <a href="#%E4%BA%94%E3%80%81%E6%A0%87%E5%BF%97">五、标志</a> </p></blockquote><h4 id="a-号-1"><a href="#a-号-1" class="headerlink" title="a) ^ 号"></a>a) <code>^</code> 号</h4><blockquote><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p>例如，<code>^(学习|打工)的汪</code> 进行匹配</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;^(学习|打工)的汪&quot;</span> =&gt;  <span class="comment">//注意:下列字符串要分四次匹配,因为即使换行了,后三行字符串本质上都不在字符串开头</span></span><br><span class="line">&gt;<span class="comment">//或者标志换成 /m 而不是 /g  因为此处还未说到标志,所以默认大家使用/g全局搜索</span></span><br><span class="line">&gt;学习的汪 hong</span><br><span class="line">&gt;打工的汪 hong</span><br><span class="line">&gt;努力打工的汪 hong</span><br><span class="line">&gt;努力学习的汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825104339765.png" alt="image-20210825104339765"> </p></blockquote><h4 id="b-号-1"><a href="#b-号-1" class="headerlink" title="b) $ 号"></a>b) <code>$</code> 号</h4><blockquote><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>学习的(汪|打工人)$</code> 匹配以 [ 汪 ] 或者 [ 打工人 ]  结尾的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习的(汪|打工人)$&quot;</span> =&gt;  <span class="comment">//注意:下列字符串要分四次匹配,因为即使换行了,前三行字符串本质上都不在字符串结尾</span></span><br><span class="line">&gt;<span class="comment">//或者标志换成 /m 而不是 /g  因为此处还未说到标志,所以默认大家使用/g全局搜索</span></span><br><span class="line">&gt;努力学习的汪 </span><br><span class="line">&gt;努力学习的打工人</span><br><span class="line">&gt;努力学习的打工人 hongjilins</span><br><span class="line">&gt;努力学习的汪_  <span class="comment">//此处 _ 模拟表示空格 </span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825105333415.png" alt="image-20210825105333415"> </p></blockquote><h4 id="c-单词边界-b"><a href="#c-单词边界-b" class="headerlink" title="c) 单词边界 \b"></a>c) 单词边界 <code>\b</code></h4><blockquote><p>\b : 单词边界:指[a-zA-z0-9]之外的字符,举个栗子:<code>\bis\b</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;\bis\b&#x27;</span>=&gt;</span><br><span class="line">&gt;<span class="title class_">My</span> name is hongjilin</span><br><span class="line">&gt;my name@is@hong jilin</span><br><span class="line">&gt;myname学is习hongjilin</span><br><span class="line">&gt;mynameishongjilin <span class="comment">//只有此处不被匹配</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825151100732.png" alt="image-20210825151100732"> </p></blockquote><h4 id="d-非单词边界-B"><a href="#d-非单词边界-B" class="headerlink" title="d) 非单词边界 \B"></a>d) 非单词边界 <code>\B</code></h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;\Bis\B&#x27;</span>=&gt;</span><br><span class="line">&gt;<span class="title class_">My</span> name is hongjilin</span><br><span class="line">&gt;my name@is@hong jilin</span><br><span class="line">&gt;myname学is习hongjilin</span><br><span class="line">&gt;mynameishongjilin <span class="comment">//只有此处被匹配,与单词边界切好相反</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825151355148.png" alt="image-20210825151355148"> </p></blockquote><h1 id="三、简写字符集"><a href="#三、简写字符集" class="headerlink" title="三、简写字符集"></a>三、简写字符集</h1><blockquote><p>这些简写字符集,简洁明了且非常常用,但是也因为这样当初没有仔细去记,用时还得查阅资料十分不便,建议背下来</p><p>正则表达式提供一些常用的字符集简写。如下:   </p><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table></blockquote><h1 id="四、零宽度断言-前后预查"><a href="#四、零宽度断言-前后预查" class="headerlink" title="四、零宽度断言 (前后预查)"></a>四、零宽度断言 (前后预查)</h1><blockquote><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（<code>仅作为约束</code>）。</p><p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>。 这个表达式匹配 <code>$</code> 开头，后面可以跟着<code>单个字符</code>:[0~9]、[.]、[?],这些字符可以出现大于等于 0 次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;(?&lt;=\$)[0-9\.\?]*&quot;</span> =&gt;</span><br><span class="line">&gt;$<span class="number">0.</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,$<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,$?<span class="number">7</span>,<span class="number">8</span>,$.<span class="number">.9</span><span class="number">.9</span>?</span><br><span class="line">&gt;<span class="comment">//0.     //4    //?7   //..9.9?</span></span><br></pre></td></tr></table></figure><p>零宽度断言如下：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>?=</td><td>正先行断言-存在</td></tr><tr><td>?!</td><td>负先行断言-排除</td></tr><tr><td>?&lt;=</td><td>正后发断言-存在</td></tr><tr><td>?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table></blockquote><h2 id="1、-正先行断言-–-gt-gt"><a href="#1、-正先行断言-–-gt-gt" class="headerlink" title="1、 正先行断言  –&gt;&gt;  ?=..."></a>1、 正先行断言  –&gt;&gt;  <code>?=...</code></h2><blockquote><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p><p>返回结果只包含满足匹配条件的第一部分表达式(即不会返回先行断言匹配部分的内容)。 定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p><p>正先行断言的内容写在括号中的等号后面。 例如，表达式 <code>学习的汪(?=\shong)</code> 首先匹配 [ 学习的汪 ]，然后在括号中我们又定义了正先行断言 <code>(?=\shong)</code> ，即  [ 学习的汪 ]后面紧跟着 [ <code>(空格)hong </code>]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习的汪(?=\shong)&quot;</span> =&gt;  <span class="comment">//此处断言中的可以再加如`+` 、`*` ......,此处举其中一个栗子说明</span></span><br><span class="line">&gt;努力学习的汪 hong <span class="comment">//只有此处被匹配到    返回: [学习的汪]  --&gt;断言中的匹配项作为约束不会返回</span></span><br><span class="line">&gt;努力学习的汪 帅</span><br><span class="line">&gt;努力学习的汪hong  <span class="comment">//此处后面没有空格</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825115024261.png" alt="image-20210825115024261"> </p></blockquote><h2 id="2、负先行断言-–-gt-gt"><a href="#2、负先行断言-–-gt-gt" class="headerlink" title="2、负先行断言  –&gt;&gt;  ?!..."></a>2、负先行断言  –&gt;&gt;  <code>?!...</code></h2><blockquote><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p><p>表达式 <code>学习的汪(?!\s+hong)</code> 首先匹配 [ 学习的汪 ]，然后在括号中我们又定义了负先行断言 <code>(?!\shong)</code> ,即  [ 学习的汪 ]后面不跟着 [ <code>(空格)hong </code> ]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;学习的汪(?!\s+hong)&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 hong  <span class="comment">//只有此处不被匹配到</span></span><br><span class="line">&gt;努力学习的汪 帅</span><br><span class="line">&gt;努力学习的汪hong</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825120225726.png" alt="image-20210825120225726"> </p></blockquote><h2 id="3、-正后发断言-–-gt-gt-lt"><a href="#3、-正后发断言-–-gt-gt-lt" class="headerlink" title="3、 正后发断言  –&gt;&gt;  ?&lt;= ..."></a>3、 正后发断言  –&gt;&gt;  <code>?&lt;= ...</code></h2><blockquote><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;=[学习|打工])的(汪|打工人)</code> 匹配  [汪]  和  [打工人] ，且需要其前方跟着 [学习] 或  [打工] 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;(?&lt;=[学习|打工])的(汪|打工人)&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪</span><br><span class="line">&gt;努力打工的打工人</span><br><span class="line">&gt;努力学习汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825134252419.png" alt="image-20210825134252419"> </p></blockquote><h2 id="4、负后发断言-–-gt-gt-lt"><a href="#4、负后发断言-–-gt-gt-lt" class="headerlink" title="4、负后发断言  –&gt;&gt;  ?&lt;!..."></a>4、负后发断言  –&gt;&gt;  <code>?&lt;!...</code></h2><blockquote><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前 <strong>不</strong> 跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;![学习|打工])的(汪|打工人)</code> 匹配  [汪]  和  [打工人] ，且需要其前方 <strong>不</strong> 跟着 [学习] 或  [打工] 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;/(?&lt;![学习|打工])的(汪|打工人)/g&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪</span><br><span class="line">&gt;努力打工的打工人</span><br><span class="line">&gt;努力学习汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825135253647.png" alt="image-20210825135253647"></p></blockquote><h1 id="五、标志-修饰符"><a href="#五、标志-修饰符" class="headerlink" title="五、标志(修饰符)"></a>五、标志(修饰符)</h1><blockquote><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写。</td></tr><tr><td>g</td><td>全局搜索。</td></tr><tr><td>m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table></blockquote><h2 id="1、全局搜索-Global-search-–-gt-gt-g"><a href="#1、全局搜索-Global-search-–-gt-gt-g" class="headerlink" title="1、全局搜索 (Global search)  –&gt;&gt;  \g"></a>1、全局搜索 (Global search)  –&gt;&gt;  <code>\g</code></h2><blockquote><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 <code>/学习的汪/g</code> 表示搜索 任意字符（除了换行）+ <code>学习的汪</code>，并返回全部结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&quot;/学习的汪/g&quot; =&gt; </span><br><span class="line">&gt;努力学习的汪</span><br><span class="line">&gt;努力学习的汪</span><br><span class="line">&gt;非常努力学习的汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825140424777.png" alt="image-20210825140424777"></p></blockquote><h2 id="2、忽略大小写-Case-Insensitive-–-gt-gt-i"><a href="#2、忽略大小写-Case-Insensitive-–-gt-gt-i" class="headerlink" title="2、忽略大小写 (Case Insensitive)  –&gt;&gt;  /i"></a>2、忽略大小写 (Case Insensitive)  –&gt;&gt;  <code>/i</code></h2><blockquote><p>修饰语 <code>i</code> 用于忽略大小写。 例如，表达式 <code>/Hong/gi</code> 表示在全局搜索 <code>Hong</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 [hong(忽略大小写)]，<code>g</code> 表示全局搜索。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;/Hong/gi&quot;</span> =&gt;  <span class="comment">//默认情况下是大小写敏感的,但此处这样标志后,就成为忽略大小写</span></span><br><span class="line">&gt;hongjilin</span><br><span class="line">&gt;<span class="title class_">Hongjilin</span></span><br><span class="line">&gt;<span class="variable constant_">HONGJILIN</span></span><br><span class="line">&gt;hOngjilin</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825142213481.png" alt="image-20210825142213481"></p></blockquote><h2 id="3、-多行注释符"><a href="#3、-多行注释符" class="headerlink" title="3、 多行注释符"></a>3、 多行注释符</h2><blockquote><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p><p>例如，表达式 <code>/学习的(汪|打工人)$/gm</code> 表示 [学习的] 后面跟着 [汪] 或 [打工人] ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。–&gt;此处举出上方锚点的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;/学习的(汪|打工人)$/gm&quot;</span> =&gt;  <span class="comment">//在之前说到 锚点 时提到,如果是 /g 只能一行一行匹配,而如果换成这个就可以直接匹配</span></span><br><span class="line">&gt;努力学习的汪</span><br><span class="line">&gt;努力学习的打工人</span><br><span class="line">&gt;努力学习的打工人 hongjilins</span><br><span class="line">&gt;努力学习的汪_  <span class="comment">//此处 _ 模拟表示空格 </span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825143341960.png" alt="image-20210825143341960"></p></blockquote><h1 id="六-、贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#六-、贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="六 、贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>六 、贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h1><h2 id="1、贪婪匹配"><a href="#1、贪婪匹配" class="headerlink" title="1、贪婪匹配"></a>1、贪婪匹配</h2><blockquote><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;/(.*汪)/&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 非常认真读书的汪  的汪  的汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825144241403.png" alt="image-20210825144241403"> </p></blockquote><h2 id="2、-惰性匹配"><a href="#2、-惰性匹配" class="headerlink" title="2、 惰性匹配"></a>2、 惰性匹配</h2><blockquote><p>我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&quot;/(.*?汪)/&quot;</span> =&gt; </span><br><span class="line">&gt;努力学习的汪 非常认真读书的汪  的汪  的汪</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825144416801.png" alt="image-20210825144416801"></p></blockquote><h1 id="七、正则常用方法"><a href="#七、正则常用方法" class="headerlink" title="七、正则常用方法"></a>七、正则常用方法</h1><blockquote><p><strong>正则中常用方法主要分为两类，一类是：RegExp对象方法；一类是：支持正则表达式的String对象的方法。</strong></p><p>此处主要列举常用的</p></blockquote><h2 id="1、-RegExp对象方法"><a href="#1、-RegExp对象方法" class="headerlink" title="1、 RegExp对象方法:"></a>1、 RegExp对象方法:</h2><blockquote><p>RegExp对象方法:exce()、test() 、compile()</p></blockquote><h3 id="Ⅰ-exce-方法"><a href="#Ⅰ-exce-方法" class="headerlink" title="Ⅰ-  exce()方法"></a>Ⅰ-  exce()方法</h3><h4 id="a-概念与介绍"><a href="#a-概念与介绍" class="headerlink" title="a) 概念与介绍"></a>a) 概念与介绍</h4><blockquote><ol><li>exec() 方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值构成的数组 ，</li><li>该数组还有继承的属性：</li></ol><ul><li>index：表示第一个匹配的字符在原字符串中的位置，</li><li>input:表示原字符串，</li><li>groups：表示当初中命名的分组时匹配到的分组对象；</li></ul><ol start="3"><li>exec()方法没有匹配到数据时返回 null。</li></ol></blockquote><h4 id="b-当正则匹配中没有分组时"><a href="#b-当正则匹配中没有分组时" class="headerlink" title="b) 当正则匹配中没有分组时"></a>b) 当正则匹配中没有分组时</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;努力666 123 学习! 456 的打工人! qrw&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> patt=<span class="regexp">/\d+/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result=patt.<span class="title function_">exec</span>(str);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825164553046.png" alt="image-20210825164553046"> </p></blockquote><h4 id="c-当正则匹配中有分组且分组存在名字时"><a href="#c-当正则匹配中有分组且分组存在名字时" class="headerlink" title="c ) 当正则匹配中有分组且分组存在名字时"></a>c ) 当正则匹配中有分组且分组存在名字时</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;努力666 123 学习! 456 的打工人! qrw&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> patt=<span class="regexp">/(?&lt;努力&gt;\d)+/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result=patt.<span class="title function_">exec</span>(str);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825165158705.png" alt="image-20210825165158705"> </p></blockquote><h4 id="d-没有匹配到符合正则的字符时"><a href="#d-没有匹配到符合正则的字符时" class="headerlink" title="d) 没有匹配到符合正则的字符时"></a>d) 没有匹配到符合正则的字符时</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;努力学习的汪&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> patt=<span class="regexp">/\d+/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result=patt.<span class="title function_">exec</span>(str);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)  <span class="comment">//返回 null</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825165311702.png" alt="image-20210825165311702"> </p></blockquote><h3 id="Ⅱ-test-方法"><a href="#Ⅱ-test-方法" class="headerlink" title="Ⅱ - test()方法"></a>Ⅱ - test()方法</h3><blockquote><p>介绍：方法用于检测一个字符串是否匹配某个模式；如果字符串中有匹配的值返回 true ，否则返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;努力学习的汪&quot;</span>;</span><br><span class="line">&gt;<span class="comment">//查找&quot;学习&quot;</span></span><br><span class="line">&gt;<span class="keyword">const</span> reg1=<span class="regexp">/学习/g</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result1=reg1.<span class="title function_">test</span>(str);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">//true</span></span><br><span class="line">&gt;<span class="comment">//查找 &quot;打工&quot;</span></span><br><span class="line">&gt;<span class="keyword">const</span> reg2=<span class="regexp">/打工/g</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result2=reg2.<span class="title function_">test</span>(str);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825165609920.png" alt="image-20210825165609920"> </p></blockquote><h3 id="Ⅲ-compile-方法"><a href="#Ⅲ-compile-方法" class="headerlink" title="Ⅲ -  compile()方法"></a>Ⅲ -  compile()方法</h3><blockquote><p>该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> reg=<span class="regexp">/[abc]/gi</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//true</span></span><br><span class="line">&gt;reg=<span class="regexp">/[cde]/gi</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line">&gt;reg.<span class="title function_">compile</span>(reg);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些</p></blockquote><h2 id="2、支持正则表达式的String对象的方法"><a href="#2、支持正则表达式的String对象的方法" class="headerlink" title="2、支持正则表达式的String对象的方法:"></a>2、支持正则表达式的String对象的方法:</h2><blockquote><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p><p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p><ul><li>[ String.prototype.match ] 调用 <code>RegExp.prototype[Symbol.match]</code></li><li>[ String.prototype.replace ]  调用 <code>RegExp.prototype[Symbol.replace]</code></li><li>[ String.prototype.search ]  调用 <code>RegExp.prototype[Symbol.search]</code></li><li>[ String.prototype.split ]  调用 <code>RegExp.prototype[Symbol.split]</code></li></ul><p>ES系列更多笔记可以点此跳转  –&gt;&gt; <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%8F%8A%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ES6及后续版本学习笔记</a></strong> </p></blockquote><h3 id="Ⅰ-search-方法"><a href="#Ⅰ-search-方法" class="headerlink" title="Ⅰ- search()方法"></a>Ⅰ- search()方法</h3><h4 id="a-概念与介绍-1"><a href="#a-概念与介绍-1" class="headerlink" title="a) 概念与介绍"></a>a) 概念与介绍</h4><blockquote><p>用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。<br>如果找到任何匹配的子串，则返回 该子串在原字符串中的第一次出现的位置。　　<br>如果没有找到任何匹配的子串，则返回 -1。</p></blockquote><h4 id="b-举个栗子"><a href="#b-举个栗子" class="headerlink" title="b) 举个栗子"></a>b) 举个栗子</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str1 = <span class="string">&#x27;努力学习 123 的汪 456&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> reg1 = <span class="regexp">/\d+/</span>; </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">search</span>(reg1));<span class="comment">//5</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">search</span>(<span class="string">&quot;的汪&quot;</span>));<span class="comment">//9</span></span><br><span class="line">&gt;<span class="keyword">const</span> str2 = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> reg2 = <span class="regexp">/\d+/</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(str2.<span class="title function_">search</span>(reg2));<span class="comment">//-1</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(str2.<span class="title function_">search</span>(<span class="string">&quot;打工人&quot;</span>));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825170353449.png" alt="image-20210825170353449"> </p></blockquote><h3 id="Ⅱ-replace-方法"><a href="#Ⅱ-replace-方法" class="headerlink" title="Ⅱ - replace()方法"></a>Ⅱ - replace()方法</h3><h4 id="a-概念与介绍-2"><a href="#a-概念与介绍-2" class="headerlink" title="a) 概念与介绍"></a>a) 概念与介绍</h4><blockquote><p>用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。原字符串不变，创建一个新的字符串</p><p>创建一个新的字符串，原字符串不变</p></blockquote><h4 id="b-替换第一个"><a href="#b-替换第一个" class="headerlink" title="b) 替换第一个"></a>b) 替换第一个</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;努力学习的汪! 努力学习的汪!! 努力学习的汪!!!&quot;</span>; </span><br><span class="line">&gt;<span class="keyword">const</span> n=str.<span class="title function_">replace</span>(<span class="string">&#x27;学习&#x27;</span>,<span class="string">&quot;打工&quot;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(str) <span class="comment">//原字符串不变</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">//新字符串</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825170801038.png" alt="image-20210825170801038"> </p></blockquote><h4 id="c-替换全部"><a href="#c-替换全部" class="headerlink" title="c) 替换全部"></a>c) 替换全部</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;努力学习的汪! 努力学习的汪!! 努力学习的汪!!!&quot;</span>; </span><br><span class="line">&gt;<span class="keyword">const</span> n=str.<span class="title function_">replace</span>(<span class="regexp">/学习/g</span>,<span class="string">&quot;打工&quot;</span>);   <span class="comment">//替换全部</span></span><br><span class="line">&gt;<span class="keyword">const</span> a=str.<span class="title function_">replace</span>(<span class="regexp">/学习/</span>,<span class="string">&quot;打工&quot;</span>); <span class="comment">//仍是替换单行</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(str) <span class="comment">//原字符串不变</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//仍是替换单行</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">//新字符串 全部替换</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825171214600.png" alt="image-20210825171214600"> </p></blockquote><h3 id="Ⅲ-split-方法"><a href="#Ⅲ-split-方法" class="headerlink" title="Ⅲ - split()方法"></a>Ⅲ - split()方法</h3><h4 id="a-概念与介绍-3"><a href="#a-概念与介绍-3" class="headerlink" title="a) 概念与介绍"></a>a) 概念与介绍</h4><blockquote><p>用于把一个字符串按符合匹配条件的方式分割成一个字符串数组。不改变原字符串</p></blockquote><h4 id="b-举个栗子-1"><a href="#b-举个栗子-1" class="headerlink" title="b) 举个栗子"></a>b) 举个栗子</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str=<span class="string">&quot;How 1are 2you 3? 4I&#x27;m 5fine! 6thanks&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> a=str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> b=str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>,<span class="number">2</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> c=str.<span class="title function_">split</span>(<span class="regexp">/\d/</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> d=str.<span class="title function_">split</span>(<span class="regexp">/\d/</span>,<span class="number">3</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// [&quot;How&quot;, &quot;1are&quot;, &quot;2you&quot;, &quot;3?&quot;, &quot;4I&#x27;m&quot;, &quot;5fine!&quot;, &quot;6thanks&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">// [&quot;How&quot;, &quot;1are&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(c);  <span class="comment">// [&quot;How &quot;, &quot;are &quot;, &quot;you &quot;, &quot;? &quot;, &quot;I&#x27;m &quot;, &quot;fine! &quot;, &quot;thanks&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(d);  <span class="comment">// [&quot;How &quot;, &quot;are &quot;, &quot;you &quot;]</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825171655993.png" alt="image-20210825171655993"> </p></blockquote><h3 id="Ⅳ-match-方法"><a href="#Ⅳ-match-方法" class="headerlink" title="Ⅳ- match()方法"></a>Ⅳ- match()方法</h3><h4 id="a-概念与介绍-4"><a href="#a-概念与介绍-4" class="headerlink" title="a) 概念与介绍"></a>a) 概念与介绍</h4><blockquote><ol><li>概念: match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配</li><li>注意点: match() 方法将检索字符串 String，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。</li></ol><ul><li>如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配，<strong>与exce的完全一致</strong></li><li>如果 regexp 有标志 g，它将找到全部符合正则子字符串，并返回一个数组。</li><li>如果没有找到任何匹配的文本，无论有没有g，match() 将返回 null</li></ul></blockquote><h4 id="b-没有g的正则匹配"><a href="#b-没有g的正则匹配" class="headerlink" title="b) 没有g的正则匹配"></a>b) 没有g的正则匹配</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str = <span class="string">&#x27;努力学习 123 的汪 456&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> reg=<span class="regexp">/\d+/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result=str.<span class="title function_">match</span>(reg); </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)  <span class="comment">//没有 全局搜索 的时候返回与 exce() 完全一致</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825173134832.png" alt="image-20210825173134832"> </p></blockquote><h4 id="c-有g的正则匹配"><a href="#c-有g的正则匹配" class="headerlink" title="c)  有g的正则匹配"></a>c)  有g的正则匹配</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str = <span class="string">&#x27;努力学习 123 的汪 456&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> reg=<span class="regexp">/\d+/g</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result=str.<span class="title function_">match</span>(reg); </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)  <span class="comment">//返回数组</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825173334751.png" alt="image-20210825173334751"> </p></blockquote><h4 id="d-没有匹配到子字符串"><a href="#d-没有匹配到子字符串" class="headerlink" title="d) 没有匹配到子字符串"></a>d) 没有匹配到子字符串</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str = <span class="string">&#x27;努力学习 123 的汪 456&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> reg=<span class="regexp">/打工/g</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> result=str.<span class="title function_">match</span>(reg); </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result)  <span class="comment">//匹配不到返回null</span></span><br></pre></td></tr></table></figure><p><img src="%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210825173421761.png" alt="image-20210825173421761"> </p></blockquote><h1 id="八、ES系列中正则的拓展"><a href="#八、ES系列中正则的拓展" class="headerlink" title="八、ES系列中正则的拓展"></a>八、ES系列中正则的拓展</h1><blockquote><p> 更多ES系列知识点笔记  –&gt;  <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%8F%8A%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ES6及后续版本学习笔记</a></strong> </p></blockquote><h2 id="1、概括与总结"><a href="#1、概括与总结" class="headerlink" title="1、概括与总结"></a>1、概括与总结</h2><blockquote><ul><li><strong>变更RegExp构造函数入参</strong>：允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</li><li><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></li><li><strong>u修饰符</strong>：Unicode模式修饰符，正确处理大于 [ \uFFFF ] 的 [ Unicode字符 ]</li><li><code>点字符</code>(.)</li><li><code>Unicode表示法</code></li><li><code>量词</code></li><li><code>预定义模式</code></li><li><code>i修饰符</code></li><li><code>转义</code></li><li><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</li><li><strong>unicode</strong>：是否设置<code>u修饰符</code></li><li><strong>sticky</strong>：是否设置<code>y修饰符</code></li><li><strong>flags</strong>：返回正则表达式的修饰符</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>y修饰符</code>隐含头部匹配标志<code>^</code></li><li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li></ul></blockquote><h2 id="2、-RegExp-构造函数"><a href="#2、-RegExp-构造函数" class="headerlink" title="2、 RegExp 构造函数"></a>2、 RegExp 构造函数</h2><blockquote><p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p><p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag 标志）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>).<span class="property">flags</span></span><br><span class="line">&gt;<span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖。</p></blockquote><h2 id="3、字符串的正则方法"><a href="#3、字符串的正则方法" class="headerlink" title="3、字符串的正则方法"></a>3、字符串的正则方法</h2><blockquote><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p><p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p><ul><li>[ String.prototype.match ] 调用 <code>RegExp.prototype[Symbol.match]</code></li><li>[ String.prototype.replace ]  调用 <code>RegExp.prototype[Symbol.replace]</code></li><li>[ String.prototype.search ]  调用 <code>RegExp.prototype[Symbol.search]</code></li><li>[ String.prototype.split ]  调用 <code>RegExp.prototype[Symbol.split]</code></li></ul></blockquote><h2 id="4、-u-修饰符"><a href="#4、-u-修饰符" class="headerlink" title="4、 u 修饰符"></a>4、 u 修饰符</h2><blockquote><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\uD83D/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^\uD83D/</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p><p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为:</p></blockquote><h3 id="Ⅰ-点字符"><a href="#Ⅰ-点字符" class="headerlink" title="Ⅰ-  点字符"></a>Ⅰ-  点字符</h3><blockquote><p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，必须加上<code>u</code>修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line">&gt;<span class="regexp">/^.$/</span>.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^.$/u</span>.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p></blockquote><h3 id="Ⅱ-Unicode-字符表示法"><a href="#Ⅱ-Unicode-字符表示法" class="headerlink" title="Ⅱ - Unicode 字符表示法"></a>Ⅱ - Unicode 字符表示法</h3><blockquote><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/\u&#123;61&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/\u&#123;61&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/\u&#123;20BB7&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\u&#123;61&#125;</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>。</p></blockquote><h3 id="Ⅲ-量词"><a href="#Ⅲ-量词" class="headerlink" title="Ⅲ -  量词"></a>Ⅲ -  量词</h3><blockquote><p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/a&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/a&#123;2&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/𠮷&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/𠮷&#123;2&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-预定义模式"><a href="#Ⅳ-预定义模式" class="headerlink" title="Ⅳ - 预定义模式"></a>Ⅳ - 预定义模式</h3><blockquote><p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\S$/</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^\S$/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p><p>利用这一点，可以写出一个正确返回字符串长度的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">codePointLength</span>(<span class="params">text</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> result = text.<span class="title function_">match</span>(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line"> <span class="keyword">return</span> result ? result.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;𠮷𠮷&#x27;</span>;</span><br><span class="line">&gt;s.<span class="property">length</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="title function_">codePointLength</span>(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-i-修饰符"><a href="#Ⅴ-i-修饰符" class="headerlink" title="Ⅴ -  i 修饰符"></a>Ⅴ -  i 修饰符</h3><blockquote><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/[a-z]/iu</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p></blockquote><h3 id="Ⅵ-转义"><a href="#Ⅵ-转义" class="headerlink" title="Ⅵ -  转义"></a>Ⅵ -  转义</h3><blockquote><p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\,</code>）无效，而在<code>u</code>模式会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/\,/</span> <span class="comment">// /\,/</span></span><br><span class="line">&gt;<span class="regexp">/\,/u</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p></blockquote><h3 id="Ⅶ-RegExp-prototype-unicode-属性"><a href="#Ⅶ-RegExp-prototype-unicode-属性" class="headerlink" title="Ⅶ- RegExp.prototype.unicode 属性"></a>Ⅶ- RegExp.prototype.unicode 属性</h3><blockquote><p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="property">unicode</span> <span class="comment">// false</span></span><br><span class="line">&gt;r2.<span class="property">unicode</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，正则表达式是否设置了<code>u</code>修饰符，可以从<code>unicode</code>属性看出来。</p></blockquote><h2 id="5、-y-修饰符"><a href="#5、-y-修饰符" class="headerlink" title="5、  y 修饰符"></a>5、  y 修饰符</h2><blockquote><p>提前剧透，<code>y</code>修饰符号相当于 <code>/g</code>隐含了头部匹配的标志<code>^</code>。带着这个思维就相对容易理解下方的<code>粘连</code>一次</p></blockquote><h3 id="Ⅰ-正常使用举例说明"><a href="#Ⅰ-正常使用举例说明" class="headerlink" title="Ⅰ -  正常使用举例说明"></a>Ⅰ -  正常使用举例说明</h3><blockquote><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。实际上相当于默认加了一个<code>^</code></p><p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]  --&gt;此时剩余字符串[_aa_a]</span></span><br><span class="line">&gt;r2.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]  --&gt;此时剩余字符串[_aa_a]</span></span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">&gt;r2.<span class="title function_">exec</span>(s) <span class="comment">// null     --&gt;y必须从第一个位置开始匹配,实际上相当于默认加了一个`^`,所以匹配不到</span></span><br></pre></td></tr></table></figure><p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p><p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">&gt;r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa_&quot;]</span></span><br><span class="line">&gt;r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa_&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码每次匹配，都是从剩余字符串的头部开始。</p></blockquote><h3 id="Ⅱ-使用lastIndex属性进行说明"><a href="#Ⅱ-使用lastIndex属性进行说明" class="headerlink" title="Ⅱ -  使用lastIndex属性进行说明"></a>Ⅱ -  使用<code>lastIndex</code>属性进行说明</h3><blockquote><p>使用<code>lastIndex</code>属性，可以更好地说明<code>y</code>修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/g</span>;</span><br><span class="line">&gt;<span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 匹配成功</span></span><br><span class="line">&gt;<span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">&gt;match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>lastIndex</code>属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止。</p><p><code>y</code>修饰符同样遵守<code>lastIndex</code>属性，但是要求必须在<code>lastIndex</code>指定的位置发现匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/y</span>;</span><br><span class="line">&gt;<span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line">&gt;<span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">3</span>;</span><br><span class="line">&gt;<span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line">&gt;<span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">&gt;match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>实际上，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/b/y</span>.<span class="title function_">exec</span>(<span class="string">&#x27;aba&#x27;</span>)<span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p></blockquote><h3 id="Ⅲ-使用字符串对象的replace方法的举例"><a href="#Ⅲ-使用字符串对象的replace方法的举例" class="headerlink" title="Ⅲ - 使用字符串对象的replace方法的举例"></a>Ⅲ - 使用字符串对象的<code>replace</code>方法的举例</h3><blockquote><p>下面是字符串对象的<code>replace</code>方法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/gy</span>;</span><br><span class="line">&gt;<span class="string">&#x27;aaxa&#x27;</span>.<span class="title function_">replace</span>(<span class="variable constant_">REGEX</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;--xa&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个<code>a</code>因为不是出现在下一次匹配的头部，所以不会被替换。</p><p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line">&gt;<span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure><p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">TOKEN_Y</span> = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">TOKEN_G</span>  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = [];</span><br><span class="line"> <span class="keyword">let</span> match;</span><br><span class="line"> <span class="keyword">while</span> (match = <span class="variable constant_">TOKEN_REGEX</span>.<span class="title function_">exec</span>(str)) &#123;</span><br><span class="line">   result.<span class="title function_">push</span>(match[<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27; ]</span></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误。</p></blockquote><h3 id="Ⅳ-RegExp-prototype-sticky-属性"><a href="#Ⅳ-RegExp-prototype-sticky-属性" class="headerlink" title="Ⅳ -  RegExp.prototype.sticky 属性"></a>Ⅳ -  RegExp.prototype.sticky 属性</h3><blockquote><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">&gt;r.<span class="property">sticky</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="6、s-修饰符：dotAll-模式"><a href="#6、s-修饰符：dotAll-模式" class="headerlink" title="6、s 修饰符：dotAll 模式"></a>6、s 修饰符：dotAll 模式</h2><blockquote><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p><p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p><ul><li>U+000A 换行符（<code>\n</code>）</li><li>U+000D 回车符（<code>\r</code>）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为<code>.</code>不匹配<code>\n</code>，所以正则表达式返回<code>false</code>。</p><p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo[^]bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种解决方案毕竟不太符合直觉， <a href="https://github.com/tc39/proposal-regexp-dotall-flag">ES2018</a> 引入<code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>s.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line">&gt;<span class="comment">// 另一种写法</span></span><br><span class="line">&gt;<span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line">&gt;re.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;re.<span class="property">dotAll</span> <span class="comment">// true</span></span><br><span class="line">&gt;re.<span class="property">flags</span> <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure><p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾。</p></blockquote><h2 id="7、-RegExp-prototype-flags-属性"><a href="#7、-RegExp-prototype-flags-属性" class="headerlink" title="7、 RegExp.prototype.flags 属性"></a>7、 RegExp.prototype.flags 属性</h2><blockquote><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的 source 属性</span></span><br><span class="line">&gt;<span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">&gt;<span class="regexp">/abc/ig</span>.<span class="property">source</span></span><br><span class="line">&gt;<span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的 flags 属性</span></span><br><span class="line">&gt;<span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">&gt;<span class="regexp">/abc/ig</span>.<span class="property">flags</span></span><br><span class="line">&gt;<span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="8、-Unicode-属性类"><a href="#8、-Unicode-属性类" class="headerlink" title="8、 Unicode 属性类"></a>8、 Unicode 属性类</h2><blockquote><p>ES2018 <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">引入</a>了一种新的类的写法<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">&gt;regexGreekSymbol.<span class="title function_">test</span>(<span class="string">&#x27;π&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>\p&#123;Script=Greek&#125;</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p><p>Unicode 属性类要指定属性名和属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyName</span>=<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure><p>对于某些属性，可以只写属性名，或者只写属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyName</span>&#125;</span><br><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure><p><code>\P&#123;…&#125;</code>是<code>\p&#123;…&#125;</code>的反向匹配，即匹配不满足条件的字符。</p><p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加<code>u</code>修饰符，正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript 预留了这两个类。</p><p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p><p><code>\p&#123;Number&#125;</code>甚至能匹配罗马数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 匹配所有数字</span></span><br><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;²³¹¼½¾&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;㉛㉜㉝&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面是其他一些例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 匹配所有空格</span></span><br><span class="line">&gt;\p&#123;<span class="title class_">White</span>_Space&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">&gt;[\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">&gt;[^\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配 Emoji</span></span><br><span class="line">&gt;<span class="regexp">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line">&gt;<span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">&gt;regexArrows.<span class="title function_">test</span>(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="9、-具名组匹配"><a href="#9、-具名组匹配" class="headerlink" title="9、 具名组匹配"></a>9、 具名组匹配</h2><h3 id="Ⅰ-简介"><a href="#Ⅰ-简介" class="headerlink" title="Ⅰ-  简介"></a>Ⅰ-  简介</h3><blockquote><p>正则表达式使用圆括号进行组匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">&gt;<span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">&gt;<span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p><p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line">&gt;<span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line">&gt;<span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加 [ “问号 + 尖括号 + 组名” ] （<code>?&lt;year&gt;</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p><p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p><p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_OPT_A</span> = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_OPT_A</span>.<span class="title function_">exec</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;matchObj.<span class="property">groups</span>.<span class="property">as</span> <span class="comment">// undefined</span></span><br><span class="line">&gt;<span class="string">&#x27;as&#x27;</span> <span class="keyword">in</span> matchObj.<span class="property">groups</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的。</p></blockquote><h3 id="Ⅱ-解构赋值和替换"><a href="#Ⅱ-解构赋值和替换" class="headerlink" title="Ⅱ -  解构赋值和替换"></a>Ⅱ -  解构赋值和替换</h3><blockquote><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.<span class="title function_">exec</span>(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">&gt;one  <span class="comment">// foo</span></span><br><span class="line">&gt;two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式。</p><p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture1, <span class="comment">// 第一个组匹配 2015</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture2, <span class="comment">// 第二个组匹配 01</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture3, <span class="comment">// 第三个组匹配 02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  position, <span class="comment">// 匹配开始的位置 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  S, <span class="comment">// 原字符串 2015-01-02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p></blockquote><h3 id="Ⅲ-引用"><a href="#Ⅲ-引用" class="headerlink" title="Ⅲ -  引用"></a>Ⅲ -  引用</h3><blockquote><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>数字引用（<code>\1</code>）依然有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这两种引用语法还可以同时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="10、String-prototype-matchAll"><a href="#10、String-prototype-matchAll" class="headerlink" title="10、String.prototype.matchAll()"></a>10、String.prototype.matchAll()</h2><blockquote><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> matches = [];</span><br><span class="line">&gt;<span class="keyword">var</span> match;</span><br><span class="line">&gt;<span class="keyword">while</span> (match = regex.<span class="title function_">exec</span>(string)) &#123;</span><br><span class="line"> matches.<span class="title function_">push</span>(match);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;matches</span><br><span class="line">&gt;<span class="comment">// [</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p><p><a href="https://github.com/tc39/proposal-string-matchall">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p><p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 转为数组的方法一</span></span><br><span class="line">&gt;[...string.<span class="title function_">matchAll</span>(regex)]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 转为数组的方法二</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex))</span><br></pre></td></tr></table></figure></blockquote><h1 id="九、常用正则收录"><a href="#九、常用正则收录" class="headerlink" title="九、常用正则收录"></a>九、常用正则收录</h1><h2 id="1、正则表达式只保留数字"><a href="#1、正则表达式只保留数字" class="headerlink" title="1、正则表达式只保留数字"></a>1、正则表达式只保留数字</h2><blockquote><ol><li>正则代码</li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;str=str.<span class="title function_">replaceAll</span>(<span class="string">&quot;[^0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//此表达式匹配错误</span></span><br><span class="line">&gt;str=str.<span class="title function_">replace</span>(<span class="regexp">/\D/g</span>,<span class="string">&#x27;&#x27;</span>); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ol start="2"><li>调用代码示例</li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span> store.<span class="title function_">changeSearchParamsValue</span>(<span class="string">&#x27;storeId&#x27;</span>)(e.<span class="property">target</span>.<span class="property">value</span>.<span class="title function_">replace</span>(<span class="regexp">/\D/g</span>,<span class="string">&#x27;&#x27;</span>))&#125; </span><br><span class="line">&gt;@action changeSearchNumberParamsValue = <span class="function">(<span class="params">type</span>) =&gt;</span> <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//this.searchParams[type] = value.replace(/\D/g,&#x27;&#x27;); 外面限制好后传入</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">searchParams</span>[type] = value;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现效果</li></ol><blockquote><p>输入非数字内容则无法键入(替换为空)</p></blockquote></blockquote><h2 id="2、限制不能为空以及中文"><a href="#2、限制不能为空以及中文" class="headerlink" title="2、限制不能为空以及中文"></a>2、限制不能为空以及中文</h2><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;str=str.<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/[\u4E00-\u9FA5]|[\uFE30-\uFFA0]/gi</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sass相关</title>
      <link href="/2022/10/20/Sass/"/>
      <url>/2022/10/20/Sass/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="SassScript"><a href="#SassScript" class="headerlink" title="SassScript"></a>SassScript</h1></blockquote><blockquote><p>在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。</p><p>弱类型语言, 对语法要求没那么严格</p></blockquote><h2 id="一、注释"><a href="#一、注释" class="headerlink" title="一、注释"></a>一、注释</h2><blockquote><ol><li><p>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释 <code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</p></li><li><p>将 <code>!</code> 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p></li><li><p>插值语句 (interpolation) 也可写进多行注释中输出变量值</p></li></ol><p>  例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// compile scss files to css</span></span><br><span class="line">&gt;<span class="comment">// it&#x27;s ready to do it.</span></span><br><span class="line">&gt;<span class="variable">$pink</span>: <span class="number">#f3e1e1</span>;</span><br><span class="line">&gt;<span class="selector-tag">html</span>&#123;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="variable">$pink</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable">$author</span>: <span class="string">&#x27;gdream@126.com&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">/*!</span></span><br><span class="line"><span class="comment">Author: #&#123;$author&#125;.</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><p>开发模式编译后:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* </span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world!</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br><span class="line">&gt;<span class="selector-tag">html</span>&#123;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#f3e1e1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">/*!</span></span><br><span class="line"><span class="comment">Author: &#x27;gdream@126.com&#x27;.</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><p>压缩输出模式编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">html</span>&#123;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#f3e1e1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">/*!</span></span><br><span class="line"><span class="comment">Author: &#x27;gdream@126.com&#x27;.</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><blockquote><p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">1600px</span>;</span><br><span class="line"><span class="variable">$pen-size</span>: <span class="number">3em</span>;</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><blockquote><p>直接使用变量的名称即可调用变量</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$pen-size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3.作用域"></a>3.作用域</h3><blockquote><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#foo</span> &#123;</span><br><span class="line">  <span class="variable">$width</span>: <span class="number">5em</span> !global;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#bar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#foo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#bar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><blockquote><p>SassScript 支持 7 种主要的数据类型：</p><ul><li>数字，<code>1, 2, 13, 10px</code></li><li>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></li><li>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)</code></li><li>布尔型，<code>true, false</code></li><li>空值，<code>null</code></li><li>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></li><li>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></li></ul><p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p><p>判断数据类型的方式：<code>type-of($value)</code></p></blockquote><h3 id="1-字符串-Strings"><a href="#1-字符串-Strings" class="headerlink" title="1.字符串 (Strings)"></a>1.字符串 (Strings)</h3><blockquote><p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>: <span class="string">&#x27;Tom Bob&#x27;</span>;</span><br><span class="line"><span class="variable">$container</span>: <span class="string">&quot;top bottom&quot;</span>;</span><br><span class="line"><span class="variable">$what</span>: heart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#&#123;&#125;` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名</span></span><br></pre></td></tr></table></figure><h3 id="2-数字-Numbers"><a href="#2-数字-Numbers" class="headerlink" title="2.数字(Numbers)"></a>2.数字(Numbers)</h3><blockquote><p>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可正可浮点）</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$my-age</span>: <span class="number">19</span>;</span><br><span class="line"><span class="variable">$your-age</span>: <span class="number">19.5</span>;</span><br><span class="line"><span class="variable">$height</span>: <span class="number">120px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：单位会和数字当做一个整体，进行算数运算</span></span><br></pre></td></tr></table></figure><h3 id="3-空值-Null"><a href="#3-空值-Null" class="headerlink" title="3.空值(Null)"></a>3.空值(Null)</h3><blockquote><p>只有一个取值<code>null</code></p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$value</span>: null;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算</span></span><br></pre></td></tr></table></figure><h3 id="4-布尔型-Booleans"><a href="#4-布尔型-Booleans" class="headerlink" title="4.布尔型(Booleans)"></a>4.布尔型(Booleans)</h3><blockquote><p>只有两个取值：<code>true</code>和<code>false</code></p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: true;</span><br><span class="line"><span class="variable">$b</span>: false;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：只有自身是false和null才会返回false，其他一切都将返回true</span></span><br></pre></td></tr></table></figure><h3 id="5-数组-Lists"><a href="#5-数组-Lists" class="headerlink" title="5.数组 (Lists)"></a>5.数组 (Lists)</h3><blockquote><p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$list0</span>: <span class="number">1px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">6px</span>;</span><br><span class="line"><span class="variable">$list1</span>: <span class="number">1px</span> <span class="number">2px</span>, <span class="number">5px</span> <span class="number">6px</span>;</span><br><span class="line"><span class="variable">$list2</span>: (<span class="number">1px</span> <span class="number">2px</span>) (<span class="number">5px</span> <span class="number">6px</span>);</span><br></pre></td></tr></table></figure><blockquote><p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p><p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p><p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p><p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p></blockquote><h3 id="6-映射-Maps"><a href="#6-映射-Maps" class="headerlink" title="6.映射(Maps)"></a>6.映射(Maps)</h3><blockquote><p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$map</span>: ( </span><br><span class="line">  <span class="variable">$key1</span>: value1, </span><br><span class="line">  <span class="variable">$key2</span>: value2, </span><br><span class="line">  <span class="variable">$key3</span>: value3 </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="7-颜色-Colors"><a href="#7-颜色-Colors" class="headerlink" title="7.颜色 (Colors)"></a>7.颜色 (Colors)</h3><blockquote><p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词</p><p>SCSS提供了内置Colors函数，从而更方便地使用颜色</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color0</span>: green;</span><br><span class="line"><span class="variable">$color1</span>: <span class="built_in">lighten</span>(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color2</span>: <span class="built_in">darken</span>(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color3</span>: <span class="built_in">saturate</span>(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color4</span>: <span class="built_in">desaturate</span>(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color5</span>: (green + red);</span><br></pre></td></tr></table></figure><hr><h2 id="四、运算"><a href="#四、运算" class="headerlink" title="四、运算"></a>四、运算</h2><h3 id="1-数字运算符"><a href="#1-数字运算符" class="headerlink" title="1.数字运算符"></a>1.数字运算符</h3><blockquote><p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p><p>如果要保留运算符号，则应该使用插值语法</p></blockquote><ul><li><p><code>+</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯数字</span></span><br><span class="line"><span class="variable">$add1</span>: <span class="number">1</span> + <span class="number">2</span>;<span class="comment">// 3</span></span><br><span class="line"><span class="variable">$add2</span>: <span class="number">1</span> + <span class="number">2px</span>; <span class="comment">// 3px</span></span><br><span class="line"><span class="variable">$add3</span>: <span class="number">1px</span> + <span class="number">2</span>; <span class="comment">// 3px</span></span><br><span class="line"><span class="variable">$add4</span>: <span class="number">1px</span> + <span class="number">2px</span>;<span class="comment">//3px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯字符串</span></span><br><span class="line"><span class="variable">$add5</span>: <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// &quot;ab&quot;</span></span><br><span class="line"><span class="variable">$add6</span>: <span class="string">&quot;a&quot;</span> + b;  <span class="comment">// &quot;ab&quot;</span></span><br><span class="line"><span class="variable">$add7</span>: a + <span class="string">&quot;b&quot;</span>;  <span class="comment">// ab</span></span><br><span class="line"><span class="variable">$add8</span>: a + b;  <span class="comment">// ab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字和字符串</span></span><br><span class="line"><span class="variable">$add9</span>: <span class="number">1</span> + a;<span class="comment">// 1a</span></span><br><span class="line"><span class="variable">$adda</span>: a + <span class="number">1</span>;<span class="comment">// a1</span></span><br><span class="line"><span class="variable">$addb</span>: <span class="string">&quot;1&quot;</span> + a; <span class="comment">// &quot;1a&quot;</span></span><br><span class="line"><span class="variable">$addc</span>: <span class="number">1</span> + <span class="string">&quot;a&quot;</span>; <span class="comment">// &quot;1a&quot;</span></span><br><span class="line"><span class="variable">$addd</span>: <span class="string">&quot;a&quot;</span> + <span class="number">1</span>; <span class="comment">// &quot;a1&quot;</span></span><br><span class="line"><span class="variable">$adde</span>: a + <span class="string">&quot;1&quot;</span>; <span class="comment">// a1</span></span><br><span class="line"><span class="variable">$addf</span>: <span class="number">1</span> + <span class="string">&quot;1&quot;</span>; <span class="comment">// &quot;11&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line"><span class="selector-tag">a</span>.纯数字：只要有单位，结果必有单位</span><br><span class="line"><span class="selector-tag">b</span>.纯字符串：第一个字符串有无引号决定结果是否有引号</span><br><span class="line">c数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号</span><br></pre></td></tr></table></figure></li><li><p><code>-</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$add1</span>: <span class="number">1</span> - <span class="number">2</span>;<span class="comment">// -1</span></span><br><span class="line"><span class="variable">$add2</span>: <span class="number">1</span> - <span class="number">2px</span>; <span class="comment">// -1px</span></span><br><span class="line"><span class="variable">$add3</span>: <span class="number">1px</span> - <span class="number">2</span>; <span class="comment">// -1px</span></span><br><span class="line"><span class="variable">$add4</span>: <span class="number">1px</span> - <span class="number">2px</span>;<span class="comment">//-1px</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sub1</span>: a - <span class="number">1</span>;  <span class="comment">// a-1</span></span><br><span class="line"><span class="variable">$sub2</span>: <span class="number">1</span> - a;  <span class="comment">// 1-a</span></span><br><span class="line"><span class="variable">$sub3</span>: <span class="string">&quot;a&quot;</span> - <span class="number">1</span>;<span class="comment">// &quot;a&quot;-1</span></span><br><span class="line"><span class="variable">$sub4</span>: a - <span class="string">&quot;1&quot;</span>;<span class="comment">// a-&quot;1&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line">每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。</span><br><span class="line">只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来</span><br></pre></td></tr></table></figure></li><li><p><code>*</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num1</span>: <span class="number">1</span> * <span class="number">2</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="variable">$mul2</span>: <span class="number">1</span> * <span class="number">2px</span>;  <span class="comment">// 2px</span></span><br><span class="line"><span class="variable">$num3</span>: <span class="number">1px</span> * <span class="number">2</span>;  <span class="comment">// 2px</span></span><br><span class="line"><span class="variable">$num4</span>: <span class="number">2px</span> * <span class="number">2px</span>;<span class="comment">// 编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$num5</span>: <span class="number">1</span> * <span class="number">2</span>abc; <span class="comment">// 2abc</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line">每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过</span><br></pre></td></tr></table></figure></li><li><p><code>/</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line"><span class="selector-tag">a</span>.不会四舍五入，精确到小数点后<span class="number">5</span>位</span><br><span class="line"><span class="selector-tag">b</span>.每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来。</span><br><span class="line">(因为此时后缀被当被单位看待了)</span><br></pre></td></tr></table></figure></li><li><p><code>%</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line"><span class="selector-tag">a</span>.值与&quot;%&quot;之间必须要有空格，否则会被看做字符串</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h3><blockquote><p>大前提：两端必须为<code>数字</code> 或 <code>前部分数字后部分字符</code></p><p>返回值：<code>true</code> or <code>false</code></p></blockquote><ul><li><p><code>&gt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &gt; <span class="number">2</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &gt; <span class="number">2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>&gt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &gt;= <span class="number">2</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &lt;= <span class="number">2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-相等运算符"><a href="#3-相等运算符" class="headerlink" title="3.相等运算符"></a>3.相等运算符</h3><blockquote><p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p><p>返回值：<code>true</code> or <code>false</code></p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> == <span class="number">1px</span>; <span class="comment">// true</span></span><br><span class="line"><span class="variable">$b</span>: <span class="string">&quot;a&quot;</span> == a; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line">前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应</span><br></pre></td></tr></table></figure><h3 id="4-布尔运算符"><a href="#4-布尔运算符" class="headerlink" title="4.布尔运算符"></a>4.布尔运算符</h3><blockquote><p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span>&gt;<span class="number">0</span> and <span class="number">0</span>&gt;=<span class="number">5</span>; <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总结：</span></span><br><span class="line">值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串</span><br></pre></td></tr></table></figure><h3 id="5-颜色值运算"><a href="#5-颜色值运算" class="headerlink" title="5.颜色值运算"></a>5.颜色值运算</h3><blockquote><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p></blockquote><ul><li><p><code>颜色值与颜色值</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> + <span class="number">#040506</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</span></span><br><span class="line"><span class="comment">// p &#123;</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#050709</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>颜色值与数字</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为</span></span><br><span class="line"><span class="comment">// p &#123;</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#020406</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>RGB和HSL</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>) + <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p &#123;</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>); &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-运算优先级"><a href="#6-运算优先级" class="headerlink" title="6.运算优先级"></a>6.运算优先级</h3><ol start="0"><li><p><code>()</code></p></li><li><p><code>*</code>、<code>/</code>、<code>%</code></p></li><li><p><code>+</code>、<code>-</code></p></li><li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p></li></ol><hr><h2 id="五、嵌套语法"><a href="#五、嵌套语法" class="headerlink" title="五、嵌套语法"></a>五、嵌套语法</h2><blockquote><p>此部分不计入笔记</p></blockquote><hr><h2 id="六、杂货语法"><a href="#六、杂货语法" class="headerlink" title="六、杂货语法"></a>六、杂货语法</h2><h3 id="1-插值语法"><a href="#1-插值语法" class="headerlink" title="1.插值语法"></a>1.<code>插值语法</code></h3><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p><p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>: foo;</span><br><span class="line"><span class="variable">$attr</span>: border;</span><br><span class="line"><span class="selector-tag">p</span>.#&#123;<span class="variable">$name</span>&#125; &#123;</span><br><span class="line">  #&#123;<span class="variable">$attr</span>&#125;-<span class="attribute">color</span>: <span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-amp-in-SassScript"><a href="#2-amp-in-SassScript" class="headerlink" title="2.&amp; in SassScript"></a>2.<code>&amp; in SassScript</code></h3><p><code>&amp;</code>为父选择器</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;<span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: blank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-default"><a href="#3-default" class="headerlink" title="3.!default"></a>3.<code>!default</code></h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$content</span>: <span class="string">&quot;First content&quot;</span>;</span><br><span class="line"><span class="variable">$content</span>: <span class="string">&quot;Second content?&quot;</span> !default;</span><br><span class="line"><span class="variable">$new_content</span>: <span class="string">&quot;First time reference&quot;</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="variable">$content</span>;</span><br><span class="line">  new-<span class="attribute">content</span>: <span class="variable">$new_content</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;First content&quot;</span>;</span><br><span class="line">  new-<span class="attribute">content</span>: <span class="string">&quot;First time reference&quot;</span>; &#125;</span><br></pre></td></tr></table></figure><p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。</p><h3 id="3-global"><a href="#3-global" class="headerlink" title="3.!global"></a>3.<code>!global</code></h3><p>将局部变量提升为全局变量</p><h3 id="4-optional"><a href="#4-optional" class="headerlink" title="4.!optional"></a>4.<code>!optional</code></h3><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123;@extend .notice&#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p><p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的.</p><p>简而言之：当<code>@extend</code>相关代码出现语法错误时，编译器可能会给我们”乱”编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码</p><hr><h2 id="七、-Rules与指令"><a href="#七、-Rules与指令" class="headerlink" title="七、@-Rules与指令"></a>七、@-Rules与指令</h2><h3 id="1-import"><a href="#1-import" class="headerlink" title="1.@import"></a>1.<code>@import</code></h3><blockquote><p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p><p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p><ul><li>文件拓展名是 <code>.css</code>；</li><li>文件名以 <code>http://</code> 开头；</li><li>文件名是 <code>url()</code>；</li><li><code>@import</code> 包含 media queries。</li></ul><p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo.scss&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="comment">// 以上两种方式均可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式均不可行</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo.css&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo&quot;</span> screen;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;http://foo.com/bar&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> url(foo);</span><br></pre></td></tr></table></figure><blockquote><p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;rounded-corners&quot;</span>, <span class="string">&quot;text-shadow&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式：</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$family</span>: <span class="built_in">unquote</span>(<span class="string">&quot;Droid+Sans&quot;</span>);</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;http://fonts.googleapis.com/css?family=\#&#123;$family&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p><p>除此之外，还支持嵌套 @import,但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p></blockquote><h3 id="2-media"><a href="#2-media" class="headerlink" title="2.@media"></a>2.<code>@media</code></h3><blockquote><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>; &#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$media</span>: screen;</span><br><span class="line"><span class="variable">$feature</span>: -webkit-min-device-pixel-ratio;</span><br><span class="line"><span class="variable">$value</span>: <span class="number">1.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> #&#123;<span class="variable">$media</span>&#125; and ($feature: $value) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">1.5</span>) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="3-extend"><a href="#3-extend" class="headerlink" title="3.*@extend"></a>3.<code>*@extend</code></h3><blockquote><p><code>@extend</code>即<code>继承</code>。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。</p><p>总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）</p></blockquote><p>a. <code>基本延伸</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。</span></span><br></pre></td></tr></table></figure><blockquote><p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）</p></blockquote><p>注意理解以下情况：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.error</span><span class="selector-class">.intrusion</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;/image/hacked.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .error, .seriousError &#123;</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span><span class="selector-class">.intrusion</span>, <span class="selector-class">.seriousError</span><span class="selector-class">.intrusion</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;/image/hacked.png&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>当合并选择器时，<code>@extend</code> 会很聪明地避免无谓的重复，<code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code>，不能匹配任何元素的选择器也会删除。</p></blockquote><p>b.  <code>延伸复杂的选择器</code>：Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等</p><p>c. <code> 多重延伸</code>：同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器</p><p>d. <code>继续延伸</code>：当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个</p><p>e.<code>*选择器列</code>：暂时不可以将选择器列 (Selector Sequences)，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code>，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。</p><p>尽量不使用<code>合并选择器列</code>，因为如果凭个人推理的话，会出现排列组合的情况，所以SASS编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。</p><ol><li><p>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span>,</span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold; &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.overview</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold; &#125;</span><br></pre></td></tr></table></figure></li></ol><p>f. <code>在指令中延伸</code></p><p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS.</p><p>g.  <code>%placeholder</code>为选择器占位符，配合<code>@extend-Only选择器</code>使用。</p><p>效果：只定义了样式，但不会对原有选择器匹配的元素生效</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1:</span></span><br><span class="line">%<span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.path</span>&#123;</span><br><span class="line">    <span class="keyword">@extend</span> %img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-class">.path</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example2:</span></span><br><span class="line"><span class="selector-id">#context</span> <span class="selector-tag">a</span>%extreme &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %extreme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：必须是&quot;.&quot;和&quot;#&quot;选择器</span></span><br></pre></td></tr></table></figure><h3 id="4-at-root"><a href="#4-at-root" class="headerlink" title="4.@at-root"></a>4.<code>@at-root</code></h3><blockquote><p>The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector</p><p>译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用</p><p>且@at-root 使多个规则跳出嵌套</p><p>@at-root默认情况下并不能使规则或者选择器跳出指令，通过使用without和with可以解决该问题</p><p>了解即可</p></blockquote><h3 id="5-debug"><a href="#5-debug" class="headerlink" title="5.@debug"></a>5.<code>@debug</code></h3><p>用于调试，按标准错误输出流输出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$size</span>: <span class="number">9px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.file</span>&#123;</span><br><span class="line">  <span class="keyword">@debug</span> <span class="variable">$size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-warn"><a href="#6-warn" class="headerlink" title="6.@warn"></a>6.<code>@warn</code></h3><p>用于警告，按标准错误输出流输出</p><h3 id="7-error"><a href="#7-error" class="headerlink" title="7.@error"></a>7.<code>@error</code></h3><p>用于报错，按标准错误输出流输出</p><table><thead><tr><th>序列</th><th>@-rules</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>@import</td><td>导入sass或scss文件</td></tr><tr><td>2</td><td>@media</td><td>用于将样式规则设置为不同的媒体类型</td></tr><tr><td>3</td><td>@extend</td><td>以继承的方式共享选择器</td></tr><tr><td>4</td><td>@at-root</td><td>转到根节点</td></tr><tr><td>5</td><td>@debug</td><td>用于调试，按标准错误输出流输出</td></tr><tr><td>6</td><td>@warn</td><td>用于警告，按标准错误输出流输出</td></tr><tr><td>7</td><td>@error</td><td>用于报错，按标准错误输出流输出</td></tr></tbody></table><hr><h2 id="八、控制指令"><a href="#八、控制指令" class="headerlink" title="八、控制指令"></a>八、控制指令</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1.if()"></a>1.<code>if()</code></h3><p><em>三元运算符</em></p><p>表达式：<code>if(expression, value1, value2)</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">if</span>(<span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>, green, yellow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-if"><a href="#2-if" class="headerlink" title="2.@if"></a>2.<code>@if</code></h3><p><em>条件语句</em></p><p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p><p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p><ul><li><p><code>单@if</code></p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> != <span class="number">2</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@if - @else if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$age</span>: <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="keyword">@if</span> <span class="variable">$age</span> == <span class="number">18</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if <span class="variable">$age</span> == <span class="number">19</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-for"><a href="#3-for" class="headerlink" title="3.@for"></a>3.<code>@for</code></h3><p><em>循环语句</em></p><p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p><p>through 和 to 的相同点与不同点：</p><ul><li>相同点：两者均包含<start>的值</li><li>不同点：through包含<end>的值，但to不包含<end>的值</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>; &#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>; &#125;</span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6em</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="4-while"><a href="#4-while" class="headerlink" title="4.@while"></a>4.<code>@while</code></h3><p><em>循环语句</em></p><p>表达式：<code>@while expression</code></p><p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>; &#125;</span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>; &#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>; &#125;</span><br></pre></td></tr></table></figure><h3 id="5-each"><a href="#5-each" class="headerlink" title="5.@each"></a>5.<code>@each</code></h3><p><em>循环语句</em></p><p>表达式：<code>$var in $vars</code></p><p><code>$var</code> 可以是任何变量名</p><p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p><ul><li><p>一维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span> in puma, sea-slug, egret, salamander &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/puma.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/sea-slug.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/egret.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.salamander-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/salamander.png&#x27;</span>); &#125;</span><br></pre></td></tr></table></figure></li><li><p>二维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span>, <span class="variable">$color</span>, <span class="variable">$cursor</span> in (puma, black, default),</span><br><span class="line">                                  (sea-slug, blue, <span class="attribute">pointer</span>),</span><br><span class="line">                                  (egret, white, move) &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="variable">$cursor</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/puma.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">cursor</span>: default; &#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/sea-slug.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer; &#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/egret.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid white;</span><br><span class="line">  <span class="attribute">cursor</span>: move; &#125;</span><br></pre></td></tr></table></figure></li><li><p>maps</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$header</span>, <span class="variable">$size</span> in (h1: <span class="number">2em</span>, h2: <span class="number">1.5em</span>, h3: <span class="number">1.2em</span>) &#123;</span><br><span class="line">  #&#123;<span class="variable">$header</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>; &#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>; &#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="九、混合指令"><a href="#九、混合指令" class="headerlink" title="九、混合指令"></a>九、混合指令</h2><blockquote><p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p></blockquote><p>注意：这不是函数！没有返回值！！</p><h3 id="1-定义混合指令"><a href="#1-定义混合指令" class="headerlink" title="1.定义混合指令"></a>1.定义混合指令</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="keyword">@mixin</span> name &#123;</span><br><span class="line">    <span class="comment">// 样式....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example：</span></span><br><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: Arial;</span><br><span class="line">    size: <span class="number">20px</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-引用混合样式"><a href="#2-引用混合样式" class="headerlink" title="2.引用混合样式"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="keyword">@include</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：无参数或参数都有默认值时，带不带括号都可以</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example：</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> large-text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-参数"><a href="#3-参数" class="headerlink" title="3.参数"></a>3.参数</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p><p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p><h4 id="a-位置传参"><a href="#a-位置传参" class="headerlink" title="a. 位置传参"></a>a. 位置传参</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mp(<span class="variable">$width</span>) &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> mp(<span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b-关键词传参"><a href="#b-关键词传参" class="headerlink" title="b.关键词传参"></a>b.关键词传参</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mp(<span class="variable">$width</span>) &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> mp(<span class="variable">$width</span>: <span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="c-参数默认值"><a href="#c-参数默认值" class="headerlink" title="c.参数默认值"></a>c.参数默认值</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mp(<span class="variable">$width</span>: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> mp(<span class="variable">$width</span>: <span class="number">300px</span>);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    <span class="keyword">@include</span> mp(<span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d-不定参数"><a href="#d-不定参数" class="headerlink" title="d.不定参数"></a>d.不定参数</h4><blockquote><p>官方：Variable Arguments</p><p>译文：参数变量</p><p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mar(<span class="variable">$value</span>...) &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-向混合样式中导入内容"><a href="#4-向混合样式中导入内容" class="headerlink" title="4.向混合样式中导入内容"></a>4.向混合样式中导入内容</h3><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方</p><p>可以看作参数的升级版</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> example &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> example&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="selector-class">.logo</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-混合指令用例"><a href="#5-混合指令用例" class="headerlink" title="5.混合指令用例"></a>5.混合指令用例</h3><blockquote><p><img src="A_SassScript%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%E7%94%A8%E4%BE%8B.png" alt="混合指令用例"></p></blockquote><hr><h2 id="十、函数指令"><a href="#十、函数指令" class="headerlink" title="十、函数指令"></a>十、函数指令</h2><h3 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1.内置函数"></a>1.内置函数</h3><h4 id="a-字符串函数"><a href="#a-字符串函数" class="headerlink" title="a. 字符串函数"></a>a. 字符串函数</h4><blockquote><p>索引第一个为1，最后一个为-1；切片两边均为闭区间</p></blockquote><table><thead><tr><th align="left">函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td align="left">quote($string)</td><td align="center">添加引号</td></tr><tr><td align="left">unquote($string)</td><td align="center">除去引号</td></tr><tr><td align="left">to-lower-case($string)</td><td align="center">变为小写</td></tr><tr><td align="left">to-upper-case($string)</td><td align="center">变为大写</td></tr><tr><td align="left">str-length($string)</td><td align="center">返回$string的长度(汉字算一个)</td></tr><tr><td align="left">str-index($string，$substring)</td><td align="center">返回$substring在$string的位置</td></tr><tr><td align="left">str-insert($string, $insert, $index)</td><td align="center">在$string的$index处插入$insert</td></tr><tr><td align="left">str-slice($string, $start-at, $end-at）</td><td align="center">截取$string的$start-at和$end-at之间的字符串</td></tr></tbody></table><h4 id="b-数字函数"><a href="#b-数字函数" class="headerlink" title="b. 数字函数"></a>b. 数字函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>percentage($number)</td><td align="center">转换为百分比形式</td></tr><tr><td>round($number)</td><td align="center">四舍五入为整数</td></tr><tr><td>ceil($number)</td><td align="center">数值向上取整</td></tr><tr><td>floor($number)</td><td align="center">数值向下取整</td></tr><tr><td>abs($number)</td><td align="center">获取绝对值</td></tr><tr><td>min($number…)</td><td align="center">获取最小值</td></tr><tr><td>max($number…)</td><td align="center">获取最大值</td></tr><tr><td>random($number?:number)</td><td align="center">不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭）</td></tr></tbody></table><h4 id="c-数组函数"><a href="#c-数组函数" class="headerlink" title="c. 数组函数"></a>c. 数组函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>length($list)</td><td align="center">获取数组长度</td></tr><tr><td>nth($list, n)</td><td align="center">获取指定下标的元素</td></tr><tr><td>set-nth($list, $n, $value)</td><td align="center">向$list的$n处插入$value</td></tr><tr><td>join($list1, $list2, $separator)</td><td align="center">拼接$list1和list2；$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>append($list, $val, $separator)</td><td align="center">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>index($list, $value)</td><td align="center">返回$value值在$list中的索引值</td></tr><tr><td>zip($lists…)</td><td align="center">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td></tr></tbody></table><h4 id="d-映射函数"><a href="#d-映射函数" class="headerlink" title="d. 映射函数"></a>d. 映射函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>map-get($map, $key)</td><td align="center">获取$map中$key对应的$value</td></tr><tr><td>map-merge($map1, $map2)</td><td align="center">合并$map1和$map2，返回一个新$map</td></tr><tr><td>map-remove($map, $key)</td><td align="center">从$map中删除$key，返回一个新$map</td></tr><tr><td>map-keys($map)</td><td align="center">返回$map所有的$key</td></tr><tr><td>map-values($map)</td><td align="center">返回$map所有的$value</td></tr><tr><td>map-has-key($map, $key)</td><td align="center">判断$map中是否存在$key，返回对应的布尔值</td></tr><tr><td>keywords($args)</td><td align="center">返回一个函数的参数，并可以动态修改其值</td></tr></tbody></table><h4 id="e-颜色函数"><a href="#e-颜色函数" class="headerlink" title="e. 颜色函数"></a>e. 颜色函数</h4><ul><li><p><strong>RGB函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>rgb($red, $green, $blue)</td><td align="center">返回一个16进制颜色值</td></tr><tr><td>rgba($red,$green,$blue,$alpha)</td><td align="center">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td></tr><tr><td>red($color)</td><td align="center">从$color中获取其中红色值</td></tr><tr><td>green($color)</td><td align="center">从$color中获取其中绿色值</td></tr><tr><td>blue($color)</td><td align="center">从$color中获取其中蓝色值</td></tr><tr><td>mix($color1,$color2,$weight?)</td><td align="center">按照$weight比例，将$color1和$color2混合为一个新颜色</td></tr></tbody></table></li><li><p><strong>HSL函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th>函数作用</th></tr></thead><tbody><tr><td>hsl($hue,$saturation,$lightness)</td><td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td></tr><tr><td>hsla($hue,$saturation,$lightness,$alpha)</td><td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td></tr><tr><td>saturation($color)</td><td>从一个颜色中获取饱和度（saturation）值</td></tr><tr><td>lightness($color)</td><td>从一个颜色中获取亮度（lightness）值</td></tr><tr><td>adjust-hue($color,$degrees)</td><td>通过改变一个颜色的色相值，创建一个新的颜色</td></tr><tr><td>lighten($color,$amount)</td><td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td></tr><tr><td>darken($color,$amount)</td><td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td></tr><tr><td>hue($color)</td><td>从一个颜色中获取亮度色相（hue）值</td></tr></tbody></table></li><li><p><strong>Opacity函数</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>alpha($color)/opacity($color)</td><td>获取颜色透明度值</td></tr><tr><td>rgba($color,$alpha)</td><td>改变颜色的透明度</td></tr><tr><td>opacify($color, $amount) / fade-in($color, $amount)</td><td>使颜色更不透明</td></tr><tr><td>transparentize($color, $amount) / fade-out($color, $amount)</td><td>使颜色更加透明</td></tr></tbody></table></li></ul><h4 id="f-Introspection函数"><a href="#f-Introspection函数" class="headerlink" title="f. Introspection函数"></a>f. Introspection函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>type-of($value)</td><td align="center">返回$value的类型</td></tr><tr><td>unit($number)</td><td align="center">返回$number的单位</td></tr><tr><td>unitless($number)</td><td align="center">判断$number是否带单位，返回对应的布尔值</td></tr><tr><td>comparable($number1, $number2)</td><td align="center">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td></tr></tbody></table><h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2.自定义函数"></a>2.自定义函数</h3><blockquote><p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p><p>Params: 与Mixin一致</p><p>支持返回值</p></blockquote><p><strong>基本格式：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> fn-name(<span class="variable">$params</span>...) &#123;</span><br><span class="line">    <span class="keyword">@return</span> <span class="variable">$params</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example:</span></span><br><span class="line"><span class="keyword">@function</span> fn-name(<span class="variable">$params</span>...) &#123;</span><br><span class="line">    <span class="keyword">@return</span> nth(<span class="variable">$params</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">fn-name</span>(<span class="number">1px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiled:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="十一、-extend、-Mixin和-function的选择"><a href="#十一、-extend、-Mixin和-function的选择" class="headerlink" title="十一、@extend、@Mixin和@function的选择"></a>十一、@extend、@Mixin和@function的选择</h2><blockquote><p>本部分来自csswizardry的<a href="https://csswizardry.com/2016/02/mixins-better-for-performance/">原文链接</a></p></blockquote><h3 id="1、为何有这个问题"><a href="#1、为何有这个问题" class="headerlink" title="1、为何有这个问题"></a>1、为何有这个问题</h3><blockquote><p>当谈到预处理器时，我被问到的最常见的问题之一是 Mixins 或<code>@extend</code>? 关于这个话题，我坚信你应该避免<code>@extend</code>的一些原因：</p><ol><li>它改变了你的源顺序，这在 CSS 中总是有风险的。</li><li>它会在您的代码中创建笨拙的分组，将不相关的选择器放在一起。</li><li>它非常贪婪，<code>@extend</code>对给定主题的每个实例进行处理，而不仅仅是您真正想要的那个。</li><li>它<a href="https://twitter.com/droob/status/561161783239389185">真的会失控</a>，<a href="https://twitter.com/gaelmetais/status/564109775995437057">真的很快</a>。</li></ol><p><code>@extend</code> 现在被广泛认为是一种反模式，所以它的使用正在逐渐消失，但我们还没有完全到那里。</p><p>昨天我正在与一个客户进行研讨会，并被问及 mixin 与 <code>@extend</code>情况，对此我给出了我通常的回答“永远不要使用” <code>@extend</code>！，作为回报，我被问到但是<code>@extend</code>性能不是更好吗？它生成的代码更少。</p><p>确实<code>@extend</code>（如果使用得当）会产生更少的 CSS，但我的回答是坚决不：<strong>mixin 对性能更好</strong>。</p><p>尽管实际上从未做过任何测试，但我还是很有信心地回答了这个问题。我有信心的原因是我有一个非常可靠的理论：</p><p><strong>因为 gzip 有利于重复，所以如果我们共享完全相同的声明，比如 1000 次，肯定会比我们共享 1000 个独特的类两次获得更好的压缩率。</strong></p><p>你看，当人们谈论 mixin 的性能时，他们通常会考虑文件系统上的文件大小。但是因为我们启用了 gzip（您 <em>确实</em>启用了 gzip，对吧？），我们应该考虑<em>网络上的</em>文件大小</p></blockquote><h3 id="2、操作实践"><a href="#2、操作实践" class="headerlink" title="2、操作实践"></a>2、操作实践</h3><blockquote><ol><li><p>我创建了两个 CSS 文件。</p></li><li><p>每个文件都有 1000 个独特的类，使用 Sass 生成：</p></li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">1000</span> &#123;</span><br><span class="line">  .#&#123;<span class="built_in">unique-id</span>()&#125;-#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>我给了每个类一个唯一的声明，通过使用父选择器简单地重复使用形成名称本身的相同随机字符串，并且我在其两侧放置了一些无意义的字符串：</li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">1000</span> &#123;</span><br><span class="line">  .#&#123;<span class="built_in">unique-id</span>()&#125;-#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;ibf#&#123;&amp;&#125;jaslbw&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>然后我选择了三个简单的声明，它们在所有 1000 个类中都保持不变：</li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol start="5"><li>在一个文件中，我通过 mixin 共享了这些声明：</li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> foo &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.#&#123;<span class="built_in">unique-id</span>()&#125;-#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">@include</span> foo;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;ibf#&#123;&amp;&#125;jaslbw&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>在另一个中，我通过<code>@extend</code>以下方式分享了它们：</li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%foo &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.#&#123;<span class="built_in">unique-id</span>()&#125;-#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %foo;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;ibf#&#123;&amp;&#125;jaslbw&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些测试文件（以及更多）都可以<a href="https://github.com/csswizardry/extend-vs-mixin">在 GitHub 上找到</a>。</p><p>这给我留下了两个由完全独特的类和 1000 个独特声明组成的文件，以及以两种不同方式共享的三个相同声明。</p><p>这些文件大小丝毫不会让您感到惊讶：</p><ul><li><code>mixin.css</code>进来<strong>108K</strong>。</li><li><code>extend.css</code>进来<strong>72K</strong>。</li><li>这导致文件大小的差异为<strong>36K</strong>。</li><li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li></ul><p>这正是我所期待的，混入<em>不</em>产生更多的CSS比<code>@extend</code> 呢。</p><p>但！我们必须记住，我们不应该担心文件系统上的文件大小——我们只关心我们的 gzip 文件的大小。</p><p>我缩小并压缩了这两个文件并得到了我预期的结果：</p><ul><li><code>mixin.css</code>进来<strong>12K</strong>。</li><li><code>extend.css</code>进来<strong>18K</strong>。</li><li>这导致文件大小的差异为<strong>6K</strong>。</li><li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li></ul><p>惊人！我们已经从 mixin 比 using 大 1.5 倍<code>@extend</code>，到 mixin比 using<strong>小 0.3 倍</strong><code>@extend</code>。我的理论似乎是正确的！</p></blockquote><h3 id="3、让事情更现实"><a href="#3、让事情更现实" class="headerlink" title="3、让事情更现实"></a>3、让事情更现实</h3><blockquote><p>我确实觉得测试文件很公平——为类名创建唯一的字符串是为了阻碍压缩，这样我们就可以更准确地测试 gzip 对我们实际主题的影响：共享声明。</p><p>也就是说，测试文件非常不切实际，所以我决定让事情变得更合理一些。</p><p>我从现有项目中获取编译好的 CSS，制作了两份副本，并将我的<code>@import</code>每个测试文件分别放入每个项目中。这意味着我的测试文件被大约 1794 行真实的 CSS 包围着。</p><p>我编译了每个新的测试文件，结果如下：</p><ul><li><code>mixin.css</code>进来<strong>16K</strong>。</li><li><code>extend.css</code>进来了<strong>22K</strong>。</li><li>这导致文件大小的差异为<strong>6K</strong>。</li><li><strong>使用 mixins 比使用<code>@extend</code>.</strong></li></ul><p>绝对数字似乎微不足道（仅 6K），但相对而言，我们可以通过选择使用 mixin 一遍又一遍地重复声明，而不是使用<code>@extend</code>重复少数选择器来实现 27% 的网络节省。</p></blockquote><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p><blockquote><p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p><p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p></blockquote><h2 id="十二、项目中实战"><a href="#十二、项目中实战" class="headerlink" title="十二、项目中实战"></a>十二、项目中实战</h2><h3 id="Ⅰ-Scss混入"><a href="#Ⅰ-Scss混入" class="headerlink" title="Ⅰ-Scss混入"></a>Ⅰ-Scss混入</h3><blockquote><p>在工作中提出的对于同事代码的优化–&gt;使用<code>sass混合指令知识</code>,方便后期维护</p><p><img src="A_SassScript%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%E7%94%A8%E4%BE%8B.png" alt="混合指令用例"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小程序遇到的问题</title>
      <link href="/2022/10/19/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/19/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序遇到的小问题总结"><a href="#微信小程序遇到的小问题总结" class="headerlink" title="微信小程序遇到的小问题总结"></a>微信小程序遇到的小问题总结</h1><h2 id="1-微信小程序怎样使用npm包"><a href="#1-微信小程序怎样使用npm包" class="headerlink" title="1.微信小程序怎样使用npm包"></a>1.微信小程序怎样使用npm包</h2><blockquote><p>1.在项目根目录使用 npm init -y 此时项目中会多出一个package.json文件</p></blockquote><blockquote><p>2.打开微信开发者工具中，本地设置中打开“将JS便以为Es5”</p></blockquote><blockquote><p>3.npm install 包名</p></blockquote><h2 id="2-微信小程序使用pubsub-js"><a href="#2-微信小程序使用pubsub-js" class="headerlink" title="2.微信小程序使用pubsub-js"></a>2.微信小程序使用pubsub-js</h2><blockquote><p>1.什么是pubsub？</p></blockquote><p>PubSubJS is a topic-based publish/subscribe library written in JavaScript.一个利用JavaScript进行消息发布/订阅的库,可以实现组件或者路由之间的通信</p><h2 id="3-微信小程序EventChannel的初次使用"><a href="#3-微信小程序EventChannel的初次使用" class="headerlink" title="3.微信小程序EventChannel的初次使用"></a>3.微信小程序EventChannel的初次使用</h2><h4 id="EventChannel-实现页面之间的通信"><a href="#EventChannel-实现页面之间的通信" class="headerlink" title="EventChannel 实现页面之间的通信"></a>EventChannel 实现页面之间的通信</h4><blockquote><p>此处A为列表页面，B为详情页面</p></blockquote><p>A页面给B页面发送数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">            <span class="comment">// url中只能携带字符串,需要将数据转为JSON字符串,方便接收解析</span></span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;/pages/songDetail/songDetail?song=&quot;</span>+song.<span class="property">id</span>,</span><br><span class="line">            <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 向被打开的页面传递数据</span></span><br><span class="line">                res.<span class="property">eventChannel</span>.<span class="title function_">emit</span>(<span class="string">&#x27;getIdList&#x27;</span>,<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">idList</span>) <span class="comment">//将所有的id传递给详情页</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>B页面接收A页面发送的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventChannel=<span class="variable language_">this</span>.<span class="title function_">getOpenerEventChannel</span>() <span class="comment">//获取事件对象</span></span><br><span class="line">      <span class="comment">//监听getData事件,获取上层页面通过eventChannel传递过来的数据</span></span><br><span class="line">      eventChannel.<span class="title function_">on</span>(<span class="string">&#x27;getIdList&#x27;</span>,<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;<span class="attr">idList</span>:res&#125;)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h2 id="微信小程序实现页面背景音乐的播放和暂停"><a href="#微信小程序实现页面背景音乐的播放和暂停" class="headerlink" title="微信小程序实现页面背景音乐的播放和暂停"></a>微信小程序实现页面背景音乐的播放和暂停</h2><blockquote><p>遇到问题：音乐项目切换音乐时点击页面的暂停按钮无法控制音乐的播放</p></blockquote><blockquote><p>解决方法：在用户点击切换后，把切换后的url和title重新配置给全局音频管理器</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isPlay</span>) &#123;<span class="comment">//播放音乐</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">bgAudioManager</span>.<span class="property">src</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">url</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">bgAudioManager</span>.<span class="property">title</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">name</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">isPlay</span>:<span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">bgAudioManager</span>.<span class="title function_">pause</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//暂停</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">isPlay</span>:<span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">bgAudioManager</span>.<span class="title function_">play</span>()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在使用微信小程序播放音乐时,需要一个全局的音频管理,这时候就可以使用背景音频管理器,获取全局唯一的背景音频管理器</p><blockquote><p>this.bgAudioManager=wx.getBackgroundAudioManager()</p></blockquote><p>通过控制背景音频的实例,监听音乐的 播放和暂停（解决用户操作系统中的暂停而页面不发生暂停的情况）</p><blockquote><p>this.bgAudioManager.onPlay(()=&gt;{}) 监听播放</p></blockquote><blockquote><p>this.bgAudioManager.onPause(()=&gt;{})监听暂停</p></blockquote><blockquote><p>this.bgAudioManager.onStop(()=&gt;{})监听停止</p></blockquote><blockquote><p>this.bgAudioManager.src = this.data.url配置音频url(设置新url会自动播放)</p></blockquote><blockquote><p>this.bgAudioManager.title = this.data.name 配置音频标题(必填项)</p></blockquote><h2 id="自定义组件的数据传递"><a href="#自定义组件的数据传递" class="headerlink" title="自定义组件的数据传递"></a>自定义组件的数据传递</h2><h3 id="1-父组件给子组件传递数据"><a href="#1-父组件给子组件传递数据" class="headerlink" title="1.父组件给子组件传递数据"></a>1.父组件给子组件传递数据</h3><blockquote><p>父组件向子组件传值以属性的形式，子组件以properties接收，并可指定数据类型type以及默认值value。在wxml里可直接以的形式使用，而在js中以this.properties.name获取。</p></blockquote><blockquote><p>父组件：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Peggy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子组件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">properties</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-父组件给子组件传递数据-1"><a href="#1-父组件给子组件传递数据-1" class="headerlink" title="1.父组件给子组件传递数据"></a>1.父组件给子组件传递数据</h3><p>子组件向父组件传递数据使用this.triggerEvent方法，这个方法接受3个参数：</p><blockquote><p>this.triggerEvent(‘myevent’, myEventDetail, myEventOption);</p></blockquote><p>1.myevent为方法名，</p><p>2.myEventDetail是传到组件外的数据，</p><p>3.myEventOption为是否冒泡的选项，有三个参数可以设置：<br>bubbles    默认false 事件是否冒泡,<br>composed 默认false 事件是否可以穿越组件边界,<br>capturePhase 默认false 事件是否拥有捕获阶段。</p><blockquote><p>子组件 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;changeName&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>父组件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">changeName</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">detail</span>)</span><br><span class="line">  <span class="comment">// &#123; age:18 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件监听事件bindchangeName=”changeName”，在changeName方法里有一个event参数，可以从event.detail里拿到组件内部传出来的值</p>]]></content>
      
      
      <categories>
          
          <category> 小问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack5进阶知识</title>
      <link href="/2022/10/18/Webpack%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"/>
      <url>/2022/10/18/Webpack%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Webpack进阶"><a href="#Webpack进阶" class="headerlink" title="Webpack进阶"></a>Webpack进阶</h1><h2 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h2><blockquote><p>开发时我们运行的代码是经过 webpack 编译后的，所有 css 和 js 合并成了一个文件，并且多了其他代码。此时如果代码运行出错那么提示代码错误位置我们是看不懂的。一旦将来开发代码文件很多，那么很难去发现错误出现在哪里。所以我们需要更加准确的错误提示，来帮助我们更好的开发代码。这时候我们就可以使用到<code>sourceMap</code></p></blockquote><blockquote><p>SourceMap简介</p></blockquote><blockquote><p>SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。</p><p>它会生成一个 <code>xxx.map</code> 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。</p></blockquote><blockquote><p>SourceMap使用</p></blockquote><p>1.开发模式：<code>cheap-module-source-map</code></p><blockquote><p>优点：打包编译速度快，只包含行映射</p><p>缺点：没有列映射</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;cheap-module-source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.生产模式：<code>source-map</code></p><blockquote><p>优点：包含行/列映射</p><p>缺点：打包编译速度更慢</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="提升打包构建速度"><a href="#提升打包构建速度" class="headerlink" title="提升打包构建速度"></a>提升打包构建速度</h2><h3 id="HotModuleReplacement"><a href="#HotModuleReplacement" class="headerlink" title="HotModuleReplacement"></a>HotModuleReplacement</h3><blockquote><p>当我们只修改一个模块的代码时，webpack默认会将所有模块重新打包编译，速度很慢，所以我们需要的是，只对那个修改的模块进行打包编译，其他的模块不再打包，这样就能提升速度。</p></blockquote><blockquote><p>HotModuleReplacement简介</p></blockquote><p><code>HotModuleReplacement</code>（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。</p><p>1.基本配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="comment">// 启动服务器域名</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&quot;3000&quot;</span>, <span class="comment">// 启动服务器端口号</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">    <span class="comment">//开启后模块发生改变不会刷新整个页面</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>, <span class="comment">// 开启HMR功能（只能用于开发环境，生产环境不需要）</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时 css 样式经过 style-loader 处理，已经具备 HMR 功能了。 但是 js 还不行。</p><p>2.js配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">// 判断是否支持HMR功能</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&quot;./js/count.js&quot;</span>, <span class="keyword">function</span> (<span class="params">count</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="title function_">count</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&quot;./js/sum.js&quot;</span>, <span class="keyword">function</span> (<span class="params">sum</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样写会很麻烦，所以实际开发我们会使用其他 loader 来解决。比如：<code>vue-loader</code>, <code>react-hot-loader</code>。</p><h3 id="OneOf"><a href="#OneOf" class="headerlink" title="OneOf"></a>OneOf</h3><blockquote><p>打包时每个文件都会经过所有 loader 处理，虽然因为 <code>test</code> 正则原因实际没有处理上，但是都要过一遍。比较慢。（开发和生产模式都可使用）</p></blockquote><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>:[</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">          ...</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="include-exclude"><a href="#include-exclude" class="headerlink" title="include/exclude"></a>include/exclude</h3><blockquote><p>开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。</p></blockquote><blockquote><p>所以我们在对 js 文件处理时，要排除 node_modules 下面的文件。</p></blockquote><p>1.include:包含，只处理某个文件</p><p>2.exclude:排除，除外其他文件都处理</p><p>用法举例：</p><blockquote><p>规则中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">     <span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line">     <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">     <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>扩展中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>, <span class="comment">// 默认值</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><blockquote><p>每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。</p></blockquote><blockquote><p>我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了。</p></blockquote><p>用法举例：</p><blockquote><p>规则中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">          <span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">       &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>, <span class="comment">// 默认值</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="comment">// 缓存目录</span></span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h3 id="Thead"><a href="#Thead" class="headerlink" title="Thead"></a>Thead</h3><blockquote><p>开启多线程同时处理js文件，这样速度就比单进程打包更快</p></blockquote><blockquote><p>多进程打包：开启电脑的多个进程同时干一件事，速度更快。</p></blockquote><p>需要<code>注意</code>：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 <code>600ms</code> 左右开销。</p><blockquote><p>使用：</p></blockquote><p>1.获取CPU核数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">// nodejs核心模块，直接使用</span></span><br><span class="line"><span class="keyword">const</span> os=<span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>)</span><br><span class="line"><span class="comment">// 获取cpu核数</span></span><br><span class="line"><span class="keyword">const</span> threads=os.<span class="title function_">cpus</span>().<span class="property">length</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure><p>3.使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> threads = os.<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line">...</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>:[</span><br><span class="line">          ...</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line">            <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;thread-loader&quot;</span>, <span class="comment">// 开启多进程(需要在babel之前)</span></span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">workers</span>: threads, <span class="comment">// 数量</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>, <span class="comment">// 默认值</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="comment">// 缓存目录</span></span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">      threads, <span class="comment">// 开启多进程</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// css压缩也可以写到optimization.minimizer里面，效果一样的</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="comment">// 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: threads <span class="comment">// 开启多进程</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="减少代码体积"><a href="#减少代码体积" class="headerlink" title="减少代码体积"></a>减少代码体积</h2><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><blockquote><p>简介：Tree Shaking 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。</p></blockquote><blockquote><p>注意：它依赖 <code>ES Module</code>。(且webpack默认开启)</p></blockquote><blockquote><p>开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。这样将整个库都打包进来，体积就太大了。</p></blockquote><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！ 对一些公共方法使用了非常小的辅助代码，比如 _extend。默认情况下会被添加到每一个需要它的文件中。</p><blockquote><p>将这些辅助代码作为一个<code>独立模块</code>，来避免重复引入。</p></blockquote><p><code>@babel/plugin-transform-runtime</code>: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 <code>@babel/plugin-transform-runtime</code> 并且使所有辅助代码从这里引用</p><p>1.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/plugin-transform-runtime -D</span><br></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>:[</span><br><span class="line">          ...</span><br><span class="line">               &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">                  <span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">                  <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>], <span class="comment">// 减少代码体积</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Image-Minimizer"><a href="#Image-Minimizer" class="headerlink" title="Image Minimizer"></a>Image Minimizer</h3><blockquote><p>如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。可以使用<code>image-minimizer-webpack-plugin</code>(注意是静态图片，而不是链接)</p></blockquote><p>1.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i image-minimizer-webpack-plugin imagemin -D</span><br></pre></td></tr></table></figure><p>(1)无损压缩：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D</span><br></pre></td></tr></table></figure><p>(1)有损压缩：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D</span><br></pre></td></tr></table></figure><p>2.配置</p><p>以无损为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ImageMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line">...</span><br><span class="line">  <span class="attr">optimization</span>: &#123;<span class="comment">//开启压缩</span></span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// css压缩也可以写到optimization.minimizer里面，效果一样的</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="comment">// 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: threads, <span class="comment">// 开启多进程</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 压缩图片</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageMinimizerPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">minimizer</span>: &#123;</span><br><span class="line">          <span class="attr">implementation</span>: <span class="title class_">ImageMinimizerPlugin</span>.<span class="property">imageminGenerate</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line">              [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">plugins</span>: [</span><br><span class="line">                    <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;prefixIds&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;sortAttrs&quot;</span>,</span><br><span class="line">                      <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">xmlnsOrder</span>: <span class="string">&quot;alphabetical&quot;</span>,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>完成上述操作后，进行打包会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Error with &#x27;src\images\1.jpeg&#x27;: &#x27;&quot;C:\Users\86176\Desktop\webpack\webpack_code\node_modules\jpegtran-bin\vendor\jpegtran.exe&quot;&#x27;</span><br><span class="line">Error with &#x27;src\images\3.gif&#x27;: spawn C:\Users\86176\Desktop\webpack\webpack_code\node_modules\optipng-bin\vendor\optipng.exe ENOENT</span><br></pre></td></tr></table></figure><p>需要安装两个文件到 node_modules 中才能解决</p><p>1.<code>jpegtran.exe</code><a href="http://jpegclub.org/jpegtran/">jpegtran官网</a></p><p>需要复制到 <code>node_modules\jpegtran-bin\vendor</code> 下面</p><p>1.<code>optipng.exe</code><a href="http://optipng.sourceforge.net/">OptiPNG官网</a></p><p>需要复制到 <code>node_modules\optipng-bin\vendor</code> 下面</p><h2 id="优化代码运行性能"><a href="#优化代码运行性能" class="headerlink" title="优化代码运行性能"></a>优化代码运行性能</h2><h3 id="Code-Split"><a href="#Code-Split" class="headerlink" title="Code Split"></a>Code Split</h3><blockquote><p>打包代码时会将所有 js 文件打包到一个文件中，体积太大了。我们如果只要渲染首页，就应该只加载首页的 js 文件，其他文件不应该加载。</p></blockquote><blockquote><p>所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。</p></blockquote><blockquote><p>代码分割（Code Split）主要做了两件事：</p></blockquote><p>1.分割文件：将打包生成的文件进行分割，生成多个 js 文件。</p><p>2.按需加载：需要哪个文件就加载哪个文件。</p><p>使用：</p><h4 id="1-配置多入口"><a href="#1-配置多入口" class="headerlink" title="1.配置多入口"></a>1.配置多入口</h4><blockquote><p>文件目录</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">|   ├── app.js</span><br><span class="line">|   └── main.js</span><br><span class="line">├── package.json</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>(1)下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>(2)新建文件夹</p><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello main&#x27;</span>)</span><br></pre></td></tr></table></figure><p>(3)配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 单入口</span></span><br><span class="line">  <span class="comment">// entry: &#x27;./src/main.js&#x27;,</span></span><br><span class="line">  <span class="comment">// 多入口</span></span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">main</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&quot;./src/app.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    <span class="comment">// [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span></span><br><span class="line">    <span class="comment">// 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span></span><br><span class="line">    <span class="comment">// chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。</span></span><br><span class="line">    <span class="comment">// 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;js/[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">clear</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时在 dist 目录我们能看到输出了两个 js 文件。总结：配置了几个入口，至少输出几个 js 文件。</p><h4 id="2-提取重复代码"><a href="#2-提取重复代码" class="headerlink" title="2.提取重复代码"></a>2.提取重复代码</h4><p>如果多入口文件中都引用了同一份代码，我们不希望这份代码被打包到两个文件中，导致代码重复，体积更大。</p><p>我们需要提取多入口的重复代码，只打包生成一个 js 文件，其他文件引用它就好</p><p>(1)修改文件</p><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello app&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello main&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>math.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p + c, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(2)修改配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 单入口</span></span><br><span class="line">  <span class="comment">// entry: &#x27;./src/main.js&#x27;,</span></span><br><span class="line">  <span class="comment">// 多入口</span></span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">main</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&quot;./src/app.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    <span class="comment">// [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span></span><br><span class="line">    <span class="comment">// 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span></span><br><span class="line">    <span class="comment">// chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。</span></span><br><span class="line">    <span class="comment">// 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;js/[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有模块都进行分割</span></span><br><span class="line">      <span class="comment">// 以下是默认值</span></span><br><span class="line">      <span class="comment">// minSize: 20000, // 分割代码最小的大小</span></span><br><span class="line">      <span class="comment">// minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0</span></span><br><span class="line">      <span class="comment">// minChunks: 1, // 至少被引用的次数，满足条件才会代码分割</span></span><br><span class="line">      <span class="comment">// maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量</span></span><br><span class="line">      <span class="comment">// maxInitialRequests: 30, // 入口js文件最大并行请求数量</span></span><br><span class="line">      <span class="comment">// enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）</span></span><br><span class="line">      <span class="comment">// cacheGroups: &#123; // 组，哪些模块要打包到一个组</span></span><br><span class="line">      <span class="comment">//   defaultVendors: &#123; // 组名</span></span><br><span class="line">      <span class="comment">//     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span></span><br><span class="line">      <span class="comment">//     priority: -10, // 权重（越大越高）</span></span><br><span class="line">      <span class="comment">//     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">//   default: &#123; // 其他没有写的配置会使用上面的默认值</span></span><br><span class="line">      <span class="comment">//     minChunks: 2, // 这里的minChunks权重更大</span></span><br><span class="line">      <span class="comment">//     priority: -20,</span></span><br><span class="line">      <span class="comment">//     reuseExistingChunk: true,</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      <span class="comment">// 修改配置</span></span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="comment">// 组，哪些模块要打包到一个组</span></span><br><span class="line">        <span class="comment">// defaultVendors: &#123; // 组名</span></span><br><span class="line">        <span class="comment">//   test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span></span><br><span class="line">        <span class="comment">//   priority: -10, // 权重（越大越高）</span></span><br><span class="line">        <span class="comment">//   reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="comment">// 其他没有写的配置会使用上面的默认值</span></span><br><span class="line">          <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 我们定义的文件体积太小了，所以要改打包的最小文件体积</span></span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(3)运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>此时我们会发现生成 3 个 js 文件 </p><h4 id="3-按需加载"><a href="#3-按需加载" class="headerlink" title="3.按需加载"></a>3.按需加载</h4><p>(1).修改文件</p><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello main&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 动态导入 --&gt; 实现按需加载</span></span><br><span class="line">  <span class="comment">// 即使只被引用了一次，也会代码分割</span></span><br><span class="line">  <span class="title function_">import</span>(<span class="string">&quot;./math.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; sum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>public/index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Code Split<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello webpack<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>我们可以发现，一旦通过 import 动态导入语法导入模块，模块就被代码分割，同时也能按需加载了。</p><h4 id="4-单入口"><a href="#4-单入口" class="headerlink" title="4.单入口"></a>4.单入口</h4><p>开发时我们可能是单页面应用（SPA），只有一个入口（单入口）。那么我们需要这样配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 单入口</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 多入口</span></span><br><span class="line">  <span class="comment">// entry: &#123;</span></span><br><span class="line">  <span class="comment">//   main: &quot;./src/main.js&quot;,</span></span><br><span class="line">  <span class="comment">//   app: &quot;./src/app.js&quot;,</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    <span class="comment">// [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span></span><br><span class="line">    <span class="comment">// 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span></span><br><span class="line">    <span class="comment">// chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。</span></span><br><span class="line">    <span class="comment">// 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;js/[name].js&quot;</span>,</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有模块都进行分割</span></span><br><span class="line">      <span class="comment">// 以下是默认值</span></span><br><span class="line">      <span class="comment">// minSize: 20000, // 分割代码最小的大小</span></span><br><span class="line">      <span class="comment">// minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0</span></span><br><span class="line">      <span class="comment">// minChunks: 1, // 至少被引用的次数，满足条件才会代码分割</span></span><br><span class="line">      <span class="comment">// maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量</span></span><br><span class="line">      <span class="comment">// maxInitialRequests: 30, // 入口js文件最大并行请求数量</span></span><br><span class="line">      <span class="comment">// enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）</span></span><br><span class="line">      <span class="comment">// cacheGroups: &#123; // 组，哪些模块要打包到一个组</span></span><br><span class="line">      <span class="comment">//   defaultVendors: &#123; // 组名</span></span><br><span class="line">      <span class="comment">//     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span></span><br><span class="line">      <span class="comment">//     priority: -10, // 权重（越大越高）</span></span><br><span class="line">      <span class="comment">//     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">//   default: &#123; // 其他没有写的配置会使用上面的默认值</span></span><br><span class="line">      <span class="comment">//     minChunks: 2, // 这里的minChunks权重更大</span></span><br><span class="line">      <span class="comment">//     priority: -20,</span></span><br><span class="line">      <span class="comment">//     reuseExistingChunk: true,</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-更新配置"><a href="#5-更新配置" class="headerlink" title="5.更新配置"></a>5.更新配置</h4><p>最终我们会使用单入口+代码分割+动态导入方式来进行配置。更新之前的配置文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ImageMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpu核数</span></span><br><span class="line"><span class="keyword">const</span> threads = os.<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取处理样式的Loaders</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/main.js&quot;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">            <span class="attr">parser</span>: &#123;</span><br><span class="line">              <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">generator</span>: &#123;</span><br><span class="line">              <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">              <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">              <span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line">              <span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line">              <span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line">              <span class="attr">filename</span>: <span class="string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">            <span class="attr">generator</span>: &#123;</span><br><span class="line">              <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line">            <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;thread-loader&quot;</span>, <span class="comment">// 开启多进程</span></span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">workers</span>: threads, <span class="comment">// 数量</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">                  <span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">                  <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>], <span class="comment">// 减少代码体积</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>, <span class="comment">// 默认值</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="comment">// 缓存目录</span></span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">      threads, <span class="comment">// 开启多进程</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// css压缩</span></span><br><span class="line">    <span class="comment">// new CssMinimizerPlugin(),</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// css压缩也可以写到optimization.minimizer里面，效果一样的</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="comment">// 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: threads, <span class="comment">// 开启多进程</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 压缩图片</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageMinimizerPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">minimizer</span>: &#123;</span><br><span class="line">          <span class="attr">implementation</span>: <span class="title class_">ImageMinimizerPlugin</span>.<span class="property">imageminGenerate</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line">              [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">plugins</span>: [</span><br><span class="line">                    <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;prefixIds&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;sortAttrs&quot;</span>,</span><br><span class="line">                      <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">xmlnsOrder</span>: <span class="string">&quot;alphabetical&quot;</span>,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有模块都进行分割</span></span><br><span class="line">      <span class="comment">// 其他内容用默认配置即可</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="给动态导入文件取名"><a href="#给动态导入文件取名" class="headerlink" title="给动态导入文件取名"></a>给动态导入文件取名</h4><blockquote><p>1.修改文件</p></blockquote><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;./js/sum&quot;</span>;</span><br><span class="line"><span class="comment">// 引入资源，Webpack才会对其打包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/iconfont.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./css/index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./less/index.less&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.sass&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./sass/index.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styl/index.styl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码生产模式下会删除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&quot;./js/sum.js&quot;</span>, <span class="keyword">function</span> (<span class="params">sum</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onClick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// eslint会对动态导入语法报错，需要修改eslint配置文件</span></span><br><span class="line">  <span class="comment">// webpackChunkName: &quot;math&quot;：这是webpack动态导入模块命名的方式</span></span><br><span class="line">  <span class="comment">// &quot;math&quot;将来就会作为[name]的值显示。</span></span><br><span class="line">  <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &quot;math&quot; */</span> <span class="string">&quot;./js/math.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">count</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>2.eslint配置</p></blockquote><p>下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-import -D</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 继承 Eslint 规则</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>, <span class="comment">// 启用node中全局变量</span></span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>, <span class="comment">// 启用浏览器中全局变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&quot;import&quot;</span>], <span class="comment">// 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的</span></span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span>, <span class="comment">// 不能使用 var 定义变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>统一命名配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/[name].js&quot;</span>, <span class="comment">// 入口文件打包输出资源命名方式</span></span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&quot;static/js/[name].chunk.js&quot;</span>, <span class="comment">// 动态导入输出资源命名方式</span></span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/media/[name].[hash][ext]&quot;</span>, <span class="comment">// 图片、字体等资源命名方式（注意用hash）</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">   <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">            <span class="attr">parser</span>: &#123;</span><br><span class="line">              <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// generator: &#123;</span></span><br><span class="line">            <span class="comment">//   // 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">            <span class="comment">//   // 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">            <span class="comment">//   // [hash:8]: hash值取8位</span></span><br><span class="line">            <span class="comment">//   // [ext]: 使用之前的文件扩展名</span></span><br><span class="line">            <span class="comment">//   // [query]: 添加之前的query参数</span></span><br><span class="line">            <span class="comment">//   filename: &quot;static/imgs/[hash:8][ext][query]&quot;,</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">            <span class="comment">// generator: &#123;</span></span><br><span class="line">            <span class="comment">//   filename: &quot;static/media/[hash:8][ext][query]&quot;,</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line">            <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;thread-loader&quot;</span>, <span class="comment">// 开启多进程</span></span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">workers</span>: threads, <span class="comment">// 数量</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">                  <span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">                  <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>], <span class="comment">// 减少代码体积</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>, <span class="comment">// 默认值</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="comment">// 缓存目录</span></span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">      threads, <span class="comment">// 开启多进程</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/[name].css&quot;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&quot;static/css/[name].chunk.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// css压缩</span></span><br><span class="line">    <span class="comment">// new CssMinimizerPlugin(),</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// css压缩也可以写到optimization.minimizer里面，效果一样的</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="comment">// 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: threads, <span class="comment">// 开启多进程</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 压缩图片</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageMinimizerPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">minimizer</span>: &#123;</span><br><span class="line">          <span class="attr">implementation</span>: <span class="title class_">ImageMinimizerPlugin</span>.<span class="property">imageminGenerate</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line">              [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">plugins</span>: [</span><br><span class="line">                    <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;prefixIds&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;sortAttrs&quot;</span>,</span><br><span class="line">                      <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">xmlnsOrder</span>: <span class="string">&quot;alphabetical&quot;</span>,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有模块都进行分割</span></span><br><span class="line">      <span class="comment">// 其他内容用默认配置即可</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preload-Prefetch"><a href="#Preload-Prefetch" class="headerlink" title="Preload/Prefetch"></a>Preload/Prefetch</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>我们前面已经做了代码分割，同时会使用 import 动态导入语法来进行代码按需加载（我们也叫懒加载，比如路由懒加载就是这样实现的）。</p><p>但是加载速度还不够好，比如：是用户点击按钮时才加载这个资源的，如果资源体积很大，那么用户会感觉到明显卡顿效果。</p><p>我们想在浏览器空闲时间，加载后续需要使用的资源。我们就需要用上 Preload 或 Prefetch 技术。</p><blockquote><p>1.<code>Preload</code>:告诉浏览器立即加载资源</p></blockquote><blockquote><p>2.<code>Prefetch</code>:告诉浏览器在空闲时才开始加载资源</p></blockquote><p>共同点：都只会加载资源,不会执行，都有缓存</p><p>区别：</p><p>（1）Preload加载优先级高，Prefetch加载优先级低。</p><p>（2）Preload只能加载当前页面需要使用的资源，Prefetch可以加载当前页面资源，也可以加载下一个页面需要使用的资源。</p><p>综上：当前页面优先级高的资源用 Preload 加载。<br>下一个页面需要使用的资源用 Prefetch 加载。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">npm i @vue/preload-webpack-plugin -D</span><br><span class="line">```式配</span><br><span class="line"></span><br><span class="line">2.配置生</span><br><span class="line">```js产模置</span><br><span class="line">const PreloadWebpackPlugin = require(&quot;@vue/preload-webpack-plugin&quot;);</span><br><span class="line">...</span><br><span class="line">module.exports=&#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins:[</span><br><span class="line">    ...</span><br><span class="line">    new PreloadWebpackPlugin(&#123;</span><br><span class="line">      rel: &quot;preload&quot;, // preload兼容性更好</span><br><span class="line">      as: &quot;script&quot;,</span><br><span class="line">      // rel: &#x27;prefetch&#x27; // prefetch兼容性更差</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Network-Cache"><a href="#Network-Cache" class="headerlink" title="Network Cache"></a>Network Cache</h3><h4 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h4><p>开发时我们对静态资源会使用缓存来优化，这样浏览器第二次请求资源就能读取缓存了，速度很快.</p><p>这样的话就会有一个问题, 因为前后输出的文件名是一样的，都叫 main.js，一旦将来发布新版本，因为文件名没有变化导致浏览器会直接读取缓存，不会加载新资源，项目也就没法更新了。</p><p>所以我们从文件名入手，确保更新前后文件名不一样，这样就可以做缓存了。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>fullhash（webpack4 是 hash）<br>每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。</p></blockquote><blockquote><p>chunkhash<br>根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。</p></blockquote><blockquote><p>contenthash<br>根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。</p></blockquote><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">output</span>:&#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="comment">// [contenthash:8]使用contenthash，取8位长度</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/[name].[contenthash:8].js&quot;</span>, <span class="comment">// 入口文件打包输出资源命名方式</span></span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&quot;static/js/[name].[contenthash:8].chunk.js&quot;</span>, <span class="comment">// 动态导入输出资源命名方式</span></span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/media/[name].[hash][ext]&quot;</span>, <span class="comment">// 图片、字体等资源命名方式（注意用hash）</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/[name].[contenthash:8].css&quot;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&quot;static/css/[name].[contenthash:8].chunk.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们修改js文件再重新打包时，js文件的hash值会发生变化(正常),但是main.js的hash值也变化，这会导致main.js的缓存失效。</p><p>(1)原因：</p><p>更新前：math.xxx.js, main.js 引用的 math.xxx.js</p><p>更新后：math.yyy.js, main.js 引用的 math.yyy.js, 文件名发生了变化，间接导致 main.js 也发生了变化</p><p>(2)解决：</p><p>将 hash 值单独保管在一个 runtime 文件中。</p><p>我们最终输出三个文件：main、math、runtime。当 math 文件发送变化，变化的是 math 和 runtime 文件，main 不变。</p><p>runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;eslint-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ImageMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PreloadWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;@vue/preload-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpu核数</span></span><br><span class="line"><span class="keyword">const</span> threads = os.<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取处理样式的Loaders</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="string">&quot;postcss-preset-env&quot;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    preProcessor,</span><br><span class="line">  ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line">    <span class="comment">// [contenthash:8]使用contenthash，取8位长度</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;static/js/[name].[contenthash:8].js&quot;</span>, <span class="comment">// 入口文件打包输出资源命名方式</span></span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&quot;static/js/[name].[contenthash:8].chunk.js&quot;</span>, <span class="comment">// 动态导入输出资源命名方式</span></span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/media/[name].[hash][ext]&quot;</span>, <span class="comment">// 图片、字体等资源命名方式（注意用hash）</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;less-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;sass-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            <span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&quot;stylus-loader&quot;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">            <span class="attr">parser</span>: &#123;</span><br><span class="line">              <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// generator: &#123;</span></span><br><span class="line">            <span class="comment">//   // 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">            <span class="comment">//   // 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">            <span class="comment">//   // [hash:8]: hash值取8位</span></span><br><span class="line">            <span class="comment">//   // [ext]: 使用之前的文件扩展名</span></span><br><span class="line">            <span class="comment">//   // [query]: 添加之前的query参数</span></span><br><span class="line">            <span class="comment">//   filename: &quot;static/imgs/[hash:8][ext][query]&quot;,</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">            <span class="comment">// generator: &#123;</span></span><br><span class="line">            <span class="comment">//   filename: &quot;static/media/[hash:8][ext][query]&quot;,</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line">            <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">            <span class="attr">use</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;thread-loader&quot;</span>, <span class="comment">// 开启多进程</span></span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">workers</span>: threads, <span class="comment">// 数量</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">                  <span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">                  <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>], <span class="comment">// 减少代码体积</span></span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 指定检查文件的根目录</span></span><br><span class="line">      <span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>),</span><br><span class="line">      <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>, <span class="comment">// 默认值</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="comment">// 缓存目录</span></span><br><span class="line">      <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">        __dirname,</span><br><span class="line">        <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span></span><br><span class="line">      ),</span><br><span class="line">      threads, <span class="comment">// 开启多进程</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line">      <span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line">      <span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../public/index.html&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 提取css成单独文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 定义输出文件名和目录</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;static/css/[name].[contenthash:8].css&quot;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&quot;static/css/[name].[contenthash:8].chunk.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// css压缩</span></span><br><span class="line">    <span class="comment">// new CssMinimizerPlugin(),</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PreloadWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">rel</span>: <span class="string">&quot;preload&quot;</span>, <span class="comment">// preload兼容性更好</span></span><br><span class="line">      <span class="attr">as</span>: <span class="string">&quot;script&quot;</span>,</span><br><span class="line">      <span class="comment">// rel: &#x27;prefetch&#x27; // prefetch兼容性更差</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// css压缩也可以写到optimization.minimizer里面，效果一样的</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line">      <span class="comment">// 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: threads, <span class="comment">// 开启多进程</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 压缩图片</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageMinimizerPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">minimizer</span>: &#123;</span><br><span class="line">          <span class="attr">implementation</span>: <span class="title class_">ImageMinimizerPlugin</span>.<span class="property">imageminGenerate</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line">              [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">              [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">plugins</span>: [</span><br><span class="line">                    <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;prefixIds&quot;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">name</span>: <span class="string">&quot;sortAttrs&quot;</span>,</span><br><span class="line">                      <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">xmlnsOrder</span>: <span class="string">&quot;alphabetical&quot;</span>,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有模块都进行分割</span></span><br><span class="line">      <span class="comment">// 其他内容用默认配置即可</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 提取runtime文件</span></span><br><span class="line">    <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="function">(<span class="params">entrypoint</span>) =&gt;</span> <span class="string">`runtime~<span class="subst">$&#123;entrypoint.name&#125;</span>`</span>, <span class="comment">// runtime文件命名规则</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// devServer: &#123;</span></span><br><span class="line">  <span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line">  <span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line">  <span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Core-js"><a href="#Core-js" class="headerlink" title="Core-js"></a>Core-js</h3><h4 id="引出-1"><a href="#引出-1" class="headerlink" title="引出"></a>引出</h4><p>使用 babel 对 js 代码进行了兼容性处理，其中使用@babel/preset-env 智能预设来处理兼容性问题，将 ES6 的一些语法进行编译转换，比如箭头函数、点点点运算符等。但是如果是 async 函数、promise 对象、数组的一些方法（includes）等，它没办法处理。</p><p>此时我们 js 代码仍然存在兼容性问题，一旦遇到低版本浏览器会直接报错。所以我们想要将 js 兼容性问题彻底解决</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>core-js</code> 是专门用来做 ES6 以及以上 API 的 polyfill。</p><p><code>polyfill</code>翻译过来叫做垫片/补丁。就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。</p><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>1.main.js添加代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 添加promise代码</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello promise&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//此时 Eslint 会对 Promise 报错。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/eslint-parser -D</span><br></pre></td></tr></table></figure><p>.eslintrc.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 继承 Eslint 规则</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&quot;@babel/eslint-parser&quot;</span>, <span class="comment">// 支持最新的最终 ECMAScript 标准</span></span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>, <span class="comment">// 启用node中全局变量</span></span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>, <span class="comment">// 启用浏览器中全局变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&quot;import&quot;</span>], <span class="comment">// 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的</span></span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">6</span>, <span class="comment">// es6</span></span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">// es module</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span>, <span class="comment">// 不能使用 var 定义变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>此时观察打包输出的 js 文件，我们发现 Promise 语法并没有编译转换，所以我们需要使用 core-js 来进行 polyfill。</p><p>4.下载<code>core-js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i core-js</span><br></pre></td></tr></table></figure><p>5.手动引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js&quot;</span>;</span><br><span class="line"><span class="comment">// 按需引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/es/promise&quot;</span></span><br></pre></td></tr></table></figure><p>6.自动引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 智能预设：能够编译ES6语法</span></span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      <span class="comment">// 按需加载core-js的polyfill</span></span><br><span class="line">      &#123; <span class="attr">useBuiltIns</span>: <span class="string">&quot;usage&quot;</span>, <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">proposals</span>: <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时就会自动根据我们代码中使用的语法，来按需加载相应的 <code>polyfill</code> 了</p><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><blockquote><p>简介：渐进式网络应用程序(progressive web application - PWA)：是一种可以提供类似于 native app(原生应用程序) 体验的 Web App 的技术。可以给项目提供离线的体验，内部通过 Service Workers 技术实现的。</p></blockquote><p>1.下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i workbox-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产模式</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">WorkboxPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;workbox-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">WorkboxPlugin</span>.<span class="title class_">GenerateSW</span>(&#123;</span><br><span class="line">      <span class="comment">// 这些选项帮助快速启用 ServiceWorkers</span></span><br><span class="line">      <span class="comment">// 不允许遗留任何“旧的” ServiceWorkers</span></span><br><span class="line">      <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">skipWaiting</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.修改main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;serviceWorker&quot;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.<span class="property">serviceWorker</span></span><br><span class="line">      .<span class="title function_">register</span>(<span class="string">&quot;/service-worker.js&quot;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">registration</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SW registered: &quot;</span>, registration);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">registrationError</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SW registration failed: &quot;</span>, registrationError);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果直接通过 VSCode 访问打包后页面，在浏览器控制台会发现 SW registration failed。</p><p>因为我们打开的访问路径是：<code>http://127.0.0.1:5500/dist/index.html</code>。此时页面会去请求<code> service-worker.js</code> 文件，请求路径是：<code>http://127.0.0.1:5500/service-worker.js</code>，这样找不到会 404。</p><p>实际<code> service-worker.js</code> 文件路径是：<code>http://127.0.0.1:5500/dist/service-worker.js</code>。</p><p>4.解决路径问题</p><p>npm i serve -g</p><p>serve dist</p><h2 id="React中的配置分析"><a href="#React中的配置分析" class="headerlink" title="React中的配置分析"></a>React中的配置分析</h2><blockquote><p>1、使用<code>creact-react-app</code>命令创建react项目</p><p>2、运行指令<code>npm run eject</code>:为了更好的<code>学习与观察</code>webpack在react中的配置,运行该命令</p><p>​    该命令会将react脚手架中隐藏的webpack配置暴露出来,而且<code>是不可逆</code>的,并使项目根目录多出两个文件目录:<code>config</code>和<code>scripts</code>,同时<code>package.json</code>的启动命令发生改变</p></blockquote><h3 id="Ⅰ-paths-js文件分析"><a href="#Ⅰ-paths-js文件分析" class="headerlink" title="Ⅰ-paths.js文件分析"></a>Ⅰ-paths.js文件分析</h3><blockquote><p>1、<code>appDirectory</code>:项目根目录</p><p>2、<code>resolveApp</code>:生成绝对路径的方法</p><p>3、<code>publicUrlOrPath</code>:所有资源的公共访问路径 –&gt;参数为<code>/</code> 对应自己当前这个服务器的地址</p><p>4、<code>moduleFileExtensions</code>:定义文件拓展名,在这里定义的拓展名会被react解析到</p><p>5、<code>resolveModule</code>:拿到上面的文件拓展名,检查文件路径是否匹配,存在则解析</p><p>部分代码与注释</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> getPublicUrlOrPath = <span class="built_in">require</span>(<span class="string">&#x27;react-dev-utils/getPublicUrlOrPath&#x27;</span>);</span><br><span class="line"><span class="comment">//项目根目录</span></span><br><span class="line"><span class="keyword">const</span> appDirectory = fs.<span class="title function_">realpathSync</span>(process.<span class="title function_">cwd</span>());</span><br><span class="line"><span class="comment">//生成绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolveApp</span> = relativePath =&gt; path.<span class="title function_">resolve</span>(appDirectory, relativePath);</span><br><span class="line"><span class="comment">// 所有资源的公共访问路径: / --&gt;`/`对应自己当前这个服务器的地址</span></span><br><span class="line"><span class="keyword">const</span> publicUrlOrPath = <span class="title function_">getPublicUrlOrPath</span>(</span><br><span class="line">  process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">   <span class="comment">//当你需要修改路径的时候去`package.json`进行修改,通常是不需要的</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="title function_">resolveApp</span>(<span class="string">&#x27;package.json&#x27;</span>)).<span class="property">homepage</span>,</span><br><span class="line">  process.<span class="property">env</span>.<span class="property">PUBLIC_URL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> buildPath = process.<span class="property">env</span>.<span class="property">BUILD_PATH</span> || <span class="string">&#x27;build&#x27;</span>;</span><br><span class="line"><span class="comment">//定义文件拓展名,在这里定义的拓展名会被react解析到</span></span><br><span class="line"><span class="keyword">const</span> moduleFileExtensions = [</span><br><span class="line">  <span class="string">&#x27;web.mjs&#x27;</span>, <span class="string">&#x27;mjs&#x27;</span>, <span class="string">&#x27;web.js&#x27;</span>,<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web.ts&#x27;</span>,<span class="string">&#x27;ts&#x27;</span>,<span class="string">&#x27;web.tsx&#x27;</span>,<span class="string">&#x27;tsx&#x27;</span>,<span class="string">&#x27;json&#x27;</span>,<span class="string">&#x27;web.jsx&#x27;</span>,<span class="string">&#x27;jsx&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 解析模块的方法:</span></span><br><span class="line"><span class="comment">//拿到上面的文件拓展名,检查文件路径是否匹配,存在则解析</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolveModule</span> = (<span class="params">resolveFn, filePath</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> extension = moduleFileExtensions.<span class="title function_">find</span>(<span class="function"><span class="params">extension</span> =&gt;</span></span><br><span class="line">    fs.<span class="title function_">existsSync</span>(<span class="title function_">resolveFn</span>(<span class="string">`<span class="subst">$&#123;filePath&#125;</span>.<span class="subst">$&#123;extension&#125;</span>`</span>))</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (extension) &#123;<span class="keyword">return</span> <span class="title function_">resolveFn</span>(<span class="string">`<span class="subst">$&#123;filePath&#125;</span>.<span class="subst">$&#123;extension&#125;</span>`</span>); &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolveFn</span>(<span class="string">`<span class="subst">$&#123;filePath&#125;</span>.js`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 暴露出去的路径</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">dotenv</span>: <span class="title function_">resolveApp</span>(<span class="string">&#x27;.env&#x27;</span>),</span><br><span class="line">  <span class="attr">appPath</span>: <span class="title function_">resolveApp</span>(<span class="string">&#x27;.&#x27;</span>),</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将拓展名加至暴露出去的对象上暴露出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">moduleFileExtensions</span> = moduleFileExtensions;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-start-js分析"><a href="#Ⅱ-start-js分析" class="headerlink" title="Ⅱ-start.js分析"></a>Ⅱ-start.js分析</h3><blockquote><p>用来运行<code>开发环境</code>配置</p><p>1、<code>定义环境变量</code>: ① process.env.BABEL_ENV ② process.env.NODE_ENV</p><p>2、<code>useYarn</code>:判断是否使用yarn</p><p>3、<code>config = configFactory(&#39;development&#39;)</code>:引入webpack的开发环境配置</p><p>4、<code>checkBrowsers</code>:检查当前使用的是什么浏览器</p><p>部分代码与注释</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">// 定义环境变量:开发环境</span></span><br><span class="line">process.<span class="property">env</span>.<span class="property">BABEL_ENV</span> = <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line">process.<span class="property">env</span>.<span class="property">NODE_ENV</span> = <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line"><span class="comment">// 捕获异常</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err;&#125;);</span><br><span class="line"><span class="comment">// 加载.env的环境变量:</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;../config/env&#x27;</span>);</span><br><span class="line"><span class="comment">//判断是否使用yarn</span></span><br><span class="line"><span class="keyword">const</span> useYarn = fs.<span class="title function_">existsSync</span>(paths.<span class="property">yarnLockFile</span>);</span><br><span class="line"><span class="comment">// 判断是否包含必要文件:publuc/index.html src/index.js 如果没有退出</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">checkRequiredFiles</span>([paths.<span class="property">appHtml</span>, paths.<span class="property">appIndexJs</span>])) &#123;process.<span class="title function_">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="comment">// 定义默认端口号和域名</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULT_PORT</span> = <span class="built_in">parseInt</span>(process.<span class="property">env</span>.<span class="property">PORT</span>, <span class="number">10</span>) || <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">HOST</span> = process.<span class="property">env</span>.<span class="property">HOST</span> || <span class="string">&#x27;0.0.0.0&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; checkBrowsers &#125; = <span class="built_in">require</span>(<span class="string">&#x27;react-dev-utils/browsersHelper&#x27;</span>);</span><br><span class="line"><span class="comment">//检查当前使用的是什么浏览器</span></span><br><span class="line"><span class="title function_">checkBrowsers</span>(paths.<span class="property">appPath</span>, isInteractive)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 检查端口号:检查当前端口号是否被占用,如果被占用自动加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">choosePort</span>(<span class="variable constant_">HOST</span>, <span class="variable constant_">DEFAULT_PORT</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">//webpack的开发环境配置</span></span><br><span class="line">    <span class="keyword">const</span> config = <span class="title function_">configFactory</span>(<span class="string">&#x27;development&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> protocol = process.<span class="property">env</span>.<span class="property">HTTPS</span> === <span class="string">&#x27;true&#x27;</span> ? <span class="string">&#x27;https&#x27;</span> : <span class="string">&#x27;http&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> appName = <span class="built_in">require</span>(paths.<span class="property">appPackageJson</span>).<span class="property">name</span>;</span><br><span class="line"><span class="comment">//判断是否使用typeScript</span></span><br><span class="line">    <span class="keyword">const</span> useTypeScript = fs.<span class="title function_">existsSync</span>(paths.<span class="property">appTsConfig</span>);</span><br><span class="line">    <span class="keyword">const</span> tscCompileOnError = process.<span class="property">env</span>.<span class="property">TSC_COMPILE_ON_ERROR</span> === <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    <span class="comment">// 创建编译器,将所有配置传进来</span></span><br><span class="line">    <span class="keyword">const</span> compiler = <span class="title function_">createCompiler</span>(&#123; appName,config, devSocket,urls,useYarn,useTypeScript,tscCompileOnError, webpack,&#125;);</span><br><span class="line">    <span class="comment">// 加载package.json中的prost配置</span></span><br><span class="line">    <span class="keyword">const</span> proxySetting = <span class="built_in">require</span>(paths.<span class="property">appPackageJson</span>).<span class="property">proxy</span>;</span><br><span class="line">    <span class="keyword">const</span> proxyConfig = <span class="title function_">prepareProxy</span>( proxySetting, paths.<span class="property">appPublic</span>, paths.<span class="property">publicUrlOrPath</span> );</span><br><span class="line">    <span class="comment">// 创建devServer的配置</span></span><br><span class="line">    <span class="keyword">const</span> serverConfig = <span class="title function_">createDevServerConfig</span>(</span><br><span class="line">      proxyConfig,</span><br><span class="line">      urls.<span class="property">lanUrlForConfig</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> devServer = <span class="keyword">new</span> <span class="title class_">WebpackDevServer</span>(compiler, serverConfig);</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    devServer.<span class="title function_">listen</span>(port, <span class="variable constant_">HOST</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;<span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err); &#125;</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-build-js"><a href="#Ⅲ-build-js" class="headerlink" title="Ⅲ-build.js"></a>Ⅲ-build.js</h3><blockquote><p>大致与开发环境相同,但是运行<code>生产环境</code>的</p></blockquote><h3 id="Ⅳ-webpack-config-js"><a href="#Ⅳ-webpack-config-js" class="headerlink" title="Ⅳ-webpack.config.js"></a>Ⅳ-webpack.config.js</h3><blockquote><p>用来定义开发环境与生产环境的配置</p><p>部分代码与注释</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否生成map文件</span></span><br><span class="line"><span class="comment">// cross-env修改</span></span><br><span class="line"><span class="keyword">const</span> shouldUseSourceMap = process.<span class="property">env</span>.<span class="property">GENERATE_SOURCEMAP</span> !== <span class="string">&quot;false&quot;</span>;</span><br><span class="line"><span class="comment">// 是否内联runtime文件</span></span><br><span class="line"><span class="keyword">const</span> shouldInlineRuntimeChunk = process.<span class="property">env</span>.<span class="property">INLINE_RUNTIME_CHUNK</span> !== <span class="string">&quot;false&quot;</span>;</span><br><span class="line"><span class="comment">// 最小转化base64的图片大小</span></span><br><span class="line"><span class="keyword">const</span> imageInlineSizeLimit = <span class="built_in">parseInt</span>(process.<span class="property">env</span>.<span class="property">IMAGE_INLINE_SIZE_LIMIT</span> || <span class="string">&quot;10000&quot;</span>);</span><br><span class="line"><span class="comment">// 样式文件正则</span></span><br><span class="line"><span class="keyword">const</span> cssRegex = <span class="regexp">/\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line"><span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line"><span class="comment">// 生成最终webpack开发或生产环境配置的函数</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">webpackEnv</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取环境变量的方法</span></span><br><span class="line"><span class="comment">// 加载.env文件的环境变量，REACT_APP_开头</span></span><br><span class="line"><span class="keyword">const</span> env = <span class="title function_">getClientEnvironment</span>(paths.<span class="property">publicUrlOrPath</span>.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 获取处理样式文件loader的函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">cssOptions, preProcessor</span>) =&gt; &#123;&#125;</span><br><span class="line">   <span class="comment">// webpack配置对象</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">mode</span>: isEnvProduction ? <span class="string">&quot;production&quot;</span> : isEnvDevelopment &amp;&amp; <span class="string">&quot;development&quot;</span>,</span><br><span class="line"><span class="comment">// 如果该变量为true(生产环境),则代码出错终止打包</span></span><br><span class="line"><span class="attr">bail</span>: isEnvProduction,</span><br><span class="line"><span class="attr">devtool</span>: isEnvProduction? shouldUseSourceMap? <span class="string">&quot;source-map&quot;</span> <span class="comment">// 生产环境</span></span><br><span class="line">: <span class="attr">false</span>: isEnvDevelopment &amp;&amp; <span class="string">&quot;cheap-module-source-map&quot;</span>, <span class="comment">// 开发环境</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加 /* filename */ 注释到输出的文件中</span></span><br><span class="line"><span class="attr">pathinfo</span>: isEnvDevelopment,</span><br><span class="line">    <span class="comment">// 默认 / ，可以通过package.json.homepage.</span></span><br><span class="line"><span class="attr">publicPath</span>: paths.<span class="property">publicUrlOrPath</span>,</span><br><span class="line">         <span class="comment">// 启用压缩</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line"><span class="attr">minimize</span>: isEnvProduction,</span><br><span class="line"><span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;&#125;)]<span class="comment">// 压缩js</span></span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 是否内联runtime文件：少发一个请求</span></span><br><span class="line">isEnvProduction &amp;&amp;</span><br><span class="line">shouldInlineRuntimeChunk &amp;&amp;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InlineChunkHtmlPlugin</span>(<span class="title class_">HtmlWebpackPlugin</span>, [<span class="regexp">/runtime-.+[.]js/</span>]),</span><br><span class="line"><span class="comment">// 解析index.html中 &amp;PULBLIC_URL%</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InterpolateHtmlPlugin</span>(<span class="title class_">HtmlWebpackPlugin</span>, env.<span class="property">raw</span>),</span><br><span class="line"><span class="comment">// 给ModuleNotFound更好提示</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ModuleNotFoundPlugin</span>(paths.<span class="property">appPath</span>),</span><br><span class="line"><span class="comment">// 定义环境变量</span></span><br><span class="line"><span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(env.<span class="property">stringified</span>),</span><br><span class="line"><span class="comment">// 开发环境下：HMR功能</span></span><br><span class="line">isEnvDevelopment &amp;&amp; <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>(),</span><br><span class="line"><span class="comment">// 文件路径：严格区分大小写</span></span><br><span class="line">isEnvDevelopment &amp;&amp; <span class="keyword">new</span> <span class="title class_">CaseSensitivePathsPlugin</span>(),</span><br><span class="line"><span class="comment">// 监视node_modules，一旦发生变化可以重启dev server</span></span><br><span class="line"><span class="comment">// See https://github.com/facebook/create-react-app/issues/186</span></span><br><span class="line">isEnvDevelopment &amp;&amp;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WatchMissingNodeModulesPlugin</span>(paths.<span class="property">appNodeModules</span>),</span><br><span class="line"><span class="comment">// 提取css成单独文件</span></span><br><span class="line">isEnvProduction &amp;&amp;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Vue中的配置分析"><a href="#Vue中的配置分析" class="headerlink" title="Vue中的配置分析"></a>Vue中的配置分析</h1><blockquote><p>将基于脚手架4.x版本的vue2.x配置进行分析,大致内容与react无太大区别</p><p>1、卸载老版本vuecli（1.x， 2.x）:<code>npm uninstall vue-cli -g</code>或者<code>yarn global remove vue-cli</code></p><p>2、安装最新的vuecli:<code>npm install -g @vue/cli</code></p><p>3、<code>vue create project-name</code>,选择创建vue2.x,vue2与3版本的weback配置差不多</p><p>4、vue并没有提供将webpack配置直接暴露出来的命令,但是提供了另外一种方法让我们能审查vue里面的配置,通过指令将单独的配置单独打包成单独的文件</p><p>​    Ⅰ-<code>vue inspect --mode=development &gt; webpack.dev.js</code> :将webpack的开发环境单独打包</p><p>​    Ⅱ-<code>vue inspect --mode=production &gt; webpack.prod.js</code> :将webpack的生产环境单独打包</p><p>​    Ⅲ-生成后的文件会报错,想要取消报错,在最前面用<code>module.exports=</code>将其暴露出去,就不会报错了</p></blockquote><h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><h3 id="Ⅰ-编写一个简单的loader"><a href="#Ⅰ-编写一个简单的loader" class="headerlink" title="Ⅰ-编写一个简单的loader"></a>Ⅰ-编写一个简单的loader</h3><blockquote><p>loader本质上是一种函数,此处创建一个js编写loader</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loader1.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(content,<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、如不配置loader解析规则,默认路径是<code>node_modules</code>,所以平时使用<code>style-loader</code>等都不用加路径</p><p>webpack.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;loader1&#x27;</span>,<span class="comment">//当配置了loader解析规则后写法</span></span><br><span class="line">        <span class="comment">// loader:path.resolve(__dirname,&#x27;loaders&#x27;,&#x27;loader1&#x27;) //不写resolveLoader配置的写法</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置loader解析规则,默认路径是`node_modules`</span></span><br><span class="line">  <span class="attr">resolveLoader</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [</span><br><span class="line">      <span class="string">&#x27;node_modules&#x27;</span>,</span><br><span class="line">      path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;loaders&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-loader的执行顺序"><a href="#Ⅱ-loader的执行顺序" class="headerlink" title="Ⅱ-loader的执行顺序"></a>Ⅱ-loader的执行顺序</h3><blockquote><p>1、loader是从上往下编译,编译结束后运行的顺序是<code>从下往上,从右往左 </code>执行</p><p>2、当你有写loader想要先行运行的话,可以加在<code>pitch</code>方法上,这样在编译时就会调用,且<code>从上往下</code>执行</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111111</span>,<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">pitch</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//编译时从上往下调用</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pitch 111&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-同步-amp-异步loader"><a href="#Ⅲ-同步-amp-异步loader" class="headerlink" title="Ⅲ-同步&amp;异步loader"></a>Ⅲ-同步&amp;异步loader</h3><blockquote><p>1、<code>this.callback()</code>:同步的方法  –&gt;可以替代<code>return</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111111</span>,<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content, map, meta);</span><br><span class="line"><span class="comment">//是否有错误,需要传递的内容(处理后的内容) ,可选参数,可选参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、<code>this.async()</code>:异步的方法</p><p>​    使用<code>this.async()</code>方法会使整个loader停住,只有当你再次调用<code>callback</code>方法才会继续执行,整体性能会好过同步,<code>推荐使用</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步loader</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">  <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>();</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, content);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Ⅳ-获取-amp-校验loader的options"><a href="#Ⅳ-获取-amp-校验loader的options" class="headerlink" title="Ⅳ-获取&amp;校验loader的options"></a>Ⅳ-获取&amp;校验loader的options</h3><blockquote><p>1、需要下载依赖:<code>npm i loader-utils -D</code></p><p>2、需要下载依赖:<code>schema-utils</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js传入</span></span><br><span class="line">&#123;<span class="attr">loader</span>: <span class="string">&#x27;loader3&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span> <span class="comment">//当校验文件追加属性调为false,将会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//loader3.js</span></span><br><span class="line"><span class="comment">// loader本质上是一个函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; getOptions &#125; = <span class="built_in">require</span>(<span class="string">&#x27;loader-utils&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; validate &#125; = <span class="built_in">require</span>(<span class="string">&#x27;schema-utils&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="built_in">require</span>(<span class="string">&#x27;./schema&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取options</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>, options);</span><br><span class="line">  <span class="comment">// 校验options是否合法</span></span><br><span class="line">  <span class="title function_">validate</span>(schema, options, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;loader3&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>校验文件:定义校验规则</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span><span class="comment">//指定options的类型</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//定义options里面有什么属性</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">//定义有name类型</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;名称～&quot;</span><span class="comment">//定义描述,可以随便写</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="comment">//代表是否可以运行追加其他属性</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Ⅴ-自定义babel-loader"><a href="#Ⅴ-自定义babel-loader" class="headerlink" title="Ⅴ-自定义babel-loader"></a>Ⅴ-自定义babel-loader</h3><blockquote><p>自定义babel-loader,并不是工作中的babel配置</p></blockquote><blockquote><p>webpack.config.js配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">loader</span>:<span class="string">&#x27;babelLoader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>:&#123; <span class="attr">presets</span>:[<span class="string">&#x27;@babel/preset-env&#x27;</span>] &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置loader解析规则,默认路径是`node_modules`</span></span><br><span class="line">  <span class="attr">resolveLoader</span>: &#123;  <span class="attr">modules</span>: [ <span class="string">&#x27;node_modules&#x27;</span>,path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;loaders&#x27;</span>)]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>babelLoader.js  –&gt;中间大写是防止与自带的babelloader冲突</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125; = <span class="built_in">require</span>(<span class="string">&#x27;loader-utils&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; validate &#125; = <span class="built_in">require</span>(<span class="string">&#x27;schema-utils&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> babelSchema = <span class="built_in">require</span>(<span class="string">&#x27;./babelSchema.json&#x27;</span>);</span><br><span class="line"><span class="comment">//babel.transfrom用来编译代码的方法,是一个普通异步方法</span></span><br><span class="line"><span class="comment">//util.promisify会将普通异步方法转换成基于promise的异步方法</span></span><br><span class="line"><span class="keyword">const</span> transform=util.<span class="title function_">promisify</span>(babel.<span class="property">transform</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">  <span class="comment">//获取loader的options配置</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>) || &#123;&#125;;</span><br><span class="line">  <span class="comment">//校验babel的options的配置</span></span><br><span class="line">  <span class="title function_">validate</span>(babelSchema,options,&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Babel Loader&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//创建异步</span></span><br><span class="line">  <span class="keyword">const</span> callback=<span class="variable language_">this</span>.<span class="title function_">async</span>();</span><br><span class="line">  <span class="comment">//使用babel编译代码</span></span><br><span class="line">  <span class="title function_">transform</span>(content,options)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;code,map&#125;</span>)=&gt;</span><span class="title function_">callback</span>(<span class="literal">null</span>,code,map,meta))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>)=&gt;</span><span class="title function_">callback</span>(e))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>校验文件:babelSchema.json</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;array&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;addtionalProperties&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h1><h3 id="Ⅰ-tabaple介绍与使用"><a href="#Ⅰ-tabaple介绍与使用" class="headerlink" title="Ⅰ-tabaple介绍与使用"></a>Ⅰ-tabaple介绍与使用</h3><blockquote><p>安装tapable：npm install tapable -D</p><p>初始化hooks容器 2.1 同步hooks，任务会依次执行:SyncHook、SyncBailHook 2.2 异步hooks，异步并行：AsyncParallelHook，异步串行：AsyncSeriesHook</p><p>往hooks容器中注册事件/添加回调函数</p><p>触发hooks</p><p>启动文件：node tapable.test.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span>, <span class="title class_">SyncBailHook</span>, <span class="title class_">AsyncParallelHook</span>, <span class="title class_">AsyncSeriesHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;tapable&#x27;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lesson</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化hooks容器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="comment">// 同步hooks，任务回依次执行</span></span><br><span class="line">      <span class="comment">// go: new SyncHook([&#x27;address&#x27;])</span></span><br><span class="line">      <span class="comment">// SyncBailHook：一旦有返回值就会退出～</span></span><br><span class="line">      <span class="attr">go</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>([<span class="string">&#x27;address&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 异步hooks</span></span><br><span class="line">      <span class="comment">// AsyncParallelHook：异步并行</span></span><br><span class="line">      <span class="comment">// leave: new AsyncParallelHook([&#x27;name&#x27;, &#x27;age&#x27;]),</span></span><br><span class="line">      <span class="comment">// AsyncSeriesHook: 异步串行</span></span><br><span class="line">      <span class="attr">leave</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">tap</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 往hooks容器中注册事件/添加回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">go</span>.<span class="title function_">tap</span>(<span class="string">&#x27;class0318&#x27;</span>, <span class="function">(<span class="params">address</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class0318&#x27;</span>, address);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">go</span>.<span class="title function_">tap</span>(<span class="string">&#x27;class0410&#x27;</span>, <span class="function">(<span class="params">address</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class0410&#x27;</span>, address);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">leave</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;class0510&#x27;</span>, <span class="function">(<span class="params">name, age, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class0510&#x27;</span>, name, age);</span><br><span class="line">        <span class="title function_">cb</span>();</span><br><span class="line">      &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">leave</span>.<span class="title function_">tapPromise</span>(<span class="string">&#x27;class0610&#x27;</span>, <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class0610&#x27;</span>, name, age);</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 触发hooks</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">go</span>.<span class="title function_">call</span>(<span class="string">&#x27;c318&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">leave</span>.<span class="title function_">callAsync</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="number">18</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 代表所有leave容器中的函数触发完了，才触发</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end~~~&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> l = <span class="keyword">new</span> <span class="title class_">Lesson</span>();</span><br><span class="line">l.<span class="title function_">tap</span>();</span><br><span class="line">l.<span class="title function_">start</span>();</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-compiler钩子"><a href="#Ⅱ-compiler钩子" class="headerlink" title="Ⅱ- compiler钩子"></a>Ⅱ- compiler钩子</h3><blockquote><p>工作方式：异步串行执行，因此下面代码输出顺序如下： 1.1 emit.tap 111 1.2 1秒后输出 emit.tapAsync 111 1.3 1秒后输出 emit.tapPromise 111 1.4 afterEmit.tap 111 1.5 done.tap 111</p><p>tapAsync和tapPromise表示异步</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin1</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">complier</span>) &#123;</span><br><span class="line"></span><br><span class="line">    complier.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;Plugin1&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;emit.tap 111&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    complier.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;Plugin1&#x27;</span>, <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;emit.tapAsync 111&#x27;</span>);</span><br><span class="line">        <span class="title function_">cb</span>();</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    complier.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapPromise</span>(<span class="string">&#x27;Plugin1&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;emit.tapPromise 111&#x27;</span>);</span><br><span class="line">          <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    complier.<span class="property">hooks</span>.<span class="property">afterEmit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;Plugin1&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEmit.tap 111&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    complier.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&#x27;Plugin1&#x27;</span>, <span class="function">(<span class="params">stats</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done.tap 111&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Plugin1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>此部分剩余部分,暂时跳过,并无太多实践,以后再来补足</p></blockquote><h1 id="自定义webpack"><a href="#自定义webpack" class="headerlink" title="自定义webpack"></a>自定义webpack</h1><h3 id="Ⅰ-webpack执行流程"><a href="#Ⅰ-webpack执行流程" class="headerlink" title="Ⅰ-webpack执行流程"></a>Ⅰ-webpack执行流程</h3><blockquote><p>1、初始化 Compiler：webpack(config) 得到 Compiler 对象</p><p>2、开始编译：调用 Compiler 对象 run 方法开始执行编译</p><p>3、确定入口：根据配置中的 entry 找出所有的入口文件。</p><p>4、编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，递归直到所有模块被加载进来</p><p>5、完成模块编译： 在经过第 4 步使用 Loader 编译完所有模块后，得到了每个模块被编译后的最终内容以及它们之间的依赖关系。</p><p>6、输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表。（注意：这步是可以修改输出内容的最后机会）</p><p>7、输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</p></blockquote><h3 id="Ⅱ-准备工作"><a href="#Ⅱ-准备工作" class="headerlink" title="Ⅱ-准备工作"></a>Ⅱ-准备工作</h3><blockquote><p>1、创建文件夹myWebpack</p><p>2、创建src–&gt;(add.js / count.js / index.js)，写入对应的js代码</p><p>3、创建config–&gt;webpack.config.js写入webpack基础配置（entry和output）</p><p>4、创建lib文件夹，里面写webpack的主要配置</p><p>5、创建script–&gt;build.js（将lib文件夹下面的myWebpack核心代码和config文件下的webpack基础配置引入并调用run()函数开始打包）</p><p>6、为了方便启动，控制台通过输入命令 <code>npm init -y</code>拉取出package.json文件，修改文件中scripts部分为<code>&quot;build&quot;: &quot;node ./script/build.js&quot;</code>表示通过在终端输入命令<code>npm run build</code>时会运行/script/build.js文</p><p>7、如果需要断点调试:在scripts中添加<code>&quot;debug&quot;: &quot;node --inspect-brk ./script/build.js&quot;</code>表示通过在终端输入命令<code>npm run debug</code>时会调试/script/build.js文件中的代码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise学习笔记</title>
      <link href="/2022/10/17/Promise%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/17/Promise%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Promise的理解与使用"><a href="#一、Promise的理解与使用" class="headerlink" title="一、Promise的理解与使用"></a>一、Promise的理解与使用</h1><blockquote><p>1、概念:</p><p>​    Promise是<code>异步编程的一种解决方案</code>，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>通俗讲，<code>Promise是一个许诺、承诺</code>,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。</p><ul><li>Pending  正在做。。。</li><li>Resolved 完成这个承诺</li><li>Rejected 这个承诺没有完成，失败了</li></ul><p>​    Promise 用来预定一个不一定能完成的任务，要么成功，要么失败</p><p>​    在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果</p><p>Promise 是异步编程的一种解决方案，<code>主要用来解决回调地狱的问题，可以有效的减少回调嵌套</code>。真正解决需要<code>配合async/await</code></p><p>2、特点:</p><p>​    (1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p><p>​    (2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p><p>3、缺点:</p><p>​    (1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。</p><p>​    (2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p><p>​    (3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p></blockquote><hr><h2 id="1、Promise是什么"><a href="#1、Promise是什么" class="headerlink" title="1、Promise是什么?"></a>1、Promise是什么?</h2><h4 id="Ⅰ-理解"><a href="#Ⅰ-理解" class="headerlink" title="Ⅰ-理解"></a>Ⅰ-理解</h4><blockquote><ol><li>抽象表达:  </li></ol><p>​    1) Promise 是一门新的技术(ES6 规范) </p><p>​    2)Promise 是 JS 中<code>进行异步编程</code>的新解决方案 备注：旧方案是单纯使用回调函数</p><ol start="2"><li>具体表达: </li></ol><ol><li><p>从语法上来说: Promise 是一个<code>构造函数</code></p></li><li><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p></li></ol></blockquote><h4 id="Ⅱ-promise-的状态"><a href="#Ⅱ-promise-的状态" class="headerlink" title="Ⅱ-promise 的状态"></a>Ⅱ-promise 的状态</h4><h5 id="a-promise-的状态"><a href="#a-promise-的状态" class="headerlink" title="a) promise 的状态"></a>a) promise 的状态</h5><blockquote><p>实例对象中的一个属性 『PromiseState』</p><ul><li>pending  未决定的</li><li>resolved / fullfilled  成功</li><li>rejected  失败</li></ul></blockquote><h5 id="b-promise-的状态改变"><a href="#b-promise-的状态改变" class="headerlink" title="b) promise 的状态改变"></a>b) promise 的状态改变</h5><blockquote><ol><li><p>pending 变为 resolved </p></li><li><p>pending 变为 rejected</p></li></ol><p>  说明: <code>只有这 2 种</code>, 且一个 promise 对象<code>只能改变一次</code> 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p></blockquote><h4 id="Ⅲ-promise的基本流程"><a href="#Ⅲ-promise的基本流程" class="headerlink" title="Ⅲ-promise的基本流程"></a>Ⅲ-promise的基本流程</h4><blockquote><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_promise%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Promise系统学习_promise工作流程"></p></blockquote><h4 id="Ⅳ-promise的基本使用"><a href="#Ⅳ-promise的基本使用" class="headerlink" title="Ⅳ-promise的基本使用"></a>Ⅳ-promise的基本使用</h4><h6 id="1-使用-promise-封装基于定时器的异步"><a href="#1-使用-promise-封装基于定时器的异步" class="headerlink" title="1.使用 promise 封装基于定时器的异步"></a>1.使用 promise 封装基于定时器的异步</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doDelay</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 在执行器函数中启动异步任务</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动异步任务&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延迟任务开始执行...&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 假设: 时间为奇数代表成功, 为偶数代表失败</span></span><br><span class="line">        <span class="keyword">if</span> (time % <span class="number">2</span> === <span class="number">1</span>) &#123; <span class="comment">// 成功了</span></span><br><span class="line">          <span class="comment">// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value</span></span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&#x27;成功的数据 &#x27;</span> + time)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了</span></span><br><span class="line">          <span class="comment">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&#x27;失败的数据 &#x27;</span> + time)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">doDelay</span>(<span class="number">2000</span>)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="comment">// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason</span></span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;,</span><br><span class="line">  ) &lt;</span><br><span class="line">  /script&gt;</span><br></pre></td></tr></table></figure><h6 id="2-使用-promise-封装-ajax-异步请求"><a href="#2-使用-promise-封装-ajax-异步请求" class="headerlink" title="2.使用 promise 封装 ajax 异步请求"></a>2.使用 promise 封装 ajax 异步请求</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  可复用的发 ajax 请求的函数: xhr + promise</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">promiseAjax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          status,</span><br><span class="line">          response</span><br><span class="line">        &#125; = xhr</span><br><span class="line">        <span class="comment">// 请求成功, 调用 resolve(value)</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(response))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求失败, 调用 reject(reason)</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败: status: &#x27;</span> + status))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">      xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="title function_">promiseAjax</span>(<span class="string">&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid</span></span><br><span class="line"><span class="string">    eo &#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;显示成功数据&#x27;</span>, data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ) &lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="3-fs模块使用Promise"><a href="#3-fs模块使用Promise" class="headerlink" title="3.fs模块使用Promise"></a>3.fs模块使用Promise</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数 形式----------------------------------------------------</span></span><br><span class="line"> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 如果出错 则抛出错误</span></span><br><span class="line">     <span class="keyword">if</span>(err)  <span class="keyword">throw</span> err;</span><br><span class="line">     <span class="comment">//输出文件内容</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise 形式-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装一个函数 mineReadFile 读取文件内容</span></span><br><span class="line"><span class="comment"> * 参数:  path  文件路径</span></span><br><span class="line"><span class="comment"> * 返回:  promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mineReadFile</span>(<span class="params">path</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span>(err) <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//输出文件内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-异常穿透"><a href="#4-异常穿透" class="headerlink" title="4.异常穿透"></a>4.异常穿透</h6><blockquote><p>可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p><p>在每个.then()中我可以将数据再次传出给下一个then()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./11.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&quot;2222222&quot;</span>))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是catch的&quot;</span>))</span><br></pre></td></tr></table></figure><h6 id="5-util-promisify方法"><a href="#5-util-promisify方法" class="headerlink" title="5.util.promisify方法"></a>5.<code>util.promisify方法</code></h6><blockquote><p>可以将函数直接变成promise的封装方式,不用再去手动封装</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入 util 模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="2、为什么要用Promise"><a href="#2、为什么要用Promise" class="headerlink" title="2、为什么要用Promise?"></a>2、为什么要用Promise?</h2><h3 id="Ⅰ-指定回调函数的方式更加灵活"><a href="#Ⅰ-指定回调函数的方式更加灵活" class="headerlink" title="Ⅰ-指定回调函数的方式更加灵活"></a>Ⅰ-指定回调函数的方式更加灵活</h3><blockquote><ol><li>旧的: 必须在启动异步任务前指定 </li><li>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个)</li></ol></blockquote><h3 id="Ⅱ-支持链式调用-可以解决回调地狱问题"><a href="#Ⅱ-支持链式调用-可以解决回调地狱问题" class="headerlink" title="Ⅱ-支持链式调用, 可以解决回调地狱问题"></a>Ⅱ-支持链式调用, 可以解决回调地狱问题</h3><h5 id="1、什么是回调地狱"><a href="#1、什么是回调地狱" class="headerlink" title="1、什么是回调地狱"></a>1、什么是回调地狱</h5><blockquote><p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="Promise系统学习_回调地狱"></p></blockquote><h5 id="2、回调地狱的缺点"><a href="#2、回调地狱的缺点" class="headerlink" title="2、回调地狱的缺点?"></a>2、回调地狱的缺点?</h5><blockquote><p>不便于阅读 不便于异常处理</p></blockquote><h5 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案?"></a>3、解决方案?</h5><blockquote><p>promise <code>链式调用</code>,</p><p>用来解决回调地狱问题，但是<code>只是简单的改变格式</code>，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步</p></blockquote><h5 id="4、终极解决方案"><a href="#4、终极解决方案" class="headerlink" title="4、终极解决方案?"></a>4、终极解决方案?</h5><blockquote><p>promise +async/await</p></blockquote><hr><h2 id="3、Promise中的常用-API-概述"><a href="#3、Promise中的常用-API-概述" class="headerlink" title="3、Promise中的常用 API 概述"></a>3、Promise中的常用 API 概述</h2><blockquote><p>此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的  <strong>Promise方法的具体使用</strong> 描述</p></blockquote><h4 id="Ⅰ-Promise-构造函数-Promise-excutor"><a href="#Ⅰ-Promise-构造函数-Promise-excutor" class="headerlink" title="Ⅰ- Promise 构造函数: Promise (excutor) {}"></a>Ⅰ- Promise 构造函数: Promise (excutor) {}</h4><blockquote><p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p><p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} </p><p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} </p><p>说明: executor 会在 Promise 内部立即<code>同步调用</code>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p></blockquote><h4 id="Ⅱ-Promise-prototype-then-方法-onResolved-onRejected-gt"><a href="#Ⅱ-Promise-prototype-then-方法-onResolved-onRejected-gt" class="headerlink" title="Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}"></a>Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</h4><blockquote><p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {} </p><p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} </p><p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p></blockquote><h4 id="Ⅲ-Promise-prototype-catch-方法-onRejected-gt"><a href="#Ⅲ-Promise-prototype-catch-方法-onRejected-gt" class="headerlink" title="Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt; {}"></a>Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt; {}</h4><blockquote><p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p><p>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中    </p></blockquote><h4 id="Ⅳ-Promise-resolve-方法-value-gt"><a href="#Ⅳ-Promise-resolve-方法-value-gt" class="headerlink" title="Ⅳ-Promise.resolve 方法: (value) =&gt; {}"></a>Ⅳ-Promise.resolve 方法: (value) =&gt; {}</h4><blockquote><p>(1) value: 成功的数据或 promise 对象 </p><p>说明: 返回一个成功/失败的 promise 对象,直接改变promise状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;));      </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅴ-Promise-reject-方法-reason-gt"><a href="#Ⅴ-Promise-reject-方法-reason-gt" class="headerlink" title="Ⅴ-Promise.reject 方法: (reason) =&gt; {}"></a>Ⅴ-Promise.reject 方法: (reason) =&gt; {}</h4><blockquote><p>(1) reason: 失败的原因 </p><p>说明: 返回一个失败的 promise 对象,直接改变promise状态,<code>代码示例同上</code></p></blockquote><h4 id="Ⅵ-Promise-all-方法-promises-gt"><a href="#Ⅵ-Promise-all-方法-promises-gt" class="headerlink" title="Ⅵ-Promise.all 方法: (promises) =&gt; {}"></a>Ⅵ-Promise.all 方法: (promises) =&gt; {}</h4><blockquote><p>promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, 只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);  &#125;)</span><br><span class="line">   <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;错误错误错误&#x27;</span>);</span><br><span class="line">   <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;也是成功&#x27;</span>)</span><br><span class="line">   <span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅶ-Promise-race-方法-promises-gt"><a href="#Ⅶ-Promise-race-方法-promises-gt" class="headerlink" title="Ⅶ-Promise.race 方法: (promises) =&gt; {}"></a>Ⅶ-Promise.race 方法: (promises) =&gt; {}</h4><blockquote><p>(1) promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, <code>第一个完成</code>的 promise 的结果状态就是最终的结果状态,</p><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">  <span class="comment">//调用</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="4、Promise的几个关键问题"><a href="#4、Promise的几个关键问题" class="headerlink" title="4、Promise的几个关键问题"></a>4、Promise的几个关键问题</h2><h4 id="Ⅰ-如何改变-promise-的状态"><a href="#Ⅰ-如何改变-promise-的状态" class="headerlink" title="Ⅰ-如何改变 promise 的状态?"></a>Ⅰ-如何改变 promise 的状态?</h4><blockquote><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved </p><p>(2) reject(reason): 如果当前是 pending 就会变为 rejected </p><p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p></blockquote><h4 id="Ⅱ-一个-promise-指定多个成功-失败回调函数-都会调用吗"><a href="#Ⅱ-一个-promise-指定多个成功-失败回调函数-都会调用吗" class="headerlink" title="Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗?"></a>Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗?</h4><blockquote><p>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">  <span class="comment">///指定回调 - 1</span></span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;);</span><br><span class="line">  <span class="comment">//指定回调 - 2</span></span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅲ-改变-promise-状态和指定回调函数谁先谁后"><a href="#Ⅲ-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?"></a>Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?</h4><blockquote><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 </p><p>​    先指定回调再改变状态(<code>异步</code>):先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数</p><p>​    先改状态再指定回调(<code>同步</code>):改变状态 –&gt;指定回调 <code>并马上执行</code>回调</p><p>(2) 如何先改状态再<code>指定</code>回调?   –&gt;注意:指定并不是执行</p><p>​    ① 在执行器中直接调用 resolve()/reject() –&gt;即,不使用定时器等方法,执行器内直接同步操作 </p><p>​    ② 延迟更长时间才调用 then()     –&gt;即,在<code>.then()</code>这个方法外再包一层例如延时器这种方法</p><p>(3) 什么时候才能得到数据? </p><p>​    ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 </p><p>​    ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>(4) 个人理解–结合源码</p><p>​    源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断,所以当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>,所以只是这样导致只有同步操作才能成功.</p><p>​    所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p><p>​    具体代码实现看下方自定义promise</p></blockquote><h4 id="Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定"><a href="#Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定" class="headerlink" title="Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?"></a>Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?</h4><blockquote><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定 </p><p>(2) 详细表达: </p><p>​    ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 </p><p>​    ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 </p><p>​    ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//执行 then 方法</span></span><br><span class="line">&gt;<span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line"><span class="comment">// 1. 抛出错误 ,变为 rejected</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line"><span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"><span class="comment">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅴ-promise-如何串连多个操作任务"><a href="#Ⅴ-promise-如何串连多个操作任务" class="headerlink" title="Ⅴ- promise 如何串连多个操作任务?"></a>Ⅴ- promise 如何串连多个操作任务?</h4><blockquote><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 </p><p>(2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用<code>then()</code>将多个同步或异步操作串联成一个同步队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>); &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>); &#125;);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅵ-promise-异常传透"><a href="#Ⅵ-promise-异常传透" class="headerlink" title="Ⅵ-promise 异常传透?"></a>Ⅵ-promise 异常传透?</h4><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">   .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h4 id="Ⅶ-中断-promise-链"><a href="#Ⅶ-中断-promise-链" class="headerlink" title="Ⅶ- 中断 promise 链?"></a>Ⅶ- 中断 promise 链?</h4><blockquote><p>在<code>关键问题2</code>中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?</p><p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 </p><p>(2) 办法: 在回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="5、-Promise的实际应用"><a href="#5、-Promise的实际应用" class="headerlink" title="5、 Promise的实际应用"></a>5、 Promise的实际应用</h2><blockquote><p>举两个栗子</p></blockquote><h3 id="Ⅰ-加载图片"><a href="#Ⅰ-加载图片" class="headerlink" title="Ⅰ - 加载图片"></a>Ⅰ - 加载图片</h3><blockquote><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">   image.<span class="property">onload</span>  = resolve;</span><br><span class="line">   image.<span class="property">onerror</span> = reject;</span><br><span class="line">   image.<span class="property">src</span> = path;</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-Generator-函数与-Promise-的结合"><a href="#Ⅱ-Generator-函数与-Promise-的结合" class="headerlink" title="Ⅱ - Generator 函数与 Promise 的结合"></a>Ⅱ - Generator 函数与 Promise 的结合</h3><blockquote><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getFoo</span> () &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> foo = <span class="keyword">yield</span> <span class="title function_">getFoo</span>();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">run</span> (generator) &#123;</span><br><span class="line"> <span class="keyword">const</span> it = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));</span><br><span class="line">   &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">go</span>(it.<span class="title function_">next</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p></blockquote><hr><h1 id="二、Promise-API-用法详解"><a href="#二、Promise-API-用法详解" class="headerlink" title="二、Promise API 用法详解"></a>二、Promise API 用法详解</h1><blockquote><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>此部分是对于 <strong>Promise API 用法的详解</strong> ,尽量详细地列举其常见用法,所以篇幅较长</p></blockquote><h2 id="Ⅰ-基本用法"><a href="#Ⅰ-基本用法" class="headerlink" title="Ⅰ -  基本用法"></a>Ⅰ -  基本用法</h2><h4 id="①-举个创造-Promise-实例的栗子"><a href="#①-举个创造-Promise-实例的栗子" class="headerlink" title="①  举个创造 Promise 实例的栗子"></a>①  举个创造 Promise 实例的栗子</h4><blockquote><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)  <span class="title function_">resolve</span>(value); <span class="comment">//将该 Promise 修改为成功且返回</span></span><br><span class="line"><span class="keyword">else</span>  <span class="title function_">reject</span>(error); <span class="comment">//将该 Promise 修改为失败且返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p></blockquote><h4 id="②-使用-then-方法分别指定-成功-失败-的回调"><a href="#②-使用-then-方法分别指定-成功-失败-的回调" class="headerlink" title="② 使用 [ then ] 方法分别指定 成功/失败 的回调"></a>② 使用 [ then ] 方法分别指定 成功/失败 的回调</h4><blockquote><p><code>Promise</code>实例生成以后，可以用 [ then() ] 方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为resolve 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为rejected 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>[ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，<strong>第二个函数是可选的，不一定要提供</strong>。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p></blockquote><h4 id="③-举个-Promise-对象的简单栗子"><a href="#③-举个-Promise-对象的简单栗子" class="headerlink" title="③ 举个 Promise 对象的简单栗子"></a>③ 举个 Promise 对象的简单栗子</h4><blockquote><p>下面是一个<code>Promise</code>对象的简单例子。</p><blockquote><p>setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123; <span class="comment">//声明一个方法, 传入的 参数ms 为延时器时间</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;)</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;努力学习的汪&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">timeout</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line">&gt;<span class="comment">//打印结果 : 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p></blockquote><h4 id="④-Promise-新建后就会立即执行"><a href="#④-Promise-新建后就会立即执行" class="headerlink" title="④ Promise 新建后就会立即执行"></a>④ Promise 新建后就会立即执行</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">&gt;<span class="title function_">resolve</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise</span></span><br><span class="line">&gt;<span class="comment">// Hi!</span></span><br><span class="line">&gt;<span class="comment">// resolved //可以发现,明明then是在 Hi 前面,却最后打印</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>实际上,这个运行结果相关知识点是 [ <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E5%9B%9B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务与微任务</a> ] ,单独梳理在下方.这里可以先初步理解为: </p><ol><li><p>JS是单线程的,至上往下运行,在声明 <strong>Promise</strong> 时实际上已经执行到了内部方法</p></li><li><p>为何 resolve() 运行后没有立即打印?</p></li></ol><ul><li><p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p><blockquote><p><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</p><p><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</p></blockquote></li><li><p>JS执行时会区别这2个队列:</p><blockquote><p>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</p><p>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</p></blockquote></li></ul></blockquote><h4 id="⑤-举个异步加载图片的栗子"><a href="#⑤-举个异步加载图片的栗子" class="headerlink" title="⑤ 举个异步加载图片的栗子"></a>⑤ 举个异步加载图片的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">&gt;image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载成功&#x27;</span>)</span><br><span class="line"><span class="title function_">resolve</span>(image);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法从 <span class="subst">$&#123;url&#125;</span> 中加载图片`</span> ));</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;image.<span class="property">src</span> = url;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">loadImageAsync</span>(<span class="string">&#x27;正确的url&#x27;</span>) <span class="comment">//打印图片加载成功</span></span><br><span class="line">&gt;<span class="title function_">loadImageAsync</span>(<span class="string">&#x27;错误的url&#x27;</span>) <span class="comment">//抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926180306961.png" alt="image-20210926180306961"> </p></blockquote><h4 id="⑥-举个用Promise对象实现的-Ajax-操作的栗子"><a href="#⑥-举个用Promise对象实现的-Ajax-操作的栗子" class="headerlink" title="⑥ 举个用Promise对象实现的 Ajax 操作的栗子"></a>⑥ 举个用<code>Promise</code>对象实现的 Ajax 操作的栗子</h4><blockquote><p>Ajax知识点不懂的同学要去补一下: 这里可以看本人梳理的ajax笔记 –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">点我跳转</a> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>)  <span class="keyword">return</span>; <span class="comment">//当readyState 为4 时直接返回,不修改 promise 状态</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>); <span class="comment">//返回状态为 200 时将状态修改为成功,且将响应内容返回</span></span><br><span class="line"> <span class="keyword">else</span>  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>)); <span class="comment">//失败时抛出异常</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">//实例化xml实例</span></span><br><span class="line">&gt;client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url); <span class="comment">//下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点</span></span><br><span class="line">&gt;client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">&gt;client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">&gt;client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">&gt;client.<span class="title function_">send</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">return</span> promise;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> , json);</span><br><span class="line">&gt;&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926182129672.png" alt="image-20210926182129672"></p><blockquote><p>小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们</p></blockquote><blockquote><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926182506259.png" alt="image-20210926182506259"> </p></blockquote></blockquote><h4 id="⑦-resolve-的参数可以是另一个-Promise-实例"><a href="#⑦-resolve-的参数可以是另一个-Promise-实例" class="headerlink" title="⑦  resolve()  的参数可以是另一个 Promise 实例"></a>⑦  resolve()  的参数可以是另一个 Promise 实例</h4><blockquote><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123; <span class="title function_">resolve</span>(p1) &#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;p1的状态改为错误&#x27;</span>)), <span class="number">0</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">3000</span>) <span class="comment">//将p1 传给p2</span></span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch异常捕获:&#x27;</span>+error))</span><br><span class="line">&gt;<span class="comment">//首先报错</span></span><br><span class="line">&gt;<span class="comment">//运行三秒后打印: 失败</span></span><br></pre></td></tr></table></figure><h5 id="上面代码运行后执行效果"><a href="#上面代码运行后执行效果" class="headerlink" title="上面代码运行后执行效果:"></a>上面代码运行后执行效果:</h5><ul><li>首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错)</li><li>然后等3秒后再打印:  ‘失败’</li><li>注意: 如果 <strong>p2.then()</strong> 中没有写 <strong>reject</strong> 回调函数(第二个参数),则会被 <strong>catch</strong> 捕获,变为<code>catch异常捕获:Error: p1的状态改为错误</code></li></ul><h5 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h5><blockquote><ul><li>首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 <strong>p1 的reject()</strong>,所以直接控制台报错了</li><li><code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态</li><li>总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态</li></ul></blockquote></blockquote><h4 id="⑧-调用resolve或reject并不会终结-Promise-的参数函数的执行"><a href="#⑧-调用resolve或reject并不会终结-Promise-的参数函数的执行" class="headerlink" title="⑧ 调用resolve或reject并不会终结 Promise 的参数函数的执行"></a>⑧ 调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行</h4><blockquote><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 2</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p></blockquote><h4 id="⑨-建议在修改状态函数前加return"><a href="#⑨-建议在修改状态函数前加return" class="headerlink" title="⑨ 建议在修改状态函数前加return"></a>⑨ 建议在修改状态函数前加return</h4><blockquote><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="comment">// 后面的语句不会执行</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure><p>有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 <code>resolve/reject</code>前后好像都不影响啊! 这里我给举个实际场景</p></blockquote><h5 id="a-不加-return-导致的错误场景举🌰"><a href="#a-不加-return-导致的错误场景举🌰" class="headerlink" title="a) 不加 return 导致的错误场景举🌰"></a>a) 不加 return 导致的错误场景举🌰</h5><blockquote><p>一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 [②Promise.prototype.catch()](#② Promise.prototype.catch())</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//如果你加了 return , 函数执行到此步就停止了</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误错误!!!!!&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line">&gt;<span class="comment">// ok</span></span><br><span class="line">&gt;<span class="comment">// Uncaught Error: 错误错误!!!!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p></blockquote><h2 id="Ⅱ-API-用法详解"><a href="#Ⅱ-API-用法详解" class="headerlink" title="Ⅱ -  API 用法详解"></a>Ⅱ -  API 用法详解</h2><blockquote><p>此处将对于所有API进行详细剖析,参照资料为 <a href="">阮一峰的ES6日志</a></p></blockquote><h4 id="①-Promise-prototype-then"><a href="#①-Promise-prototype-then" class="headerlink" title="① Promise.prototype.then()"></a>① Promise.prototype.then()</h4><blockquote><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p></blockquote><h5 id="a-then方法返回的是一个新的Promise实例"><a href="#a-then方法返回的是一个新的Promise实例" class="headerlink" title="a) then方法返回的是一个新的Promise实例"></a>a) <code>then</code>方法返回的是一个新的<code>Promise</code>实例</h5><blockquote><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> json.<span class="property">name</span>;</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span> )</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p></blockquote><h5 id="b-采用链式的then-会等待前一个Promise状态发生改变才会被调用"><a href="#b-采用链式的then-会等待前一个Promise状态发生改变才会被调用" class="headerlink" title="b) 采用链式的then, 会等待前一个Promise状态发生改变才会被调用"></a>b) 采用链式的<code>then</code>, 会等待前一个Promise状态发生改变才会被调用</h5><blockquote><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;  <span class="keyword">return</span> <span class="title function_">getJSON</span>(json.<span class="property">name</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">name</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: My name is &quot;</span>, name)&#125;, </span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)&#125;</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p></blockquote><h5 id="c-使用箭头函数简写"><a href="#c-使用箭头函数简写" class="headerlink" title="c) 使用箭头函数简写"></a>c) 使用箭头函数简写</h5><blockquote><p>如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="title function_">getJSON</span>(json.<span class="property">name</span>) )</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">name</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: My name is &quot;</span>, name), </span><br><span class="line">    <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Promise-prototype-catch"><a href="#②-Promise-prototype-catch" class="headerlink" title="② Promise.prototype.catch()"></a>② Promise.prototype.catch()</h4><blockquote><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p></blockquote><h5 id="a-基本用法"><a href="#a-基本用法" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象</p><blockquote><ul><li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；</li><li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误</li><li>另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</li><li>被 catch 方法捕获的前提是前方的 then() 方法中没有对 <code>rejected</code> 进行捕获处理(即没有写reject回调函数)</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在catch中进行 rejected 的处理&#x27;</span>, err));</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;等同于另起一个then,只指定 rejected 的处理&quot;</span>, err));</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-reject-方法的作用，等同于抛出错误"><a href="#b-reject-方法的作用，等同于抛出错误" class="headerlink" title="b)  reject()方法的作用，等同于抛出错误"></a>b)  <code>reject()</code>方法的作用，等同于抛出错误</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常捕获: &#x27;</span>,error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//异常捕获:  Error: 直接抛出错误</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/******************  写法一 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入catch,然后再用 reject(e)抛出 &#x27;</span>)</span><br><span class="line"><span class="title function_">reject</span>(e) </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//进入catch,然后再用 reject(e)抛出 </span></span><br><span class="line">&gt;<span class="comment">//Error: 直接抛出错误</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************  写法二 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;使用 reject() 抛出错误&#x27;</span>));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise1.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//Error: 使用 reject() 抛出错误</span></span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了</p></blockquote><h5 id="c-如果-Promise-状态已经被修改，再抛出错误是无效的"><a href="#c-如果-Promise-状态已经被修改，再抛出错误是无效的" class="headerlink" title="c) 如果 Promise 状态已经被修改，再抛出错误是无效的"></a>c) 如果 Promise 状态已经被修改，再抛出错误是无效的</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//换成 reject(&#x27;成功了&#x27;) 结果也是一样的</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;成功后扔抛出异常&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line">&gt;<span class="comment">// 成功了</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve/reject</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过)</p></blockquote><h5 id="d-Promise-对象的错误具有-“冒泡”-性质"><a href="#d-Promise-对象的错误具有-“冒泡”-性质" class="headerlink" title="d) Promise 对象的错误具有 “冒泡” 性质"></a>d) Promise 对象的错误具有 “冒泡” 性质</h5><blockquote><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>) <span class="comment">//第一个promise</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123; <span class="comment">//第二个promise</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123; <span class="comment">//第三个promise</span></span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象(<strong>then返回的仍可能是一个Promise对象</strong>)：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>也是因为这个特性,有了 <strong>异常穿透问题</strong> </p></blockquote><h5 id="e-异常穿透问题"><a href="#e-异常穿透问题" class="headerlink" title="e) 异常穿透问题"></a>e) 异常穿透问题</h5><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line"> .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line"> .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h5 id="f-建议使用-catch-进行异常处理"><a href="#f-建议使用-catch-进行异常处理" class="headerlink" title="f) 建议使用 catch() 进行异常处理"></a>f) 建议使用 catch() 进行异常处理</h5><blockquote><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// bad</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">data</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>,data),</span><br><span class="line">&gt;<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,err)</span><br><span class="line">);</span><br><span class="line">&gt;<span class="comment">/********* 好的写法 ********************/</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>( <span class="function"><span class="params">data</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>,data)) <span class="comment">//只指定成功回调</span></span><br><span class="line">&gt;.<span class="title function_">catch</span>( <span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,err));</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法:</p><ul><li>理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误</li><li>也更接近同步的写法（<code>try/catch</code>）</li><li>因此, 建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</li></ul></blockquote><h5 id="g-与传统-try-catch-代码块的差异"><a href="#g-与传统-try-catch-代码块的差异" class="headerlink" title="g) 与传统 try/catch 代码块的差异"></a>g) 与传统 <code>try/catch</code> 代码块的差异</h5><blockquote><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//Promise 的 then() 处理,但不处理异常</span></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;只指定成功回调,不处理异常错误&#x27;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。</p><blockquote><ul><li>浏览器运行到这一行，会打印出错误提示<code>Uncaught (in promise) ReferenceError: hong is not defined</code></li><li>但是不会退出进程、终止脚本执行, 2 秒之后还是会输出<code>努力学习的汪</code>。</li><li>这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li></ul></blockquote></blockquote><h5 id="h-catch-方法后还能跟-then-方法"><a href="#h-catch-方法后还能跟-then-方法" class="headerlink" title="h) catch()方法后还能跟 then() 方法"></a>h) catch()方法后还能跟 then() 方法</h5><blockquote><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>()</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捉到错误咯:&#x27;</span>, error)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获后我还要浪&#x27;</span>) &#125;);</span><br><span class="line">&gt;<span class="comment">//捉到错误咯: ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//错误捕获后我还要浪</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。</p><p>如果没有报错，则会跳过<code>catch()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;硬是成功了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捉错误&#x27;</span>, error) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch后面的then: &#x27;</span>,v) );</span><br><span class="line">&gt;<span class="comment">//catch后面的then:  硬是成功了</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p></blockquote><h5 id="i-catch-方法之中，还能再抛出错误"><a href="#i-catch-方法之中，还能再抛出错误" class="headerlink" title="i) catch()方法之中，还能再抛出错误"></a>i) <code>catch()</code>方法之中，还能再抛出错误</h5><blockquote><p><code>catch()</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>()</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function">() =&gt;</span>  <span class="title function_">someOtherAsyncThing</span>()) </span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ctach:&#x27;</span>, error);</span><br><span class="line"> <span class="comment">// 下面一行会报错，因为 sum 没有声明</span></span><br><span class="line">  sum ++;</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获后的then()&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ctach: [ReferenceError: hong is not defined]</span></span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, error);</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 sum 没有声明</span></span><br><span class="line">&gt;sum ++;</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch()后的catch: &#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//catch:  ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//catch()后的catch:  ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p></blockquote><h4 id="③-Promise-prototype-finally"><a href="#③-Promise-prototype-finally" class="headerlink" title="③ Promise.prototype.finally()"></a>③ Promise.prototype.finally()</h4><blockquote><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 <code>ES2018</code> 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><blockquote><ul><li><code>finally</code>方法的回调函数不接受任何参数，</li><li>这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。</li><li>这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li></ul></blockquote></blockquote><h5 id="a-finally本质上是then方法的特例"><a href="#a-finally本质上是then方法的特例" class="headerlink" title="a) finally本质上是then方法的特例"></a>a) <code>finally</code>本质上是<code>then</code>方法的特例</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">result</span> =&gt;</span>  result ,</span><br><span class="line">&gt;<span class="function"><span class="params">error</span> =&gt;</span>  <span class="keyword">throw</span> error</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p></blockquote><h5 id="b-它的实现"><a href="#b-它的实现" class="headerlink" title="b) 它的实现"></a>b) 它的实现</h5><blockquote><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">&gt;<span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值(传入什么即传出什么)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// resolve 的值是 undefined</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// resolve 的值是 2</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 undefined</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 3</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927135255264.png" alt="image-20210927135255264"> </p></blockquote><h4 id="④-Promise-all"><a href="#④-Promise-all" class="headerlink" title="④ Promise.all()"></a>④ Promise.all()</h4><blockquote><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.all()</code>方法接受一个数组作为参数，</li><li><code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</li><li>另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</li></ul></blockquote></blockquote><h5 id="a-返回的状态由什么决定"><a href="#a-返回的状态由什么决定" class="headerlink" title="a) 返回的状态由什么决定?"></a>a) 返回的状态由什么决定?</h5><blockquote><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><blockquote><ol><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li></ol></blockquote><h6 id="下面是一个具体的例子。"><a href="#下面是一个具体的例子。" class="headerlink" title="下面是一个具体的例子。"></a>下面是一个具体的例子。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line">&gt;<span class="keyword">const</span> promises = [<span class="string">&#x27;hong&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">map</span>(item &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">getJSON</span>( item+<span class="string">&#x27;.json&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 <strong>都</strong> 变成<code>fulfilled</code>，或者**其中有一个变为<code>rejected</code>**，才会调用<code>Promise.all</code>方法后面的回调函数。</p><h6 id="下面是另一个例子"><a href="#下面是另一个例子" class="headerlink" title="下面是另一个例子"></a>下面是另一个例子</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>(); <span class="comment">//假设定义了一个异步方法,此方法能拿到你需要的所有数据</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> booksPromise = databasePromise     <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部书本信息</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> userPromise = databasePromise    <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">&gt;booksPromise,</span><br><span class="line">&gt;userPromise</span><br><span class="line">&gt;])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p></blockquote><h5 id="b-如果参数中的Promise实例定义了自己的catch方法"><a href="#b-如果参数中的Promise实例定义了自己的catch方法" class="headerlink" title="b) 如果参数中的Promise实例定义了自己的catch方法 ?"></a>b) 如果参数中的Promise实例定义了自己的catch方法 ?</h5><blockquote><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2自己的catch捕获: &#x27;</span>, e)</span><br><span class="line">&gt;<span class="keyword">return</span> e; <span class="comment">//异常获取后原样返回,不做修改</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//p2自己的catch捕获:  Error: 报错了</span></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的成功回调:  (2) [&#x27;hello&#x27;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，</p><blockquote><ul><li><code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code></li><li>但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。</li><li>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code></li><li>因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数</li></ul></blockquote></blockquote><h5 id="c-如果参数中的Promise实例-没有-定义自己的catch方法"><a href="#c-如果参数中的Promise实例-没有-定义自己的catch方法" class="headerlink" title="c)  如果参数中的Promise实例 没有 定义自己的catch方法 ?"></a>c)  如果参数中的Promise实例 <code>没有</code> 定义自己的catch方法 ?</h5><blockquote><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的catch Error: 报错了</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Promise-race"><a href="#⑤-Promise-race" class="headerlink" title="⑤ Promise.race()"></a>⑤ Promise.race()</h4><blockquote><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p></blockquote><h5 id="a-举个简单的🌰"><a href="#a-举个简单的🌰" class="headerlink" title="a) 举个简单的🌰"></a>a) 举个简单的🌰</h5><blockquote><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&gt;&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-举个应用实🌰"><a href="#b-举个应用实🌰" class="headerlink" title="b) 举个应用实🌰"></a>b) 举个应用实🌰</h5><blockquote><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求超时!!!!&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;p</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><p>是不是很好用又简单</p></blockquote><h4 id="⑥-Promise-allSettled"><a href="#⑥-Promise-allSettled" class="headerlink" title="⑥ Promise.allSettled()"></a>⑥ Promise.allSettled()</h4><blockquote><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。</p><p><strong>只有等到所有这些参数实例都返回结果</strong>，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><p>该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p></blockquote><h5 id="a-举个简单的🌰-1"><a href="#a-举个简单的🌰-1" class="headerlink" title="a) 举个简单的🌰"></a>a) 举个简单的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;loading = <span class="literal">true</span>; <span class="comment">//请求前将 loading 改为true ; 页面出现滚动加载图标蒙层</span></span><br><span class="line">&gt;<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line">&gt;loading = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p></blockquote><h5 id="b-该方法返回的新的-Promise-实例，一旦结束，状态总是fulfilled，不会变成rejected"><a href="#b-该方法返回的新的-Promise-实例，一旦结束，状态总是fulfilled，不会变成rejected" class="headerlink" title="b)  该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected"></a>b)  该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code></h5><blockquote><p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;返回成功状态的promise&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;返回失败状态的promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line">&gt;<span class="comment">// Promise.allSettled 得到的新实例状态只会是 `fulfilled`</span></span><br><span class="line">&gt;allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">//注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;[</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;</span></span><br><span class="line"><span class="comment">&gt;]</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>(注意,是 <strong>allSettledPromise</strong> 的状态,而不是内部的promise实例)</li><li>它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应的是传入<code>Promise.allSettled()</code>的 Promise 实例。</li><li>每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。</li><li><code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</li></ul></blockquote></blockquote><h5 id="c-举个返回值用法的🌰"><a href="#c-举个返回值用法的🌰" class="headerlink" title="c) 举个返回值用法的🌰"></a>c) 举个返回值用法的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [ <span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>) ];</span><br><span class="line">&gt;<span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出成功的请求</span></span><br><span class="line">&gt;<span class="keyword">const</span> successfulPromises = results.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出失败的请求，并取得它们的失败原因</span></span><br><span class="line">&gt;<span class="keyword">const</span> errors = results</span><br><span class="line">&gt;.<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> urls = [ <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span> ,<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">fetch</span>(x));</span><br><span class="line">&gt;<span class="comment">//举例用 Promise.all 尝试实现,很明显,难以实现</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requests);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了</p></blockquote><h4 id="⑦-Promise-any"><a href="#⑦-Promise-any" class="headerlink" title="⑦ Promise.any()"></a>⑦ Promise.any()</h4><blockquote><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p></blockquote><h5 id="a-与-Promise-race-方法的区别"><a href="#a-与-Promise-race-方法的区别" class="headerlink" title="a) 与 Promise.race() 方法的区别"></a>a) 与 <code>Promise.race()</code> 方法的区别</h5><blockquote><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p></blockquote><h5 id="b-Promise-any-抛出的错误"><a href="#b-Promise-any-抛出的错误" class="headerlink" title="b) Promise.any() 抛出的错误"></a>b) Promise.any() 抛出的错误</h5><blockquote><p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">AggregateError</span>() <span class="keyword">extends</span> <span class="title class_">Array</span> -&gt; <span class="title class_">AggregateError</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">AggregateError</span>();</span><br><span class="line">&gt;err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">&gt;err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line">&gt;<span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>(promises).<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// All of the promises were rejected.</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-再举个🌰"><a href="#c-再举个🌰" class="headerlink" title="c) 再举个🌰"></a>c) 再举个🌰</h5><blockquote><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;失败了&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> alsoRejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;太失败了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>([resolved, rejected, alsoRejected]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 成功</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>([rejected, alsoRejected]).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(results);  <span class="comment">//AggregateError: All promises were rejected</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败</p></blockquote><h4 id="⑧-Promise-resolve"><a href="#⑧-Promise-resolve" class="headerlink" title="⑧ Promise.resolve()"></a>⑧ Promise.resolve()</h4><blockquote><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况</p></blockquote><h5 id="a-参数是一个-Promise-实例"><a href="#a-参数是一个-Promise-实例" class="headerlink" title="a) 参数是一个 Promise 实例"></a>a) 参数是一个 Promise 实例</h5><blockquote><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></blockquote><h5 id="b-参数是一个thenable对象"><a href="#b-参数是一个thenable对象" class="headerlink" title="b) 参数是一个thenable对象"></a><strong>b) 参数是一个<code>thenable</code>对象</strong></h5><blockquote><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>) &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">&gt;p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// &#x27;成功&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出 **’成功’**。 </p></blockquote><h5 id="c-参数不是具有then-方法的对象，或根本就不是对象"><a href="#c-参数不是具有then-方法的对象，或根本就不是对象" class="headerlink" title="c) 参数不是具有then()方法的对象，或根本就不是对象"></a>c) 参数不是具有<code>then()</code>方法的对象，或根本就不是对象</h5><blockquote><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。</p><blockquote><ul><li>由于字符串 <code>努力学习的汪</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法）</li><li>返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行</li><li><code>Promise.resolve()</code>方法的参数会同时传给回调函数作为其参数</li></ul></blockquote></blockquote><h5 id="d-不带有任何参数"><a href="#d-不带有任何参数" class="headerlink" title="d) 不带有任何参数"></a>d) 不带有任何参数</h5><blockquote><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 –&gt; 不懂的同学请看 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#4%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8Bevent-loop%E6%9C%BA%E5%88%B6">JavaScript笔记中的#4事件循环模型event-loop机制</a> ,本人在此有进行详细的解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>); <span class="comment">//这里是新的一轮事件循环</span></span><br><span class="line">&gt;&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>); <span class="comment">//本轮同步代码结束后,新一轮事件循环前,就执行</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// one</span></span><br><span class="line">&gt;<span class="comment">// two</span></span><br><span class="line">&gt;<span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p></blockquote><h4 id="⑨-Promise-reject"><a href="#⑨-Promise-reject" class="headerlink" title="⑨ Promise.reject()"></a>⑨ Promise.reject()</h4><blockquote><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p></blockquote><h4 id="⑩-Promise-try"><a href="#⑩-Promise-try" class="headerlink" title="⑩ Promise.try()"></a>⑩ Promise.try()</h4><blockquote><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// next</span></span><br><span class="line">&gt;<span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><h6 id="那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的-API-呢？"><a href="#那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的-API-呢？" class="headerlink" title="那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？"></a>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？</h6></blockquote><h5 id="a-写法一-用async函数来写"><a href="#a-写法一-用async函数来写" class="headerlink" title="a) 写法一 : 用async函数来写"></a>a) 写法一 : 用<code>async</code>函数来写</h5><blockquote><p>该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-写法二-使用new-Promise"><a href="#b-写法二-使用new-Promise" class="headerlink" title="b)  写法二 : 使用new Promise()"></a>b)  写法二 : 使用<code>new Promise()</code></h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(</span><br><span class="line"> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">   <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">f</span>())</span><br><span class="line"> )</span><br><span class="line">&gt;)();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p></blockquote><h5 id="c-Promise-try的引出"><a href="#c-Promise-try的引出" class="headerlink" title="c) Promise.try的引出"></a>c) Promise.try的引出</h5><blockquote><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">userId</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line"> .<span class="title function_">then</span>(...)</span><br><span class="line"> .<span class="title function_">catch</span>(...)</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">try</span>(<span class="function">() =&gt;</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line"> .<span class="title function_">then</span>(...)</span><br><span class="line"> .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p></blockquote><hr><h1 id="三、自定义Promise手写"><a href="#三、自定义Promise手写" class="headerlink" title="三、自定义Promise手写"></a>三、自定义Promise手写</h1><blockquote><ol><li>下方的<code>Promise.prototype.then</code>与<code>Promise.resolve</code>为什么一个挂载在<code>prototype</code>而另一个挂载在实例对象上?</li></ol><p> 解:原因是分别为静态方法与实例方法 </p><p> –&gt;上面的需要new实例化的时候自动继承实例<code>prototype</code>上的方法和属性,所以用<code>实例对象.then()</code>来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用</p><h2 id="此部分可以跳过不看-类似手撕源码"><a href="#此部分可以跳过不看-类似手撕源码" class="headerlink" title="此部分可以跳过不看,类似手撕源码"></a><strong>此部分可以跳过不看,类似手撕源码</strong></h2></blockquote><h2 id="Ⅰ-Promise的实例方法实现"><a href="#Ⅰ-Promise的实例方法实现" class="headerlink" title="Ⅰ-Promise的实例方法实现"></a>Ⅰ-Promise的实例方法实现</h2><h3 id="1-初始结构搭建"><a href="#1-初始结构搭建" class="headerlink" title="1 - 初始结构搭建"></a>1 - 初始结构搭建</h3><blockquote><p>html引入,该章节后续html大部分重复 除非必要,否则不再放上来</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise-封装 | 1 - 初始结构搭建<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./promise.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>promise.js  –&gt;使用原生写法,最后会改为class写法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">executor</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-resolve-与-reject构建与基础实现"><a href="#2-resolve-与-reject构建与基础实现" class="headerlink" title="2 - resolve 与 reject构建与基础实现"></a>2 - resolve 与 reject构建与基础实现</h3><blockquote><ol><li>使用<code>const self = this;</code>保存this执行,使function中可以取得当前实例</li></ol><p>  ps:可以不使用该方法保存,但是下方function需要<code>改为箭头函数</code>,否则<code>function默认指向是window</code></p><p>  之后代码默认使用<code>self</code>保存this,箭头函数方式将在最后改为class写法时使用</p><ol start="2"><li>默认设置 <code>PromiseState = &#39;pending&#39;以及 PromiseResult = null</code>,这就是promise状态基础</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="comment">//添加属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">PromiseResult</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//保存实例对象的 this 的值</span></span><br><span class="line"><span class="comment">/*  此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>; </span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>) &#123;--------------------------------------------</span><br><span class="line">    <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">    self.<span class="property">PromiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// resolved</span></span><br><span class="line">    <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">    self.<span class="property">PromiseResult</span> = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//reject 函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>) &#123;----------------------------------------------</span><br><span class="line">    <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">    self.<span class="property">PromiseState</span> = <span class="string">&#x27;rejected&#x27;</span>; <span class="comment">// </span></span><br><span class="line">    <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">    self.<span class="property">PromiseResult</span> = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//同步调用『执行器函数』</span></span><br><span class="line">  <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-throw-抛出异常改变状态"><a href="#3-throw-抛出异常改变状态" class="headerlink" title="3 - throw 抛出异常改变状态"></a>3 - throw 抛出异常改变状态</h3><blockquote><ol><li>在2的基础上进行修改:将执行器放入<code>try-catch()</code>中</li><li>在catch中使用<code>reject()</code>修改 promise 对象状态为『<code>失败</code>』</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//同步调用『执行器函数』</span></span><br><span class="line">   <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="comment">//修改 promise 对象状态为『失败』</span></span><br><span class="line">   <span class="title function_">reject</span>(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-状态只能修改一次"><a href="#4-状态只能修改一次" class="headerlink" title="4 - 状态只能修改一次"></a>4 - 状态只能修改一次</h3><blockquote><ol><li><p>基于2 3代码中resolve和reject方法进修改</p></li><li><p>在成功与失败函数中添加判断<code> if(self.PromiseState !== &#39;pending&#39;) return;</code>,如果进入函数时状态不为<code>pending</code>直接退出,这样就能做到状态只能从<code>pending</code>改至其他状态且做到只能改一次</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html调用--------------------------------------------------------</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">      <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="comment">// throw &quot;error&quot;;</span></span><br><span class="line">    &#125;);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">promise.<span class="property">js</span>修改--------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="comment">//判断状态</span></span><br><span class="line">        <span class="keyword">if</span>(self.<span class="property">PromiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">        self.<span class="property">PromiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span>;<span class="comment">// resolved</span></span><br><span class="line">        <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">        self.<span class="property">PromiseResult</span> = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="comment">//判断状态</span></span><br><span class="line">        <span class="keyword">if</span>(self.<span class="property">PromiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">        self.<span class="property">PromiseState</span> = <span class="string">&#x27;rejected&#x27;</span>;<span class="comment">// </span></span><br><span class="line">        <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">        self.<span class="property">PromiseResult</span> = data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-then-方法执行回调基础实现"><a href="#5-then-方法执行回调基础实现" class="headerlink" title="5 - then 方法执行回调基础实现"></a>5 - then 方法执行回调基础实现</h3><blockquote><ol><li>修改<code>Promise.prototype.then</code>方法</li><li>传入<code>then(成功回调,失败回调)</code>,当调用then后,会判断当前<code>this.PromiseState</code>的状态,当其为成功时调用<code>成功回调</code>,失败时调用<code>失败回调</code></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// resolve(&#x27;OK&#x27;);// reject(&quot;Error&quot;);</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    p.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;, </span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;</span><br><span class="line">    )</span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;<span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-异步任务-then-方法实现"><a href="#6-异步任务-then-方法实现" class="headerlink" title="6 - 异步任务 then 方法实现"></a>6 - 异步任务 then 方法实现</h3><blockquote><ol><li><p>此处对于5有四处修改,下面上<code>js代码</code></p></li><li><p>当我运行<code>异步代码</code>后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的<code>p</code>为<code>pending</code>状态,所以根本不会执行resolve与reject方法</p></li></ol><p>  解:添加判断<code>pending</code>状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到</p><ol start="3"><li>为什么要将回调保存到实例上而不是直接调用?</li></ol><p>  <code>理由</code>:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数<br>  所以当你调用<code>then()</code>时却检测到状态为<code>pending</code>,说明这时候的promise在异步队列 不能直接运行成功或者失败函数</p><p>  <code>解决</code>:因为<code>resolve与reject</code>方法与<code>then()</code>不在同一个作用域中,并不能共享<code>then(成功回调,失败回调)</code>的参数,所以在判断状态为<code>pending</code>时将回调保存到实例对象上.然后将回调函数的调用放在<code>resolve()与reject()</code>中</p><p>  这样当我代码运行到异步队列的<code>resolve()或reject()</code>时,就可以在这个函数中运行回调函数,实现异步then</p><ol start="4"><li>此处的then<code>仍有瑕疵</code>,需要继续完善</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line"> <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>); <span class="comment">/* resolve(&#x27;OK&#x27;);*/</span>&#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//声明构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&#x27;pending&#x27;</span>; <span class="variable language_">this</span>.<span class="property">PromiseResult</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 声明属性     </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callback</span> = &#123;&#125;;-----------新添加<span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">//判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">PromiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    self.<span class="property">PromiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span>; self.<span class="property">PromiseResult</span> = data;</span><br><span class="line">    <span class="comment">//调用成功的回调函数  加判断的原因是防止无回调报错</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">callback</span>.<span class="property">onResolved</span>) &#123; self.<span class="property">callback</span>.<span class="title function_">onResolved</span>(data); &#125;  ------------新添加<span class="number">2</span> 最重要 </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//reject 函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">PromiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    self.<span class="property">PromiseState</span> = <span class="string">&#x27;rejected&#x27;</span>; self.<span class="property">PromiseResult</span> = data;</span><br><span class="line">    <span class="comment">//执行回调</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">callback</span>.<span class="property">onResolved</span>) &#123; self.<span class="property">callback</span>.<span class="title function_">onResolved</span>(data);&#125;  ------------新添加<span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;<span class="title function_">executor</span>(resolve, reject);&#125; <span class="keyword">catch</span> (e) &#123;<span class="title function_">reject</span>(e);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;<span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123; <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);&#125;</span><br><span class="line">  <span class="comment">//判断 pending 状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;  ------------新添加<span class="number">4</span></span><br><span class="line">    <span class="comment">//保存回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = &#123;</span><br><span class="line">      <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">      <span class="attr">onRejected</span>: onRejected</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-指定多个回调"><a href="#7-指定多个回调" class="headerlink" title="7 - 指定多个回调"></a>7 - 指定多个回调</h3><blockquote><ol><li><p>基于6代码进行修改 只展示修改部分代码</p></li><li><p><code>6</code>中保存回调函数的方式有BUG,如果我有多个<code>.then()</code>,后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数<code>有且只有</code>最后一个</p></li></ol><p>  解:使用<code>数组</code>的方式进行存储回调函数,调用时也是用数组循环取出</p><ol start="3"><li>此处的then<code>仍有瑕疵</code>,需要继续完善</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">   <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">reject</span>(<span class="string">&#x27;No&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;);</span><br><span class="line">   p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span><br><span class="line">   p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123; <span class="title function_">alert</span>(reason);&#125;);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">       <span class="comment">//resolve 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  .....</span><br><span class="line">        <span class="comment">//调用成功的回调函数</span></span><br><span class="line">        <span class="comment">// if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; </span></span><br><span class="line">        self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;   --------修改<span class="number">1</span></span><br><span class="line">            item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>)&#123;</span><br><span class="line">      ......</span><br><span class="line">        <span class="comment">//执行失败的回调</span></span><br><span class="line">        <span class="comment">// if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125;</span></span><br><span class="line">        self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;------修改<span class="number">2</span></span><br><span class="line">            item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//保存回调函数</span></span><br><span class="line">        <span class="comment">//  this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;--------修改<span class="number">3</span></span><br><span class="line">            <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">            <span class="attr">onRejected</span>: onRejected</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-同步任务-then-返回结果"><a href="#8-同步任务-then-返回结果" class="headerlink" title="8 - 同步任务 then 返回结果"></a>8 - 同步任务 then 返回结果</h3><blockquote><ol><li>在之前的then运行结果中得知,我们使用  [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象</li></ol><p>  解:所以我们在then中<code>return new Promise()</code>,使其得到的是一个新的promise对象</p><ol start="2"><li>在为<code>解决问题1</code>后产生一个新问题:新的promise对象因为没有用<code>rejerect与resolve</code>方法,导致返回的状态一直是<code>pending</code></li></ol><p>  解:在新的promise中判断<code>运行回调函数</code>后的返回值是什么,然后根据其不同类型给其赋予不同状态</p><p>  ​    Ⅰ-<code>if(result instanceof Promise)</code>:返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称<code>②promise对象</code>),在返回值(因为是promise对象)的<code>.then()</code>回调函数中使用rejerect与resolve方法,将其<code>自身的状态</code>赋予外层的promise,</p><p>  ​    即 回调函数中的promise 赋值 给then返回值 ,  所以 <code>最终返回状态==回调函数中的新promise状态</code></p><p>  ​    Ⅱ-如果返回值是一个<code>非promise</code>对象,返回状态设置为成功</p><p>  ​    Ⅲ-如果返回值是一个异常,返回状态设置为失败</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">html调用------------------------------------------------------------</span><br><span class="line">  <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">    <span class="comment">//执行 then 方法</span></span><br><span class="line">    <span class="keyword">const</span> res = p.<span class="title function_">then</span>(</span><br><span class="line">     <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&quot;FAIL&quot;</span>;&#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line"> <span class="comment">//  if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; onResolved(this.PromiseResult);&#125; 未修改时代码</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;    -------修改<span class="number">1</span> </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//获取回调函数的执行结果</span></span><br><span class="line">                <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);</span><br><span class="line">                <span class="comment">//判断</span></span><br><span class="line">                <span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;<span class="comment">//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层</span></span><br><span class="line">                    result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;  <span class="title function_">resolve</span>(v); &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;<span class="title function_">reject</span>(r);&#125;)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="title function_">resolve</span>(result);&#125;  <span class="comment">//如果返回的不是promise对象,都将其赋予成功状态</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                <span class="title function_">rejerect</span>(e);<span class="comment">//如果出错了,则返回失败状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;rejected&#x27;</span>)&#123; <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);&#125;------此部分修改与修改<span class="number">1</span>一样</span><br><span class="line">        <span class="comment">//判断 pending 状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123; <span class="attr">onResolved</span>: onResolved, <span class="attr">onRejected</span>: onRejected&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-异步任务-then-返回结果"><a href="#9-异步任务-then-返回结果" class="headerlink" title="9 - 异步任务 then 返回结果"></a>9 - 异步任务 then 返回结果</h3><blockquote><ol><li><p>异步任务是修改<code>if(this.PromiseState === &#39;pending&#39;)</code>后面的值,原因参考<code>6</code>,下面代码只举例这部分修改</p></li><li><p>因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行<code>加工</code>,<code>添加判断其回调函数的返回值</code>的代码块再存入实例的回调函数中</p></li></ol><p>  Ⅰ-声明一个新的函数:其内部功能-&gt;先运行<code>onResolved回调函数</code>,再将其返回值取出,进行判断其返回值(这个过程同<code>8</code>)</p><p>  Ⅱ-加工后存入实例回调函数数组,之后在<code>resolve与reject</code>方法中调用即可(同<code>6</code>)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line">   <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">reject</span>(<span class="string">&quot;Error&quot;</span>);&#125;, <span class="number">1000</span>)&#125;); <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="comment">//执行 then 方法</span></span><br><span class="line">    <span class="keyword">const</span> res = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return &#x27;oh Yeah&#x27;;  //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason, <span class="string">&quot;xx&quot;</span>); <span class="comment">//如果只是打印没返回,则实际上时返回一个undefined,</span></span><br><span class="line">      <span class="comment">//在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;sss&quot;</span>   <span class="comment">// throw &#x27;error&#x27;;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行成功回调函数</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="title function_">onResolved</span>(self.<span class="property">PromiseResult</span>);</span><br><span class="line">            <span class="comment">//判断 其结果</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">              result.<span class="title function_">then</span>(</span><br><span class="line">                  <span class="function"><span class="params">v</span> =&gt;</span> &#123; <span class="title function_">resolve</span>(v);&#125;,</span><br><span class="line">                  <span class="function"><span class="params">r</span> =&gt;</span> &#123;<span class="title function_">reject</span>(r);&#125;</span><br><span class="line">                 )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="title function_">resolve</span>(result);&#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;<span class="title function_">reject</span>(e);&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          </span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行成功回调函数</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="title function_">onRejected</span>(self.<span class="property">PromiseResult</span>);</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">              result.<span class="title function_">then</span>(</span><br><span class="line">                  <span class="function"><span class="params">v</span> =&gt;</span> &#123;<span class="title function_">resolve</span>(v); &#125;,</span><br><span class="line">                  <span class="function"><span class="params">r</span> =&gt;</span> &#123;<span class="title function_">reject</span>(r);&#125;</span><br><span class="line">                 )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="title function_">resolve</span>(result);&#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123; <span class="title function_">reject</span>(e); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="10-then方法代码优化"><a href="#10-then方法代码优化" class="headerlink" title="10- then方法代码优化"></a>10- then方法代码优化</h3><blockquote><ol><li>在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    封装函数----------------------------------------------------------------------------</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">type</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">type</span>(self.<span class="property">PromiseResult</span>);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">//如果是 Promise 类型的对象</span></span><br><span class="line">          result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//结果的对象状态为『成功』</span></span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  -----------------------------------------------------------------------------------    </span><br><span class="line">    <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//保存回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">callback</span>(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-catch-方法与异常穿透与值传递"><a href="#11-catch-方法与异常穿透与值传递" class="headerlink" title="11 - catch 方法与异常穿透与值传递"></a>11 - catch 方法与异常穿透与值传递</h3><blockquote><ol><li><p>异常穿透:添加<code>catch 方法 </code>,并且需要进行回调函数为<code>undefined的</code>处理</p></li><li><p>当我<code>then()</code>中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是<code>undefined</code></p></li></ol><p>  解:进行回调函数判断,当其为空时,基于默认回调函数内容:<code>直接往外抛出</code>这样下方的<code>then() or catch()</code>就可以承接到异常或者值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//值传递</span></span><br><span class="line">    p.<span class="title function_">then</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);&#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);&#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">...-----------修改<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason;&#125;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123; onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;&#125;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加 catch 方法  </span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">onRejected</span>)&#123;  ---------------异常穿透 修改<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-Promise的静态方法实现"><a href="#Ⅱ-Promise的静态方法实现" class="headerlink" title="Ⅱ-Promise的静态方法实现"></a>Ⅱ-Promise的静态方法实现</h2><h3 id="1-Promise-resolve-封装"><a href="#1-Promise-resolve-封装" class="headerlink" title="1 - Promise.resolve 封装"></a>1 - Promise.resolve 封装</h3><blockquote><ol><li><p>判断传入的参数是否为<code>promise对象</code>:</p><p>Ⅰ-如果为<code>promise</code>:将其状态与结果赋值给外层promise对象</p><p>Ⅱ-如果为<code>非promise</code>:状态设置为成功</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"> <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line"> <span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;     </span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);<span class="comment">// resolve(&#x27;Success&#x27;);</span></span><br><span class="line">    &#125;));</span><br><span class="line"> <span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>));</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 resolve 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="comment">//返回promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>)&#123;</span><br><span class="line">            value.<span class="title function_">then</span>(</span><br><span class="line">                <span class="function"><span class="params">v</span>=&gt;</span>&#123;<span class="title function_">resolve</span>(v);&#125;,</span><br><span class="line">                <span class="function"><span class="params">r</span>=&gt;</span>&#123;<span class="title function_">reject</span>(r);&#125;</span><br><span class="line">            )&#125;<span class="keyword">else</span>&#123;<span class="title function_">resolve</span>(value); &#125;<span class="comment">//状态设置为成功</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Promise-resolve-封装"><a href="#2-Promise-resolve-封装" class="headerlink" title="2 - Promise.resolve 封装"></a>2 - Promise.resolve 封装</h3><blockquote><p>不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为<code>失败</code>即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line">   <span class="comment">//Promise.reject</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 reject 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Promise-all-封装"><a href="#3-Promise-all-封装" class="headerlink" title="3 - Promise.all 封装"></a>3 - Promise.all 封装</h3><blockquote><ol><li>遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回<code>成功</code>状态</li><li>如果当数组中任意一个promise的执行结果是<code>reject</code>,直接中断,返回状态为<code>失败</code></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">    <span class="comment">//调用 all 方法</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 all 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">//返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">//每个promise对象 都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//将当前promise对象成功的结果 存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;<span class="title function_">resolve</span>(arr);&#125;<span class="comment">//修改状态</span></span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Promise-race-封装"><a href="#4-Promise-race-封装" class="headerlink" title="4 - Promise.race 封装"></a>4 - Promise.race 封装</h3><blockquote><p>直接谁先执行就返回谁的运行结果即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"> <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">    <span class="comment">//调用 race 方法</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line">promise.<span class="property">js</span>修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 race 方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改返回对象的状态为 『成功』</span></span><br><span class="line">        <span class="title function_">resolve</span>(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改返回对象的状态为 『失败』</span></span><br><span class="line">        <span class="title function_">reject</span>(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-其他优化"><a href="#Ⅲ-其他优化" class="headerlink" title="Ⅲ-其他优化"></a>Ⅲ-其他优化</h2><h3 id="1-回调函数『异步执行』"><a href="#1-回调函数『异步执行』" class="headerlink" title="1 - 回调函数『异步执行』"></a>1 - 回调函数『异步执行』</h3><blockquote><ol><li>如果我们运行下面代码,正确顺序是: 111 –&gt; 333 –&gt;444</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">444</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>但当我们运行之前封装的 <strong>Promise</strong> 代码时,结果却是:111 –&gt; 444 –&gt; 333</li></ol><p>  我们需要将我们的then方法变成<code>异步方法</code></p><ol start="3"><li>我们只要在以下四处地方的<code>回调函数调用</code>外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>)&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.<span class="title function_">onResolved</span>(data); &#125;); &#125;);--修改<span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//reject 函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">data</span>)&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; self.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.<span class="title function_">onRejected</span>(data); &#125;); &#125;);---修改<span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//添加 then 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">      <span class="comment">/*  修改前代码</span></span><br><span class="line"><span class="comment">      if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125;</span></span><br><span class="line"><span class="comment">  if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected);</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">callback</span>(onResolved);&#125;);&#125;  -----修改<span class="number">3</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;rejected&#x27;</span>)&#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">callback</span>(onRejected);&#125;);   ---修改<span class="number">4</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><code>相关原理参照js事件循环机制、宏任务与微任务</code></li></ol></blockquote><h3 id="2-class改写promise"><a href="#2-class改写promise" class="headerlink" title="2- class改写promise"></a>2- class改写promise</h3><blockquote><ol><li>其中将<code>self=this</code>保存this指向方式改为箭头函数表示(在上面示例中也有效果)</li><li>将其改为class写法</li><li>下面为promisedemo.js代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line"> <span class="comment">//构造方法</span></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">   <span class="comment">//添加属性</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">PromiseResult</span> = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">//声明属性</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">callbacks</span> = [];</span><br><span class="line">   <span class="comment">//保存实例对象的 this 的值</span></span><br><span class="line">   <span class="comment">//resolve 函数</span></span><br><span class="line">   <span class="keyword">let</span> <span class="title function_">resolve</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">     <span class="comment">//判断状态</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// resolved</span></span><br><span class="line">     <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">PromiseResult</span> = data;</span><br><span class="line">     <span class="comment">//调用成功的回调函数</span></span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">         item.<span class="title function_">onResolved</span>(data);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//reject 函数</span></span><br><span class="line">   <span class="keyword">let</span> <span class="title function_">reject</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">     <span class="comment">//判断状态</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">PromiseState</span> = <span class="string">&#x27;rejected&#x27;</span>; <span class="comment">// </span></span><br><span class="line">     <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">PromiseResult</span> = data;</span><br><span class="line">     <span class="comment">//执行失败的回调</span></span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">         item.<span class="title function_">onRejected</span>(data);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//同步调用『执行器函数』</span></span><br><span class="line">     <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="comment">//修改 promise 对象状态为『失败』</span></span><br><span class="line">     <span class="title function_">reject</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//then 方法封装</span></span><br><span class="line"> <span class="title function_">then</span>(<span class="params">onResolved, onRejected</span>) &#123;</span><br><span class="line">   <span class="comment">//判断回调函数参数</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">     onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> reason;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">     onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">     <span class="comment">//value =&gt; &#123; return value&#125;;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">//封装函数</span></span><br><span class="line">     <span class="keyword">let</span> <span class="title function_">callback</span> = (<span class="params">type</span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获取回调函数的执行结果</span></span><br><span class="line">         <span class="keyword">let</span> result = <span class="title function_">type</span>(<span class="variable language_">this</span>.<span class="property">PromiseResult</span>);</span><br><span class="line">         <span class="comment">//判断</span></span><br><span class="line">         <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">           <span class="comment">//如果是 Promise 类型的对象</span></span><br><span class="line">           result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="title function_">resolve</span>(v);</span><br><span class="line">           &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="title function_">reject</span>(r);</span><br><span class="line">           &#125;)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//结果的对象状态为『成功』</span></span><br><span class="line">           <span class="title function_">resolve</span>(result);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         <span class="title function_">reject</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">callback</span>(onResolved);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">callback</span>(onRejected);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//判断 pending 状态</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">PromiseState</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">       <span class="comment">//保存回调函数</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">         <span class="attr">onResolved</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">callback</span>(onResolved);</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">onRejected</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">callback</span>(onRejected);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//catch 方法</span></span><br><span class="line"> <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 resolve 方法</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">   <span class="comment">//返回promise对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">       value.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">resolve</span>(v);</span><br><span class="line">       &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">reject</span>(r);</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//状态设置为成功</span></span><br><span class="line">       <span class="title function_">resolve</span>(value);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 reject 方法</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="title function_">reject</span>(reason);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 all 方法</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">   <span class="comment">//返回结果为promise对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">//声明变量</span></span><br><span class="line">     <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">let</span> arr = [];</span><br><span class="line">     <span class="comment">//遍历</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//得知对象的状态是成功</span></span><br><span class="line">         <span class="comment">//每个promise对象 都成功</span></span><br><span class="line">         count++;</span><br><span class="line">         <span class="comment">//将当前promise对象成功的结果 存入到数组中</span></span><br><span class="line">         arr[i] = v;</span><br><span class="line">         <span class="comment">//判断</span></span><br><span class="line">         <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line">           <span class="comment">//修改状态</span></span><br><span class="line">           <span class="title function_">resolve</span>(arr);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="title function_">reject</span>(r);</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加 race 方法</span></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//修改返回对象的状态为 『成功』</span></span><br><span class="line">         <span class="title function_">resolve</span>(v);</span><br><span class="line">       &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="comment">//修改返回对象的状态为 『失败』</span></span><br><span class="line">         <span class="title function_">reject</span>(r);</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>html文件调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>class版本封装<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./promisedemo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// resolve(&quot;OK&quot;);</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">reject</span>(<span class="string">&quot;Erosssr&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span></span><br><span class="line"><span class="language-javascript">   &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span></span><br><span class="line"><span class="language-javascript">   &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="三、Promise-async-await"><a href="#三、Promise-async-await" class="headerlink" title="三、Promise+ async + await"></a>三、Promise+ async + await</h1><blockquote><h5 id="1-Promise-gt-异步"><a href="#1-Promise-gt-异步" class="headerlink" title="1)Promise==&gt;异步"></a>1)Promise==&gt;异步</h5><h5 id="2-await-gt-异步转同步"><a href="#2-await-gt-异步转同步" class="headerlink" title="2)await==&gt;异步转同步"></a>2)await==&gt;异步转同步</h5><ol><li>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</li><li>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行        </li></ol><h5 id="3-async-gt-同步转异步"><a href="#3-async-gt-同步转异步" class="headerlink" title="3)async==&gt;同步转异步"></a>3)async==&gt;同步转异步</h5><ol><li>   方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</li></ol><h6 id="4-mdn文档"><a href="#4-mdn文档" class="headerlink" title="4)mdn文档"></a>4)mdn文档</h6><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async</a> </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li></ol></blockquote><h2 id="Ⅰ-async函数"><a href="#Ⅰ-async函数" class="headerlink" title="Ⅰ-async函数"></a>Ⅰ-async函数</h2><blockquote><ol><li>函数的返回值为 promise 对象 </li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol></blockquote><h2 id="Ⅱ-await表达式"><a href="#Ⅱ-await表达式" class="headerlink" title="Ⅱ-await表达式"></a>Ⅱ-await表达式</h2><blockquote><ol><li><p>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 </p></li><li><p>如果表达式是 promise 对象, await 返回的是 promise 成功的值 </p></li><li><p>如果表达式是其它值, 直接将此值作为 await 的返回值</p></li></ol></blockquote><h2 id="Ⅲ-注意"><a href="#Ⅲ-注意" class="headerlink" title="Ⅲ-注意"></a>Ⅲ-注意</h2><blockquote><ol><li>await 必须写在 async 函数中, 但 async 函数中可以没有 await </li><li>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li></ol></blockquote><h2 id="Ⅳ-自己对某些问题理解解答"><a href="#Ⅳ-自己对某些问题理解解答" class="headerlink" title="Ⅳ-自己对某些问题理解解答"></a>Ⅳ-自己对某些问题理解解答</h2><h3 id="1、如何在Promise外部使用Promise的结果"><a href="#1、如何在Promise外部使用Promise的结果" class="headerlink" title="1、如何在Promise外部使用Promise的结果"></a>1、如何在Promise外部使用Promise的结果</h3><blockquote><p>用到的本章节知识:</p><p>1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将<code>new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)</code>等价于<code>axios(&#123;&#125;)</code></p><p>2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次</p><p>3、 上一步抛出后可以在下面 的.then()中获取到</p><p>  Ⅰ-如果没有用.then(),则值会抛往Promise外部</p><p>  Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出–<code>某些业务场景需要</code> ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) —前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//讲解时写的简单demo</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">resolveCommon</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> result=<span class="string">&quot;普通promise初始值&quot;</span></span><br><span class="line">  result=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">resolve</span>(<span class="string">&quot;promise普通结果&quot;</span>); &#125;, <span class="number">1000</span>); &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"> <span class="comment">//打印结果: Promise &#123; &lt;pending&gt; &#125; </span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">resolveAsync</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> result=<span class="string">&quot;await+async的promise初始值&quot;</span></span><br><span class="line">  result=<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">resolve</span>(<span class="string">&quot;这是async+await结果&quot;</span>); &#125;, <span class="number">1000</span>);&#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"> <span class="comment">//打印结果: 这是async+await结果  这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中</span></span><br><span class="line"> <span class="comment">//------------------------------------------------------</span></span><br><span class="line"> <span class="comment">//在第二个promise中调用使用</span></span><br><span class="line"> <span class="keyword">let</span> result2=<span class="string">&quot;&quot;</span></span><br><span class="line"> result2= <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">resolve</span>(result+<span class="string">&quot;+经过第二个promise加工&quot;</span>); &#125;, <span class="number">1000</span>);&#125;)</span><br><span class="line"> .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二个promise的then()中打印并返回:&quot;</span>,v)</span><br><span class="line">   <span class="keyword">return</span> v+<span class="string">&quot;,经过then()加工返回&quot;</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;最终结果:第二个promise外部结果打印,&quot;</span>,result2)</span><br><span class="line"> <span class="comment">//---------------------------------------------</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="title function_">resolveCommon</span>()  <span class="comment">//调用普通promise函数</span></span><br><span class="line">&gt;<span class="title function_">resolveAsync</span>()    <span class="comment">//调用await+async</span></span><br><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">1.resolveCommon() 运行结果:    Promise &#123; &lt;pending&gt; &#125;</span></span><br><span class="line"><span class="comment">2.resolveAsync() 运行结果:     </span></span><br><span class="line"><span class="comment"> 这是async+await结果</span></span><br><span class="line"><span class="comment"> 第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工</span></span><br><span class="line"><span class="comment"> 最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><p>原因解析:</p><ol><li>new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列 </li></ol><p>  所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { <pending> } 对象</p><ol start="2"><li>而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值</li></ol><p>  所以下面的任务就可以使用到这个值</p><ol start="3"><li>为什么这些操作要放在同一个async fn()=&gt;{} 中?</li></ol><p> 1)Promise==&gt;异步</p><p> 2)await==&gt;异步转同步</p><ol><li><p>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</p></li><li><p>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行  </p></li></ol><p> 3)async==&gt;同步转异步</p><p>  方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</p></blockquote><h1 id="四、宏任务与微任务"><a href="#四、宏任务与微任务" class="headerlink" title="四、宏任务与微任务"></a>四、宏任务与微任务</h1><h2 id="Ⅰ-说明"><a href="#Ⅰ-说明" class="headerlink" title="Ⅰ-说明"></a>Ⅰ-说明</h2><blockquote><p>原理图:</p><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Promise系统学习_宏任务微任务原理图"></p><p>说明:</p><ol><li>JS中用来存储待执行回调函数的队列包含2个不同特定的列队<ul><li><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</li><li><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</li></ul></li><li>JS执行时会区别这2个队列:<ul><li>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</li><li>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</li></ul></li></ol></blockquote><h2 id="Ⅱ-代码与示例"><a href="#Ⅱ-代码与示例" class="headerlink" title="Ⅱ-代码与示例"></a>Ⅱ-代码与示例</h2><blockquote><p>你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序</p></blockquote><h3 id="1、代码示例"><a href="#1、代码示例" class="headerlink" title="1、代码示例:"></a>1、代码示例:</h3><h4 id="a-首先给出注释的栗子举一个"><a href="#a-首先给出注释的栗子举一个" class="headerlink" title="a) 首先给出注释的栗子举一个"></a>a) 首先给出注释的栗子举一个</h4><blockquote><p>此处会给出每个打印放入什么队列,加深你的印象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout callback1（）&#x27;</span>)<span class="comment">//立即放入宏队列</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise onResolved3()&#x27;</span>, value)<span class="comment">//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 </span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout callback2（）&#x27;</span>) <span class="comment">//立即放入宏队列,</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise onResolved1()&#x27;</span>, value)<span class="comment">//立即放入微队列</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout callback3（）&#x27;</span>, value) <span class="comment">//立即放入宏任务</span></span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise onResolved2()&#x27;</span>, value)<span class="comment">//立即放入微队列</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;同步代码&#x27;</span>) <span class="comment">//同步代码立即执行</span></span><br></pre></td></tr></table></figure><p>结果放在下方,就怕你不小心瞄到</p></blockquote><h4 id="b-尝试自己思考下"><a href="#b-尝试自己思考下" class="headerlink" title="b) 尝试自己思考下"></a>b) 尝试自己思考下</h4><blockquote><p>尝试自己脑海中用自己理解 ‘运行’ 一下, 然后把结果写下来,再去下面结果做对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码开始执行&#x27;</span>),<span class="number">0</span>)</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始for循环&#x27;</span>);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">   i == <span class="number">99</span> &amp;&amp; <span class="title function_">resolve</span>()</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行then函数&#x27;</span>))</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、示例结果"><a href="#2、示例结果" class="headerlink" title="2、示例结果:"></a>2、示例结果:</h3><h4 id="a-第一个栗子的结果"><a href="#a-第一个栗子的结果" class="headerlink" title="a) 第一个栗子的结果"></a>a) 第一个栗子的结果</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;同步代码&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Promise onResolved1()&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Promise onResolved2()&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;timeout callback1（）&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Promise onResolved3()&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;timeout callback2（）&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;timeout callback3（）&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="b-第二个栗子的结果"><a href="#b-第二个栗子的结果" class="headerlink" title="b) 第二个栗子的结果"></a>b) 第二个栗子的结果</h4><blockquote><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210827094130354.png" alt="image-20210827094130354"></p><p>PS: 可以忽略<code>undefined</code>这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担.</p><p>当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释</p></blockquote><h1 id="五、对浏览器console控制台输出undefined的分析"><a href="#五、对浏览器console控制台输出undefined的分析" class="headerlink" title="五、对浏览器console控制台输出undefined的分析"></a>五、对浏览器console控制台输出undefined的分析</h1><h2 id="Ⅰ-出现场景"><a href="#Ⅰ-出现场景" class="headerlink" title="Ⅰ- 出现场景"></a>Ⅰ- 出现场景</h2><blockquote><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210827095144833.png" alt="image-20210827095144833"></p></blockquote><h2 id="Ⅱ-尝试输入其他内容进行分析"><a href="#Ⅱ-尝试输入其他内容进行分析" class="headerlink" title="Ⅱ - 尝试输入其他内容进行分析"></a>Ⅱ - 尝试输入其他内容进行分析</h2><blockquote><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210827095702736.png" alt="image-20210827095702736"></p><p>那么做个合理推测: 应该是在控制台输入的内容,它的 <code>返回值</code> 会显示出来,这让我们不禁想到JS的 [ <strong>eval()</strong> ]</p></blockquote><h2 id="Ⅲ-eval（string）"><a href="#Ⅲ-eval（string）" class="headerlink" title="Ⅲ - eval（string）"></a>Ⅲ - eval（string）</h2><blockquote><p>其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值；</p><p>如果是没有返回值的表达式或语句，则会返回 undefined ；</p><p>如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。</p><p>于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数</p></blockquote><h2 id="Ⅳ-验证一下"><a href="#Ⅳ-验证一下" class="headerlink" title="Ⅳ - 验证一下"></a>Ⅳ - 验证一下</h2><blockquote><p><img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210827100156570.png" alt="image-20210827100156570"> </p><p>大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧 </p></blockquote><h2 id="Ⅴ-分析其在宏任务与微任务的打印顺序"><a href="#Ⅴ-分析其在宏任务与微任务的打印顺序" class="headerlink" title="Ⅴ -  分析其在宏任务与微任务的打印顺序"></a>Ⅴ -  分析其在宏任务与微任务的打印顺序</h2><blockquote><p>首先看图:<img src="A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210827094130354.png" alt="image-20210827094130354"> </p><p>可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ES系列学习笔记</title>
      <link href="/2022/10/17/ES%E5%85%A8%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/17/ES%E5%85%A8%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ECMAScript引出"><a href="#一、ECMAScript引出" class="headerlink" title="一、ECMAScript引出"></a>一、ECMAScript引出</h1><blockquote><p>JS基础要会再看这个,不然容易造成基础不牢的后果,此部分<code>类似JS语法糖</code>,请相信我不会害你的</p><p>必要的预备前置知识点:  <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0">JavaScript基础以及进阶知识点</a> –&gt;其中 [ 进阶 ] 笔记部分需要重点掌握</p></blockquote><h2 id="1、什么是-ECMA和ECMAScript"><a href="#1、什么是-ECMA和ECMAScript" class="headerlink" title="1、什么是 ECMA和ECMAScript"></a>1、什么是 ECMA和ECMAScript</h2><blockquote><p><code>ECMA</code>（European Computer Manufacturers Association）中文名称为欧洲计算机制 造商协会, 这个组织的目标是评估、开发和认可电信和计算机标准. 1994 年后该 组织改名为 Ecma 国际. </p><p><code>ECMAScript</code> 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言. </p></blockquote><h2 id="2、ECMA-262"><a href="#2、ECMA-262" class="headerlink" title="2、ECMA-262"></a>2、ECMA-262</h2><blockquote><p>Ecma 国际制定了许多标准, 而 ECMA-262 只是其中的一个, 所有标准列表查看 –&gt;<a href="https://www.ecma-international.org/publications-and-standards/standards/">点我传送</a></p></blockquote><h3 id="Ⅰ-ECMA-262-历史"><a href="#Ⅰ-ECMA-262-历史" class="headerlink" title="Ⅰ-ECMA-262 历史"></a>Ⅰ-ECMA-262 历史</h3><blockquote><p>ECMA-262（ECMAScript）历史版本查看网址: –&gt;<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">点我传送</a></p><table><thead><tr><th align="center">版数</th><th align="center">年份</th><th>内容</th></tr></thead><tbody><tr><td align="center">第 1 版</td><td align="center">1997 年</td><td>制定了语言的基本语法</td></tr><tr><td align="center">第 2 版</td><td align="center">1998 年</td><td>较小改动</td></tr><tr><td align="center">第 3 版</td><td align="center">1999 年</td><td>引入正则、异常处理、格式化输出等. IE 开始支持</td></tr><tr><td align="center">第 4 版</td><td align="center">2007 年</td><td>过于激进, 未发布</td></tr><tr><td align="center">第 5 版</td><td align="center">2009 年</td><td>引入严格模式、JSON , 扩展对象、数组、原型、字符串、日期方法</td></tr><tr><td align="center"><code>第 6 版</code></td><td align="center"><code>2015 年</code></td><td>模块化、面向对象语法、 Promise、箭头函数、let、 const、数组解构赋值等等<br />因为发布内容很多,堪称里程碑,所以我们目前通常主要学这个</td></tr><tr><td align="center">第 7 版</td><td align="center">2016 年</td><td>幂运算符、数组扩展、 Async/await 关键字</td></tr><tr><td align="center">第 8 版</td><td align="center">2017 年</td><td>Async/await、字符串扩展</td></tr><tr><td align="center">第 9 版</td><td align="center">2018 年</td><td>对象解构赋值、正则扩展</td></tr><tr><td align="center">第 10 版</td><td align="center">2019 年</td><td>扩展对象、数组方法</td></tr><tr><td align="center">ES.next</td><td align="center">动态指向下一个版本</td><td><code>后续学到我会进行补充</code></td></tr></tbody></table><p><code>注: 从 ES6 开始, 每年发布一个版本, 版本号比年份最后一位大 1</code></p><p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)、<code>ES11</code>(实质上是<code>ES2020</code>), 实质上都是一些不规范的概念. 从ES1到ES6 , 每个标准都是花了好几年甚至十多年才制定下来, 你一个ES6到ES7 , ES7到ES8 , 才用了一年, 按照这样的定义下去, 那不是很快就ES20了. 用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>、<strong>ES2016</strong>、<strong>ES2017</strong>、<strong>ES2018</strong>、<strong>ES2019</strong>、<strong>ES2020</strong>. </p></blockquote><h3 id="Ⅱ-谁在维护-ECMA-262"><a href="#Ⅱ-谁在维护-ECMA-262" class="headerlink" title="Ⅱ-谁在维护 ECMA-262"></a>Ⅱ-谁在维护 ECMA-262</h3><blockquote><p>TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会. 其会员都是公司（<code>其中主要是浏览器厂商</code>:有苹果、谷歌、微软、因特尔等）. TC39 定期 召开会议, 会议由会员公司的代表与特邀专家出席</p></blockquote><h2 id="3、为什么要重点学习-ES6"><a href="#3、为什么要重点学习-ES6" class="headerlink" title="3、为什么要重点学习 ES6"></a>3、为什么要重点学习 ES6</h2><blockquote><ul><li>ES6 的版本变动内容最多, 具有里程碑意义</li><li>ES6 加入许多新的语法特性, 编程实现更简单、高效</li><li>ES6 是前端发展趋势, 就业必备技能</li><li>实际上ES系列的知识点基本上都要掌握,才能写出逼格更高的代码:dog:</li></ul></blockquote><h2 id="4、ES6-兼容性"><a href="#4、ES6-兼容性" class="headerlink" title="4、ES6 兼容性"></a>4、ES6 兼容性</h2><blockquote><p>可以查看gitHub上的这个图–&gt;<a href="http://kangax.github.io/compat-table/es6/">点我传送</a></p></blockquote><h1 id="二、ECMASript-6-新特性"><a href="#二、ECMASript-6-新特性" class="headerlink" title="二、ECMASript 6 新特性"></a>二、ECMASript 6 新特性</h1><blockquote><p>想要查看更权威的官方ES6文档,可以看 <a href="https://www.bookstack.cn/read/es6-3rd/sidebar.md">阮一峰的ES6文档</a></p><p>此部分将记录由 <strong>ES6提出以及后续补充的</strong> ,但不仅限于 ES6新增内容, 比如 <strong>Promise</strong>是ES6提出的,但是例如<code>Promise.allSettled()</code> 该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入,我仍然会收录在此部分笔记而不是记录在<strong>ES11</strong>新特性中</p></blockquote><h2 id="1、ES6更新的内容概括"><a href="#1、ES6更新的内容概括" class="headerlink" title="1、ES6更新的内容概括"></a>1、ES6更新的内容概括</h2><blockquote><p><strong>表达式</strong>: 声明、解构赋值</p><p><strong>内置对象</strong>: 字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</p><p><strong>语句与运算</strong>: Class、Module、Iterator</p><p><strong>异步编程</strong>: Promise、Generator、Async</p></blockquote><h2 id="2、let和const命令、作用域"><a href="#2、let和const命令、作用域" class="headerlink" title="2、let和const命令、作用域"></a>2、let和const命令、作用域</h2><blockquote><p>注意:<code>不存在变量提升</code></p><p><code>var</code>命令会发生“变量提升”现象, 即变量可以在声明之前使用, 值为 <strong>undefined</strong> . 这种现象多多少少是有些奇怪的, 按照一般的逻辑, 变量应该在声明语句之后才可以使用. </p><p>为了纠正这种现象, <code>let</code>、<code>const</code>命令改变了语法行为, 它所声明的变量一定要在声明后使用, 否则报错</p></blockquote><h3 id="Ⅰ-概括与总结"><a href="#Ⅰ-概括与总结" class="headerlink" title="Ⅰ-概括与总结"></a>Ⅰ-概括与总结</h3><blockquote><blockquote><p>声明</p></blockquote><ul><li> <strong>const命令</strong>: 声明常量</li><li> <strong>let命令</strong>: 声明变量</li></ul><blockquote><p>作用</p></blockquote><ol><li>作用域</li></ol><ul><li><strong>全局作用域</strong></li><li><strong>函数作用域</strong>: <code>function() &#123;&#125;</code></li><li><strong>块级作用域</strong>: <code>&#123;&#125;</code></li></ul><ol start="2"><li>作用范围</li></ol><ul><li><code>var命令</code>在全局代码中执行</li><li><code>const命令</code>和<code>let命令</code>只能在代码块中执行</li></ul><ol start="3"><li>赋值使用</li></ol><ul><li><code>const命令</code>声明常量后必须立马赋值</li><li><code>let命令</code>声明变量后可立马赋值或使用时赋值</li></ul><ol start="4"><li>声明方法: <code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></li></ol><blockquote><p>重点难点</p></blockquote><ul><li>不允许重复声明</li><li>未定义就使用会报错: <code>const命令</code>和<code>let命令</code>不存在变量提升</li><li>暂时性死区: 在代码块内使用<code>const命令</code>和<code>let命令</code>声明变量之前, 该变量都不可用</li></ul><p>下一节为赋值解构的概括总结  –&gt;<a href="#3%E3%80%81%E8%B5%8B%E5%80%BC%E8%A7%A3%E6%9E%84">点我传送</a></p></blockquote><h3 id="Ⅱ-let关键字命令"><a href="#Ⅱ-let关键字命令" class="headerlink" title="Ⅱ-let关键字命令"></a>Ⅱ-let关键字命令</h3><blockquote><p>let 关键字用来声明变量, 使用 let 声明的变量有几个特点:  </p><ul><li>不允许重复声明 </li><li>块级作用域 </li><li>不存在变量提升 </li><li>不影响作用域链</li></ul><p>应用场景: 声明重复赋值的变量时可以用这个,如果你不是要求很高的话,基本上都能用let进行声明(var声明的可以都用这个替代了)</p></blockquote><h3 id="Ⅲ-const关键字命令"><a href="#Ⅲ-const关键字命令" class="headerlink" title="Ⅲ-const关键字命令"></a>Ⅲ-const关键字命令</h3><blockquote><p>const 关键字用来声明<code>常量</code> ,<code>数组</code>或者<code>对象</code> const 声明有以下特点:</p><ul><li>不允许重复声明 </li><li><code>值不允许修改</code></li><li>不存在变量提升 </li><li>块级作用域 </li><li>声明<code>必须赋初始值</code></li><li>标识符一般为<code>大写</code></li></ul><p>注意: <code>对象属性修改和数组元素变化不会触发 const 错误</code><br>  const Tem = [‘ut’, ‘tut’, ‘tyty’]<br>  Tem.push(‘zz’)<br>  Tem = 100 // 报错<br>   console.log(Tem); //[‘ut’, ‘tut’, ‘tyty’,’zz’]</p><blockquote><p><code>const</code>实际上保证的, <code>并不是常量的值不得改动, 而是变量指向的那个内存地址所保存的数据不得改动</code>. </p><p>对于简单类型的数据（数值、字符串、布尔值）, 值就保存在变量指向的那个内存地址, 因此等同于常量. 但对于复合类型的数据（主要是对象和数组）, 变量指向的内存地址, 保存的只是一个指向实际数据的指针, <code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址）, 至于它指向的数据结构是不是可变的, 就完全不能控制了. 因此,<code> 将一个对象声明为常量必须非常小心</code>. </p></blockquote><p>应用场景: 声明对象类型、确定不会再次赋值的变量使用 const , 其他的可以用let</p></blockquote><h3 id="Ⅳ-ES6-声明变量的六种方法"><a href="#Ⅳ-ES6-声明变量的六种方法" class="headerlink" title="Ⅳ-ES6 声明变量的六种方法"></a>Ⅳ-ES6 声明变量的六种方法</h3><blockquote><p>ES5 只有两种声明变量的方法: <code>var</code>命令和<code>function</code>命令. ES6 除了添加<code>let</code>和<code>const</code>命令, 后面还会提到, 另外两种声明变量的方法: <code>import</code>命令和<code>class</code>命令. 所以 , ES6 一共有 6 种声明变量的方法. </p></blockquote><h3 id="Ⅴ-块级作用域"><a href="#Ⅴ-块级作用域" class="headerlink" title="Ⅴ-块级作用域"></a>Ⅴ-块级作用域</h3><h4 id="①-为什么需要块级作用域？"><a href="#①-为什么需要块级作用域？" class="headerlink" title="① 为什么需要块级作用域？"></a>① 为什么需要块级作用域？</h4><blockquote><p>ES5 只有全局作用域和函数作用域, 没有块级作用域, 这带来很多不合理的场景. </p><p>第一种场景, 内层变量可能会覆盖外层变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">var</span> tmp = <span class="string">&#x27;努力学习的汪&#x27;</span>; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/*********** 上面写法实际上等于这样 **********************/</span></span><br><span class="line">&gt;<span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> tmp = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">//所以这里打印是undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;  tmp = <span class="string">&#x27;努力学习的汪&#x27;</span>; &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码的原意是, <code>if</code>代码块的外部使用外层的<code>tmp</code>变量, 内部使用内层的<code>tmp</code>变量. 但是, 函数 [ <code>f</code> ] 执行后, 输出结果为 <strong>undefined</strong> , 原因在于变量提升, 导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量. </p><p>第二种场景, 用来计数的循环变量泄露为全局变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>i</code>只用来控制循环, 但是循环结束后, 它并没有消失, 泄露成了全局变量. </p></blockquote><h4 id="②-ES6-的块级作用域"><a href="#②-ES6-的块级作用域" class="headerlink" title="② ES6 的块级作用域"></a>② ES6 的块级作用域</h4><blockquote><p><code>let</code>实际上为 JavaScript 新增了块级作用域. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="keyword">let</span> n = <span class="number">10</span>; &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块, 都声明了变量<code>n</code>, 运行后输出 5. 这表示外层代码块不受内层代码块的影响. 如果两次都使用<code>var</code>定义变量<code>n</code>, 最后输出的值才是 10. </p><p>ES6 允许块级作用域的任意嵌套. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;&#123;&#123;&#123;</span><br><span class="line"> &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(insane); <span class="comment">// 报错 因为外层不能取到内层数据</span></span><br><span class="line">&gt;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域, 每一层都是一个单独的作用域. <code>第四层作用域无法读取第五层作用域的内部变量</code>. </p><p>内层作用域可以定义外层作用域的同名变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;&#123;&#123;&#123;</span><br><span class="line"> <span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"> &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125; <span class="comment">//可以这样命名,不会报错</span></span><br><span class="line">&gt;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>块级作用域的出现, 实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了. –&gt;<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">对于IIFE不懂的可以看本人JS进阶笔记,点我跳转</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// IIFE 写法</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> tmp ;</span><br><span class="line">      ...</span><br><span class="line">&gt;&#125;());</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 块级作用域写法</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">let</span> tmp ;</span><br><span class="line">      ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-块级作用域与函数声明"><a href="#③-块级作用域与函数声明" class="headerlink" title="③ 块级作用域与函数声明"></a>③ 块级作用域与函数声明</h4><blockquote><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题. </p><p>ES5 规定, 函数只能在顶层作用域和函数作用域之中声明, 不能在块级作用域声明. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 情况一</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况二</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面两种函数声明, 根据 ES5 的规定都是非法的. </p><p>但是, 浏览器没有遵守这个规定, 为了兼容以前的旧代码, 还是支持在块级作用域之中声明函数, 因此上面两种情况实际都能运行, 不会报错. </p><p>ES6 引入了块级作用域, 明确允许在块级作用域之中声明函数. ES6 规定, 块级作用域之中, 函数声明语句的行为类似于<code>let</code>, 在块级作用域之外不可引用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125;&#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在 ES5 中运行, 会得到“**我在里面!**”, 因为在<code>if</code>内声明的函数 [ f ] 会被提升到函数头部, 实际运行的代码如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 环境</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br></pre></td></tr></table></figure><p>ES6 就完全不一样了, 理论上会得到“**我在外面!**”. 因为块级作用域内声明的函数类似于<code>let</code>, 对作用域之外没有影响. 但是, 如果你真的在 ES6 浏览器中运行一下上面的代码, 是会报错的, 这是为什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125; &#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在 ES6 浏览器中, 都会报错. </p><p>原来, 如果改变了块级作用域内声明的函数的处理规则, 显然会对老代码产生很大影响. 为了减轻因此产生的不兼容问题 , ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定, 浏览器的实现可以不遵守上面的规定, 有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>. </p><ul><li>允许在块级作用域内声明函数. </li><li>函数声明类似于<code>var</code>, 即会提升到全局作用域或函数作用域的头部. </li><li>同时, 函数声明还会提升到所在的块级作用域的头部. </li></ul><p>注意, 上面三条规则只对 ES6 的浏览器实现有效, 其他环境的实现不用遵守, 还是将块级作用域的函数声明当作<code>let</code>处理. </p><p>根据这三条规则, 浏览器的 ES6 环境中, 块级作用域内声明的函数, 行为类似于<code>var</code>声明的变量. 上面的栗子实际运行的代码如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125;&#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大, 应该<code>避免在块级作用域内声明函数</code>. 如果确实需要, 也应该写成函数表达式, 而不是函数声明语句. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 块级作用域内部的函数声明语句, 建议不要使用</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> a; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 块级作用域内部, 优先使用函数表达式</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line"> <span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>另外, 还有一个需要注意的地方. ES6 的块级作用域必须有大括号, 如果没有大括号 , JavaScript 引擎就认为不存在块级作用域. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 第一种写法, 报错</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第二种写法, 不报错</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 第一种写法没有大括号, 所以不存在块级作用域, 而<code>let</code>只能出现在当前作用域的顶层, 所以报错. 第二种写法有大括号, 所以块级作用域成立. </p><p>函数声明也是如此, 严格模式下, 函数只能声明在当前作用域的顶层. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 不报错</span></span><br><span class="line">&gt;<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、赋值解构"><a href="#3、赋值解构" class="headerlink" title="3、赋值解构"></a>3、赋值解构</h2><blockquote><p>ES6 允许按照一定模式, <code>从数组和对象中提取值, 对变量进行赋值</code>, 这被称为解构（Destructuring）. </p><p>本质上, 这种写法属于“<code>模式匹配</code>”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值</p></blockquote><h3 id="Ⅰ-概括总结"><a href="#Ⅰ-概括总结" class="headerlink" title="Ⅰ-概括总结"></a>Ⅰ-概括总结</h3><blockquote><ol><li> <strong>字符串解构</strong>: <code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li> <strong>数值解构</strong>: <code>const &#123; toString: s &#125; = 123</code></li><li> <strong>布尔解构</strong>: <code>const &#123; toString: b &#125; = true</code></li><li><strong>对象解构</strong></li></ol><ul><li>形式: <code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li><li>默认: <code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li><li>改名: <code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li></ul><ol start="5"><li><strong>数组解构</strong></li></ol><ul><li>规则: 数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>形式: <code>const [x, y] = [1, 2]</code></li><li>默认: <code>const [x, y = 2] = [1]</code></li></ul><ol start="6"><li><strong>函数参数解构</strong></li></ol><ul><li>数组解构: <code>function Func([x = 0, y = 1]) &#123;&#125;</code></li><li>对象解构: <code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li></ul><blockquote><p><code>应用场景</code> </p></blockquote><ul><li>交换变量值: <code>[x, y] = [y, x]</code></li><li>返回函数多个值: <code>const [x, y, z] = Func()</code></li><li>定义函数参数: <code>Func([1, 2])</code></li><li>提取JSON数据: <code>const &#123; name, version &#125; = packageJson</code></li><li>定义函数参数默认值: <code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>遍历Map结构: <code>for (let [k, v] of Map) &#123;&#125;</code></li><li>输入模块指定属性和方法: <code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li></ul><blockquote><p> ** <code>重点难点</code> **</p></blockquote><ul><li>匹配模式: 只要等号两边的模式相同, 左边的变量就会被赋予对应的值</li><li>解构赋值规则: 只要等号右边的值不是对象或数组, 就先将其转为对象</li><li>解构默认值生效条件: 属性值严格等于 <strong>undefined</strong> </li><li>解构遵循匹配模式</li><li>解构不成功时变量的值等于 <strong>undefined</strong> </li><li> <strong>undefined</strong> 和 <strong>null</strong> 无法转为对象, 因此无法进行解构</li></ul><p>下一节为字符串的拓展概括  –&gt;<a href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%93%E5%B1%95">点我传送</a></p></blockquote><h3 id="Ⅱ-基本用法"><a href="#Ⅱ-基本用法" class="headerlink" title="Ⅱ-基本用法"></a>Ⅱ-基本用法</h3><h4 id="①-基本用法举例"><a href="#①-基本用法举例" class="headerlink" title="① 基本用法举例"></a>① 基本用法举例</h4><blockquote><p>以前, 为变量赋值, 只能直接指定值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面代码表示, 可以从数组中提取值, 按照对应位置, 对变量赋值. </p><p>本质上, 这种写法属于“模式匹配”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值. 下面是一些使用嵌套数组进行解构的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];<span class="comment">//foo : 1 bar : 2 baz : 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];<span class="comment">//third : &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//x : 1 y : 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="comment">//head : 1 tail : [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];<span class="comment">//x : &quot;a&quot; y : undefined z : []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功, 变量的值就等于 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [foo] = [];</span><br><span class="line">&gt;<span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功, <code>foo</code>的值都会等于 <strong>undefined</strong> . </p><p>另一种情况是不完全解构, 即等号左边的模式, 只匹配一部分的等号右边的数组. 这种情况下, 解构依然可以成功. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//x : 1  y : 2 </span></span><br><span class="line">&gt;<span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];<span class="comment">//a : 1 b : 2 d : 4</span></span><br></pre></td></tr></table></figure><p>上面两个栗子, 都属于不完全解构, 但是可以成功. </p><p>如果等号的右边不是数组（或者严格地说, 不是可遍历的结构, 参见《Iterator》一章）, 那么将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="title class_">NaN</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的语句都会报错, 因为等号右边的值, 要么转为对象以后不具备 Iterator 接口（前五个表达式）, 要么本身就不具备 Iterator 接口（最后一个表达式）. </p><p><code>对于 Set 结构, 也可以使用数组的解构赋值</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">&gt;x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>事实上, 只要某种数据结构具有 Iterator 接口, 都可以采用数组形式的解构赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">fibs</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">yield</span> a;</span><br><span class="line">   [a, b] = [b, a + b];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fibs</span>();</span><br><span class="line">&gt;sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>fibs</code>是一个 Generator 函数（详见《Generator 函数》）, 原生具有 Iterator 接口. 解构赋值会依次从这个接口获取值. </p></blockquote><h4 id="②-默认值"><a href="#②-默认值" class="headerlink" title="② 默认值"></a>② 默认值</h4><blockquote><p>解构赋值允许指定默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];<span class="comment">//foo = true</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>注意 , ES6 内部使用严格相等运算符（<code>===</code>）, 判断一个位置是否有值. 所以, 只有当一个数组成员严格等于 <strong>undefined</strong> , 默认值才会生效. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">//x = 1</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];<span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><p>上面代码中, 如果一个数组成员是 <strong>null</strong> , 默认值就不会生效, 因为 <strong>null</strong> 不严格等于 <strong>undefined</strong> . </p><p>如果默认值是一个表达式, 那么这个表达式是惰性求值的, 即只有在用到的时候, 才会求值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaa&#x27;</span>);&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="title function_">f</span>()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面代码中, 因为<code>x</code>能取到值, 所以函数 [ f ] 根本不会执行. 上面的代码其实等价于下面的代码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x;</span><br><span class="line">&gt;<span class="keyword">if</span> ([<span class="number">1</span>] === <span class="literal">undefined</span>) &#123; x = <span class="title function_">f</span>()&#125; </span><br><span class="line">&gt;<span class="keyword">else</span> &#123; x = [<span class="number">1</span>]; &#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量, 但该变量必须已经声明. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错, 是因为<code>x</code>用<code>y</code>做默认值时, <code>y</code>还没有声明. </p></blockquote><h4 id="③-ES6小知识点-连续赋值解构-重命名"><a href="#③-ES6小知识点-连续赋值解构-重命名" class="headerlink" title="③ ES6小知识点:连续赋值解构+重命名"></a>③ ES6小知识点:<code>连续赋值解构</code>+重命名</h4><blockquote><p>此写法也是本人常用写法,挺好用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> &#123;a&#125; = obj; <span class="comment">//传统解构赋值</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;b&#125;&#125; = obj; <span class="comment">//连续解构赋值</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:value&#125;&#125; = obj; <span class="comment">//连续解构赋值+重命名</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-对象的赋值解构"><a href="#Ⅲ-对象的赋值解构" class="headerlink" title="Ⅲ-对象的赋值解构"></a>Ⅲ-对象的赋值解构</h3><blockquote><p><code>此处应用的非常多</code>,需要多查阅</p></blockquote><h4 id="①-基本用法"><a href="#①-基本用法" class="headerlink" title="① 基本用法"></a>① 基本用法</h4><blockquote><p>解构不仅可以用于数组, 还可以用于对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//foo = &quot;aaa&quot;; bar = &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同. <code>数组的元素是按次序排列的, 变量的取值由它的位置决定；而对象的属性没有次序, 变量必须与属性同名, 才能取到正确的值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//foo = &quot;aaa&quot; ; bar = &quot;bbb&quot;</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//baz = undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个栗子, 等号左边的两个变量的次序, 与等号右边两个同名属性的次序不一致, 但是对取值完全没有影响. 第二个栗子的变量没有对应的同名属性, 导致取不到值, 最后等于 <strong>undefined</strong> . </p><p>如果解构失败, 变量的值等于 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;<span class="comment">//foo = undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 等号右边的对象没有<code>foo</code>属性, 所以变量<code>foo</code>取不到值, 所以等于 <strong>undefined</strong> . </p><p>对象的解构赋值, 可以很方便地将现有对象的方法, 赋值到某个变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="title class_">Math</span>;</span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123; log &#125; = <span class="variable language_">console</span>;</span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法, 赋值到对应的变量上, 使用起来就会方便很多. 例二将<code>console.log</code>赋值到<code>log</code>变量. </p><p>如果变量名与属性名不一致, 必须写成下面这样–&gt;<code>取别名</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//baz = &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;<span class="comment">//f = &#x27;hello&#x27; ; l = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>这实际上说明, 对象的解构赋值是下面形式的简写（详见《对象的扩展》）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说, 对象的解构赋值的内部机制, 是先找到同名属性, 然后再赋给对应的变量. 真正被赋值的是后者, 而不是前者. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="comment">//baz = &quot;aaa&quot;;</span></span><br><span class="line">&gt;<span class="comment">//foo = error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>foo</code>是匹配的模式, <code>baz</code>才是变量. 真正被赋值的是变量<code>baz</code>, 而不是模式<code>foo</code>. </p><p>与数组一样, 解构也可以用于嵌套结构的对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="attr">p</span>: [<span class="string">&#x27;Hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;]</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">&gt;<span class="comment">//x == &quot;Hello&quot;</span></span><br><span class="line">&gt;<span class="comment">//y == &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>注意, 这时<code>p</code>是模式, 不是变量, 因此不会被赋值. 如果<code>p</code>也要作为变量赋值, 可以写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="attr">p</span>: [ <span class="string">&#x27;Hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;]</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">&gt;<span class="comment">//x == &quot;Hello&quot;</span></span><br><span class="line">&gt;<span class="comment">//y == &quot;World&quot;</span></span><br><span class="line">&gt;<span class="comment">//p == [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> node = &#123;</span><br><span class="line"> <span class="attr">loc</span>: &#123; </span><br><span class="line">     <span class="attr">start</span>: &#123; <span class="attr">line</span>: <span class="number">1</span>, <span class="attr">column</span>: <span class="number">5</span> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">&gt;<span class="comment">//line == 1</span></span><br><span class="line">&gt;<span class="comment">//loc  == Object &#123;start: Object&#125;</span></span><br><span class="line">&gt;<span class="comment">//start == Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码有三次解构赋值, 分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值. 注意, 最后一次对<code>line</code>属性的解构赋值之中, 只有<code>line</code>是变量, <code>loc</code>和<code>start</code>都是模式, 不是变量. </p><p>下面是嵌套赋值的栗子. –&gt;<code>注意:外部包着一层()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [];</span><br><span class="line">&gt;(&#123; <span class="attr">foo</span>: obj.<span class="property">prop</span>, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&gt;<span class="comment">//因为 JavaScript 引擎会将`&#123;x&#125;`理解成一个代码块, 从而发生语法错误. `只有不将大括号写在行首`, 避免 JavaScript 将其解释为代码块, 才能解决这个问题. </span></span><br><span class="line">&gt;<span class="comment">//obj == &#123;prop:123&#125;</span></span><br><span class="line">&gt;<span class="comment">//arr == [true]</span></span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象, 而且子对象所在的父属性不存在, 那么将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, 等号左边对象的<code>foo</code>属性, 对应一个子对象. 该子对象的<code>bar</code>属性, 解构时会报错. 原因很简单, 因为<code>foo</code>这时等于 <strong>undefined</strong> , 再取子属性就会报错. </p><p>注意, 对象的解构赋值可以取到继承的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj1, obj2);<span class="comment">//Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">&gt;foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>obj1</code>的原型对象是<code>obj2</code>. <code>foo</code>属性不是<code>obj1</code>自身的属性, 而是继承自<code>obj2</code>的属性, 解构赋值可以取到这个属性. </p><p>注:<code>Object.setPrototypeOf()</code>详解,不知道此方法的同学们看这里 –&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">点我传送</a></p></blockquote><h4 id="②-默认值-1"><a href="#②-默认值-1" class="headerlink" title="② 默认值"></a>② 默认值</h4><blockquote><p>对象的解构也可以指定默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;<span class="comment">//x == 3</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="comment">//x == 1</span></span><br><span class="line">&gt;<span class="comment">//y == 5</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;<span class="comment">//y == 3</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;<span class="comment">//y == 5</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;<span class="comment">//msg == &quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是, 对象的属性值严格等于 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;<span class="comment">//x == 3</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;<span class="comment">//x == null</span></span><br></pre></td></tr></table></figure><p>上面代码中, 属性<code>x</code>等于 <strong>null</strong> , 因为 <strong>null</strong> 与 <strong>undefined</strong> 不严格相等, 所以是个有效的赋值, 导致默认值<code>3</code>不会生效. –&gt;[原因上面讲过](#② 默认值)</p></blockquote><h4 id="③-注意点"><a href="#③-注意点" class="headerlink" title="③ 注意点"></a>③ 注意点</h4><blockquote><p>（1）如果要将一个已经声明的变量用于解构赋值, 必须非常小心. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 错误的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> x;</span><br><span class="line">&gt;&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错, 因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个代码块, 从而发生语法错误. <code>只有不将大括号写在行首</code>, 避免 JavaScript 将其解释为代码块, 才能解决这个问题. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正确的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> x;</span><br><span class="line">&gt;(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句, <code>放在一个圆括号里面, 就可以正确执行</code>. 关于圆括号与解构赋值的关系, 参见下文. </p><p>（2）解构赋值允许等号左边的模式之中, 不放置任何变量名. 因此, 可以写出非常古怪的赋值表达式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">&gt;(&#123;&#125; = <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&gt;(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义, 但是语法是合法的, 可以执行. </p><p>（3）<code>由于数组本质是特殊的对象, 因此可以对数组进行对象属性的解构</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.<span class="property">length</span> - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">&gt;<span class="comment">//first == 1</span></span><br><span class="line">&gt;<span class="comment">//last == 3</span></span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构. 数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>, <code>[arr.length - 1]</code>就是<code>2</code>键, 对应的值是<code>3</code>. 方括号这种写法, 属于“属性名表达式”（详见《对象的扩展》）. </p></blockquote><h3 id="Ⅳ-字符串的赋值结构"><a href="#Ⅳ-字符串的赋值结构" class="headerlink" title="Ⅳ-字符串的赋值结构"></a>Ⅳ-字符串的赋值结构</h3><blockquote><p>字符串也可以解构赋值. 这是因为此时, 字符串被转换成了一个类似数组的对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">//a == &quot;h&quot; ;b  == &quot;e&quot; ; c == &quot;l&quot; ; d == &quot;l&quot; ;e == &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个<code>length</code>属性, 因此还可以对这个属性解构赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;length : len&#125; = <span class="string">&#x27;hello&#x27;</span>;<span class="comment">//len == 5</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-数值和布尔值的解构赋值"><a href="#Ⅴ-数值和布尔值的解构赋值" class="headerlink" title="Ⅴ-数值和布尔值的解构赋值"></a>Ⅴ-数值和布尔值的解构赋值</h3><blockquote><p>解构赋值时, 如果等号右边是数值和布尔值, 则会先转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">&gt;s === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">&gt;s === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 数值和布尔值的包装对象都有<code>toString</code>属性, 因此变量<code>s</code>都能取到值. </p><p>解构赋值的规则是, 只要等号右边的值不是对象或数组, 就先将其转为对象. 由于 <strong>undefined</strong> 和 <strong>null</strong> 无法转为对象, 所以对它们进行解构赋值, 都会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅵ-函数参数的解构赋值"><a href="#Ⅵ-函数参数的解构赋值" class="headerlink" title="Ⅵ-函数参数的解构赋值"></a>Ⅵ-函数参数的解构赋值</h3><blockquote><p>函数的参数也可以使用解构赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">[x, y]</span>)&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&gt;<span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>add</code>的参数表面上是一个数组, 但在传入参数的那一刻, 数组参数就被解构成变量<code>x</code>和<code>y</code>. 对于函数内部的代码来说, 它们能感受到的参数就是<code>x</code>和<code>y</code>. </p><p>下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">map</span>(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line">&gt;<span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123;  <span class="keyword">return</span> [x, y];&#125;</span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>move</code>的参数是一个对象, 通过对这个对象进行解构, 得到变量<code>x</code>和<code>y</code>的值. 如果解构失败, <code>x</code>和<code>y</code>等于默认值. </p><p>注意, 下面的写法会得到不一样的结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> [x, y];</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值, 而不是为变量<code>x</code>和<code>y</code>指定默认值, 所以会得到与前一种写法不同的结果. </p><p><strong>undefined</strong> 就会触发函数参数的默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line">&gt;<span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅶ-圆括号问题"><a href="#Ⅶ-圆括号问题" class="headerlink" title="Ⅶ-圆括号问题"></a>Ⅶ-圆括号问题</h3><blockquote><p>解构赋值虽然很方便, 但是解析起来并不容易. 对于编译器来说, <code>一个式子到底是模式, 还是表达式</code>, 没有办法从一开始就知道, 必须解析到（或解析不到）等号才能知道. </p><p>由此带来的问题是, 如果模式中出现圆括号怎么处理. ES6 的规则是, 只要有可能导致解构的歧义, 就不得使用圆括号. </p><p>但是, 这条规则实际上不那么容易辨别, 处理起来相当麻烦. 因此, 建议只要有可能, 就不要在模式中放置圆括号. </p></blockquote><h4 id="①-不能使用圆括号的情况"><a href="#①-不能使用圆括号的情况" class="headerlink" title="① 不能使用圆括号的情况"></a>① 不能使用圆括号的情况</h4><blockquote><p>以下三种解构赋值不得使用圆括号. </p><p>（1）<code>变量声明</code>语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 全部报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;(<span class="attr">x</span>: c)&#125; = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>上面 6 个语句都会报错, <code>因为它们都是变量声明语句</code>, 模式不能使用圆括号. </p><p>（2）函数参数</p><p>函数参数也属于变量声明, 因此不能带有圆括号. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[(z)]</span>) &#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[z,(x)]</span>) &#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>（3）赋值语句的模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 全部报错</span></span><br><span class="line">&gt;(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中, 导致报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将一部分模式放在圆括号之中, 导致报错. </p></blockquote><h4 id="②-可以使用圆括号的情况"><a href="#②-可以使用圆括号的情况" class="headerlink" title="② 可以使用圆括号的情况"></a>② 可以使用圆括号的情况</h4><blockquote><p>可以使用圆括号的情况只有一种: 赋值语句的非模式部分, 可以使用圆括号. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">&gt;(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">&gt;[(<span class="built_in">parseInt</span>.<span class="property">prop</span>)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行, 因为<code>首先它们都是赋值语句, 而不是声明语句</code>；其次它们的圆括号都不属于模式的一部分. 第一行语句中, 模式是取数组的第一个成员, 跟圆括号无关；第二行语句中, 模式是<code>p</code>, 而不是<code>d</code>；第三行语句与第一行语句的性质一致. </p></blockquote><h3 id="Ⅷ-具体应用场景举例"><a href="#Ⅷ-具体应用场景举例" class="headerlink" title="Ⅷ-具体应用场景举例"></a>Ⅷ-具体应用场景举例</h3><blockquote><p>变量的解构赋值用途很多</p></blockquote><h4 id="①-交换变量的值"><a href="#①-交换变量的值" class="headerlink" title="① 交换变量的值"></a>① 交换变量的值</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">&gt;[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量<code>x</code>和<code>y</code>的值, 这样的写法不仅简洁, 而且易读, 语义非常清晰. </p></blockquote><h4 id="②-从函数返回多个值"><a href="#②-从函数返回多个值" class="headerlink" title="② 从函数返回多个值"></a>② 从函数返回多个值</h4><blockquote><p>函数只能返回一个值, 如果要返回多个值, 只能将它们放在数组或对象里返回. 有了解构赋值, 取出这些值就非常方便. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 返回一个数组</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; &#125;</span><br><span class="line">&gt;<span class="keyword">let</span> [a, b, c] = <span class="title function_">example</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 返回一个对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="number">1</span>,<span class="attr">bar</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">example</span>();</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-函数参数的定义"><a href="#③-函数参数的定义" class="headerlink" title="③ 函数参数的定义"></a>③ 函数参数的定义</h4><blockquote><p>解构赋值可以方便地将一组参数与变量名对应起来. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 参数是一组有次序的值</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, z]</span>) &#123; ... &#125;</span><br><span class="line">&gt;<span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 参数是一组无次序的值</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123;x, y, z&#125;</span>) &#123; ... &#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-提取-JSON-数据"><a href="#④-提取-JSON-数据" class="headerlink" title="④  提取 JSON 数据"></a>④  提取 JSON 数据</h4><blockquote><p>解构赋值对提取 JSON 对象中的数据, 尤其有用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> jsonData = &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line"> <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line"> <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(id, status, number);</span><br><span class="line">&gt;<span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p>上面代码可以快速提取 JSON 数据的值. </p></blockquote><h4 id="⑤-函数参数的默认值"><a href="#⑤-函数参数的默认值" class="headerlink" title="⑤  函数参数的默认值"></a>⑤  函数参数的默认值</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params"> <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params"> beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params"> cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params"> complete = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params"> crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params"> <span class="variable language_">global</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params"> // ... more config</span></span><br><span class="line"><span class="params">&gt;&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line"> <span class="comment">// ... do stuff</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值, 就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句. </p></blockquote><h4 id="⑥-遍历-Map-结构"><a href="#⑥-遍历-Map-结构" class="headerlink" title="⑥ 遍历 Map 结构"></a>⑥ 遍历 Map 结构</h4><blockquote><p>任何部署了 Iterator 接口的对象, 都可以用<code>for...of</code>循环遍历. Map 结构原生支持 Iterator 接口, 配合变量的解构赋值, 获取键名和键值就非常方便. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// first is hello</span></span><br><span class="line">&gt;<span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>如果只想获取键名, 或者只想获取键值, 可以写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 获取键名</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 获取键值</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑦-输入模块的指定方法"><a href="#⑦-输入模块的指定方法" class="headerlink" title="⑦ 输入模块的指定方法"></a>⑦ 输入模块的指定方法</h4><blockquote><p>加载模块时, 往往需要指定输入哪些方法. 解构赋值使得输入语句非常清晰. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> &#123; <span class="title class_">SourceMapConsumer</span>, <span class="title class_">SourceNode</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="4、字符串的拓展"><a href="#4、字符串的拓展" class="headerlink" title="4、字符串的拓展"></a>4、字符串的拓展</h2><h3 id="Ⅰ-概括总结-1"><a href="#Ⅰ-概括总结-1" class="headerlink" title="Ⅰ-概括总结"></a>Ⅰ-概括总结</h3><blockquote><ul><li><p> <strong>Unicode表示法</strong>: <code>大括号包含</code>表示Unicode字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</p></li><li><p> <strong>字符串遍历</strong>: 可通过 [ for-of ] 遍历字符串</p></li><li><p> <strong>字符串模板</strong>: 可单行可多行可插入变量的增强版字符串</p></li><li><p> <strong>标签模板</strong>: 函数参数的特殊调用</p></li><li><p> <strong>String.raw()</strong>: 返回把字符串所有变量替换且对斜杠进行转义的结果</p></li><li><p> <strong>String.fromCodePoint()</strong>: 返回码点对应字符</p></li><li><p> <strong>codePointAt()</strong>: 返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</p></li><li><p> <strong>normalize()</strong>: 把字符的不同表示方法统一为同样形式, 返回<code>新字符串</code>(Unicode正规化)</p></li><li><p> <strong>repeat()</strong>: 把字符串重复n次, 返回<code>新字符串</code></p></li><li><p> <strong>matchAll()</strong>: 返回正则表达式在字符串的所有匹配</p></li><li><p> <strong>includes()</strong>: 是否存在指定字符串</p></li><li><p> <strong>startsWith()</strong>: 是否存在字符串头部指定字符串</p></li><li><p> <strong>endsWith()</strong>: 是否存在字符串尾部指定字符串</p></li><li><p>以上扩展方法均可作用于由<code>4个字节储存</code>的<code>Unicode字符</code>上</p></li></ul></blockquote><h3 id="Ⅱ-模板字符串"><a href="#Ⅱ-模板字符串" class="headerlink" title="Ⅱ-模板字符串"></a>Ⅱ-模板字符串</h3><blockquote><p>模板字符串（template string）是增强版的字符串, 用反引号[ <code> </code> ]标识. 它可以当作普通字符串使用, 也可以用来<code>定义多行字符串</code>, 或者在字符串中嵌入变量.</p></blockquote><blockquote><p>嵌入变量使用[<code>$&#123;变量名&#125;</code>]:如果大括号中的值不是字符串, 将按照一般的规则转为字符串. 比如, 大括号中是一个对象, 将默认调用对象的<code>toString</code>方法. 如果大括号内部是一个字符串, 将会原样输出. </p></blockquote><h4 id="①-字符串中可以出现换行符"><a href="#①-字符串中可以出现换行符" class="headerlink" title="① 字符串中可以出现换行符"></a>① 字符串中可以出现换行符</h4><blockquote><p>字符串中可以出现换行符:如果使用模板字符串表示多行字符串, 所有的空格和缩进都会被保留在输出之中. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//代码中, 所有模板字符串的空格和换行, 都是被保留的, 比如`&lt;ul&gt;`标签前面会有一个换行. 如果你不想要这个换行, 可以使用`trim`方法消除它. </span></span><br><span class="line">&gt;$(<span class="string">&#x27;#list&#x27;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&gt;&lt;ul&gt;</span></span><br><span class="line"><span class="string"> &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string"> &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt;&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt;`</span>.<span class="title function_">trim</span>());</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-可以使用-xxx-形式输出变量-变量拼接"><a href="#②-可以使用-xxx-形式输出变量-变量拼接" class="headerlink" title="② 可以使用 ${xxx} 形式输出变量,变量拼接"></a>② 可以使用 ${xxx} 形式输出变量,变量拼接</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">authorize</span>(<span class="params">user, action</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!user.<span class="title function_">hasPrivilege</span>(action)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">     <span class="comment">// 传统写法为</span></span><br><span class="line">     <span class="comment">// &#x27;User &#x27;</span></span><br><span class="line">     <span class="comment">// + user.name</span></span><br><span class="line">     <span class="comment">// + &#x27; is not authorized to do &#x27;</span></span><br><span class="line">     <span class="comment">// + action</span></span><br><span class="line">     <span class="comment">// + &#x27;.&#x27;</span></span><br><span class="line">     <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-大括号内部可以放入任意的-JavaScript-表达式"><a href="#③-大括号内部可以放入任意的-JavaScript-表达式" class="headerlink" title="③ 大括号内部可以放入任意的 JavaScript 表达式"></a>③ 大括号内部可以放入任意的 JavaScript 表达式</h4><blockquote><p>括号内部可以放入任意的 JavaScript 表达式, 可以进行运算, 以及引用对象属性. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span><span class="comment">// &quot;1 + 2 = 3&quot;</span></span><br><span class="line">&gt;<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span><span class="comment">// &quot;1 + 4 = 5&quot;</span></span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;<span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span><span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-模板字符串之中还能调用函数"><a href="#④-模板字符串之中还能调用函数" class="headerlink" title="④ 模板字符串之中还能调用函数."></a>④ 模板字符串之中还能调用函数.</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;&#125;</span><br><span class="line">&gt;<span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line">&gt;<span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-字符串嵌套"><a href="#⑤-字符串嵌套" class="headerlink" title="⑤ 字符串嵌套"></a>⑤ 字符串嵌套</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">tmpl</span> = addrs =&gt; <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;table&gt;</span></span><br><span class="line"><span class="string"> <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"> `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string"> &lt;/table&gt;</span></span><br><span class="line"><span class="string">&gt;`</span>;</span><br></pre></td></tr></table></figure><p>上面代码中, 模板字符串的变量之中, 又嵌入了另一个模板字符串, 使用方法如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> data = [</span><br><span class="line">   &#123; <span class="attr">first</span>: <span class="string">&#x27;&lt;Jane&gt;&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Bond&#x27;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">first</span>: <span class="string">&#x27;Lars&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;&lt;Croft&gt;&#x27;</span> &#125;,</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">tmpl</span>(data));</span><br><span class="line">&gt;<span class="comment">/**下面是打印结果</span></span><br><span class="line"><span class="comment">&gt;&lt;table&gt;</span></span><br><span class="line"><span class="comment">  &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"> &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">  &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身, 在需要时执行, 可以写成函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">name</span>) =&gt; <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&gt;<span class="title function_">func</span>(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 模板字符串写成了一个函数的返回值. 执行这个函数, 就相当于执行这个模板字符串了. </p></blockquote><h3 id="Ⅲ-标签模板"><a href="#Ⅲ-标签模板" class="headerlink" title="Ⅲ-标签模板"></a>Ⅲ-标签模板</h3><blockquote><p>模板字符串的功能, 不仅仅是上面这些. 它可以紧跟在一个函数名后面, 该函数将被调用来处理这个模板字符串. 这被称为“<code>标签模板</code>”功能（tagged template`）.   –&gt;反正我是很少用到,可阅读性较差</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>([<span class="string">&#x27;hello&#x27;</span>])</span><br></pre></td></tr></table></figure></blockquote><h4 id="①-简单实例"><a href="#①-简单实例" class="headerlink" title="① 简单实例"></a>① 简单实例</h4><blockquote><p>标签模板其实不是模板, 而是函数调用的一种特殊形式. <code>[标签]指的就是函数</code>, 紧跟在后面的模板字符串就是它的参数. </p><p>但是, 如果模板字符里面有变量, 就不是简单的调用了, 而是会将模板字符串先处理成多个参数, 再调用函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>,  <span class="string">&#x27; &#x27;</span>  ], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 模板字符串前面有一个标识名<code>tag</code>, 它是一个函数. 整个表达式的返回值, 就是<code>tag</code>函数处理模板字符串后的返回值. </p><p>函数<code>tag</code>依次会接收到多个参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, value1, value2</span>)&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, ...values</span>)&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>tag</code>函数的第一个参数是一个数组, <code>该数组的成员是模板字符串中那些没有变量替换的部分</code>, 也就是说, 变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间, 以此类推. </p><p><code>tag</code>函数的其他参数, 都是模板字符串各个变量被替换后的值. 由于本例中, 模板字符串含有两个变量, 因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数. </p><p><code>tag</code>函数所有参数的实际值如下. </p><ul><li>第一个参数: <code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li><li>第二个参数: 15</li><li>第三个参数: 50</li></ul><p>也就是说, <code>tag</code>函数实际上以下面的形式调用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>我们可以按照需要编写<code>tag</code>函数的代码. 下面是<code>tag</code>函数的一种写法, 以及运行结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">s, v1, v2</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">0</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">1</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">2</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v1);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v2);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line">&gt;<span class="comment">// &quot;Hello &quot;</span></span><br><span class="line">&gt;<span class="comment">// &quot; world &quot;</span></span><br><span class="line">&gt;<span class="comment">// &quot;&quot;</span></span><br><span class="line">&gt;<span class="comment">// 15</span></span><br><span class="line">&gt;<span class="comment">// 50</span></span><br><span class="line">&gt;<span class="comment">// &quot;OK&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-稍微复杂的栗子"><a href="#②-稍微复杂的栗子" class="headerlink" title="② 稍微复杂的栗子"></a>② 稍微复杂的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">passthru</span>(<span class="params">literals</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="keyword">while</span> (i &lt; literals.<span class="property">length</span>) &#123;</span><br><span class="line"> result += literals[i++];</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    result += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br><span class="line"> </span><br><span class="line">&gt;msg <span class="comment">// &quot;The total is 30 (31.5 with tax)&quot;</span></span><br></pre></td></tr></table></figure><p>上面这个栗子展示了, 如何将各个参数按照原来的位置拼合回去. </p><p><code>passthru</code>函数采用 rest 参数的写法如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">passthru</span>(<span class="params">literals, ...values</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> index;</span><br><span class="line"> <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.<span class="property">length</span>; index++) &#123;</span><br><span class="line"> output += literals[index] + values[index];</span><br><span class="line"> &#125;</span><br><span class="line">   output += literals[index]</span><br><span class="line"> <span class="keyword">return</span> output;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用, 就是过滤 HTML 字符串, 防止用户输入恶意内容. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> message =</span><br><span class="line">&gt;<span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">SaferHTML</span>(<span class="params">templateData</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> arg = <span class="title class_">String</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">   s += arg.<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">      .<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">          .<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">&gt;&#125;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>sender</code>变量往往是用户提供的, 经过<code>SaferHTML</code>函数处理, 里面的特殊字符都会被转义. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line">&gt;<span class="keyword">let</span> message = <span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">&gt;message</span><br><span class="line">&gt;<span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-用作多语言转换（国际化处理）"><a href="#③-用作多语言转换（国际化处理）" class="headerlink" title="③ 用作多语言转换（国际化处理）"></a>③ 用作多语言转换（国际化处理）</h4><blockquote><p>标签模板的另一个应用, 就是多语言转换（国际化处理）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line">&gt;<span class="comment">// &quot;欢迎访问xxx , 您是第xxxx位访问者！&quot;</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代 Mustache 之类的模板库, 因为没有条件判断和循环处理功能, 但是通过标签函数, 你可以自己添加这些功能. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line">&gt;<span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line">&gt;<span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;ul&gt;</span></span><br><span class="line"><span class="string">   #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">     &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">   #end</span></span><br><span class="line"><span class="string"> &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt;`</span>;</span><br></pre></td></tr></table></figure><p>除此之外, 你甚至可以使用标签模板, 在 JavaScript 语言之中嵌入其他语言. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;jsx<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt;</span></span><br><span class="line"><span class="string">   &lt;input</span></span><br><span class="line"><span class="string">     ref=&#x27;input&#x27;</span></span><br><span class="line"><span class="string">     onChange=&#x27;<span class="subst">$&#123;<span class="variable language_">this</span>.handleChange&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">     defaultValue=&#x27;<span class="subst">$&#123;<span class="variable language_">this</span>.state.value&#125;</span>&#x27; /&gt;</span></span><br><span class="line"><span class="string">     <span class="subst">$&#123;<span class="variable language_">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&gt;`</span></span><br></pre></td></tr></table></figure><p>上面的代码通过<code>jsx</code>函数, 将一个 DOM 字符串转为 React 对象. </p><p>下面则是一个假想的栗子, 通过<code>java</code>函数, 在 JavaScript 代码之中运行 Java 代码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;java<span class="string">`</span></span><br><span class="line"><span class="string">&gt;class HelloWorldApp &#123;</span></span><br><span class="line"><span class="string"> public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">   System.out.println(&quot;Hello World!&quot;); // Display the string.</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&gt;&#125;</span></span><br><span class="line"><span class="string">&gt;`</span></span><br><span class="line">&gt;<span class="title class_">HelloWorldApp</span>.<span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组）, 还有一个<code>raw</code>属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">console</span>.<span class="property">log</span><span class="string">`123`</span></span><br><span class="line">&gt;<span class="comment">// [&quot;123&quot;, raw: Array[1]]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>console.log</code>接受的参数, 实际上是一个数组. 该数组有一个<code>raw</code>属性, 保存的是转义后的原字符串. </p><p>请看下面的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">strings</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(strings.<span class="property">raw</span>[<span class="number">0</span>]);</span><br><span class="line"> <span class="comment">// strings.raw[0] 为 &quot;First line\\nSecond line&quot;</span></span><br><span class="line"> <span class="comment">// 打印输出 &quot;First line\nSecond line&quot;</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>tag</code>函数的第一个参数<code>strings</code>, 有一个<code>raw</code>属性, 也指向一个数组. 该数组的成员与<code>strings</code>数组完全一致. 比如, <code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>, 那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>. 两者唯一的区别, 就是字符串里面的斜杠都被转义了. 比如 , strings.raw 数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符, 而不是换行符. 这是为了方便取得转义之前的原始模板而设计的. </p></blockquote><h2 id="5、数值的拓展"><a href="#5、数值的拓展" class="headerlink" title="5、数值的拓展"></a>5、数值的拓展</h2><h3 id="Ⅰ-概括总结-2"><a href="#Ⅰ-概括总结-2" class="headerlink" title="Ⅰ- 概括总结"></a>Ⅰ- 概括总结</h3><blockquote><p><strong>二进制表示法</strong>: <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</p><p><strong>八进制表示法</strong>: <code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</p><p><strong>指数运算符</strong>:其实这是<code>ES2016</code> 新增的 ,指数运算符（<code>**</code>）.  –&gt;详见下方</p><p><strong>Number.EPSILON</strong>: 数值最小精度</p><p><strong>Number.MIN_SAFE_INTEGER</strong>: 最小安全数值(<code>-2^53</code>)</p><p><strong>Number.MAX_SAFE_INTEGER</strong>: 最大安全数值(<code>2^53</code>)</p><p><strong>Number.parseInt()</strong>: 返回转换值的整数部分</p><p><strong>Number.parseFloat()</strong>: 返回转换值的浮点数部分</p><p><strong>Number.isFinite()</strong>: 是否为有限数值</p><p><strong>Number.isNaN()</strong>: 是否为NaN</p><p><strong>Number.isInteger()</strong>: 是否为整数</p><p><strong>Number.isSafeInteger()</strong>: 是否在数值安全范围内</p><p><strong>Math.trunc()</strong>: 返回数值整数部分</p><p><strong>Math.sign()</strong>: 返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</p><p><strong>Math.cbrt()</strong>: 返回数值立方根</p><p><strong>Math.clz32()</strong>: 返回数值的32位无符号整数形式</p><p><strong>Math.imul()</strong>: 返回两个数值相乘</p><p><strong>Math.fround()</strong>: 返回数值的32位单精度浮点数形式</p><p><strong>Math.hypot()</strong>: 返回所有数值平方和的平方根</p><p><strong>Math.expm1()</strong>: 返回<code>e^n - 1</code></p><p><strong>Math.log1p()</strong>: 返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</p><p><strong>Math.log10()</strong>: 返回以10为底的n的对数</p><p><strong>Math.log2()</strong>: 返回以2为底的n的对数</p><p><strong>Math.sinh()</strong>: 返回n的双曲正弦</p><p><strong>Math.cosh()</strong>: 返回n的双曲余弦</p><p><strong>Math.tanh()</strong>: 返回n的双曲正切</p><p><strong>Math.asinh()</strong>: 返回n的反双曲正弦</p><p><strong>Math.acosh()</strong>: 返回n的反双曲余弦</p><p><strong>Math.atanh()</strong>: 返回n的反双曲正切</p></blockquote><h3 id="Ⅱ-指数运算符"><a href="#Ⅱ-指数运算符" class="headerlink" title="Ⅱ - 指数运算符"></a>Ⅱ - 指数运算符</h3><blockquote><p>ES2016 新增了一个指数运算符（<code>**</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>这个运算符的一个特点是右结合, 而不是常见的左结合. 多个指数运算符连用时, 是从最右边开始计算的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line">&gt;<span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line">&gt;<span class="comment">// 512</span></span><br></pre></td></tr></table></figure><p>上面代码中, 首先计算的是第二个指数运算符, 而不是第一个. </p><p>指数运算符可以与等号结合, 形成一个新的赋值运算符（<code>**=</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">&gt;a **= <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">&gt;b **= <span class="number">3</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="6、函数的拓展"><a href="#6、函数的拓展" class="headerlink" title="6、函数的拓展"></a>6、函数的拓展</h2><blockquote><p><code>对于JS来说函数部分是重中之重的基础</code>,相对而言篇幅占比也会较大</p></blockquote><h3 id="Ⅰ-概括总结-3"><a href="#Ⅰ-概括总结-3" class="headerlink" title="Ⅰ- 概括总结"></a>Ⅰ- 概括总结</h3><blockquote><blockquote><p><strong>Ⅰ- 参数默认值</strong>: 为函数参数指定默认值</p></blockquote><ul><li>形式: <code>function Func(x = 1, y = 2) &#123;&#125;</code></li><li>参数赋值: 惰性求值(函数调用后才求值)</li><li>参数位置: 尾参数</li><li>参数作用域: 函数作用域</li><li>声明方式: 默认声明, 不能用<code>const</code>或<code>let</code>再次声明</li><li>length: 返回没有指定默认值的参数个数</li><li>与解构赋值默认值结合: <code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>应用<ol><li>指定某个参数不得省略, 省略即抛出错误: <code>function Func(x = throwMissing()) &#123;&#125;</code></li><li>将参数默认值设为 <strong>undefined</strong> , 表明此参数可省略: <code>Func(undefined, 1)</code></li></ol></li></ul><blockquote><p><strong>Ⅱ - 箭头函数(=&gt;)</strong>: 函数简写  –&gt;<code>重点</code></p></blockquote><ul><li>无参数: <code>() =&gt; &#123;&#125;</code></li><li>单个参数: <code>x =&gt; &#123;&#125;</code>   //可以省略（）</li><li>单条语句：<code>()=&gt; </code>   //省略{}，此时return也需省略，执行结果为函数返回值<br>  let po=(n)=&gt; n+1;<br>  sonsole.log(po(1))   //2</li></ul></blockquote><blockquote><ul><li>多个参数: <code>(x, y) =&gt; &#123;&#125;</code></li><li>解构参数: <code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code></li><li>嵌套使用: ** <code>部署管道机制</code> ** –&gt;不懂的详见下方</li><li>this指向固定化(静态)<br>  1.this始终指向函数声明时所在作用域下的this的值，无法改变this指向(相当于没有this指向)<br>  2.不能所谓构造函数的实例化对象， 因为没有 [ this ] , 因此不能用作构造函数<br>  3.不能使用arguments变量<br>  4.适合用于与this无关的回调 定时器，数组的方法回调，<ol start="5"><li>不适用事件回调和对象的方法</li></ol>-</li></ul><blockquote><p><strong>Ⅲ - rest/spread参数(…)</strong>: 返回函数多余参数</p></blockquote><ul><li>形式: 以数组的形式存在, 之后不能再有其他参数</li><li>作用: 代替<code>Arguments对象</code></li><li>length: 返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul><blockquote><p><strong>Ⅳ - 严格模式</strong>: 在严格条件下运行JS</p></blockquote><ul><li>应用: 只要函数参数使用默认值、解构赋值、扩展运算符, 那么函数内部就不能显式设定为严格模式</li></ul><blockquote><p><strong>Ⅴ - name属性</strong>: 返回函数的函数名</p></blockquote><ul><li>将匿名函数赋值给变量: <code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li><li>将具名函数赋值给变量: <code>函数名</code>(<strong>ES5和ES6</strong>)</li><li>bind返回的函数: <code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li><li>Function构造函数返回的函数实例: <code>anonymous</code>(<strong>ES5和ES6</strong>)</li></ul><blockquote><p><strong>Ⅵ - 尾调用优化</strong>: 只保留内层函数的调用帧</p></blockquote><ul><li>尾调用<ul><li>定义: 某个函数的最后一步是调用另一个函数</li><li>形式: <code>function f(x) &#123; return g(x); &#125;</code></li></ul></li><li>尾递归<ul><li>定义: 函数尾调用自身</li><li>作用: 只要使用尾递归就不会发生栈溢出, 相对节省内存</li><li>实现: 把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul><blockquote><p><strong>Ⅶ - 箭头函数常见误区的正解</strong></p></blockquote><ol><li>函数体内的 [ this ] 是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li><li>可让 [ this ] 指向固定化, 这种特性很有利于封装回调函数</li><li>不可当作<code>构造函数</code>, 因此箭头函数不可使用<code>new命令</code></li><li>不可使用<code>yield命令</code>, 因此箭头函数不能用作<code>Generator函数</code></li><li>不可使用<code>Arguments对象</code>, 此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>返回对象时必须在对象外面加上括号</li></ol></blockquote><h3 id="Ⅱ-函数参数的默认值"><a href="#Ⅱ-函数参数的默认值" class="headerlink" title="Ⅱ - 函数参数的默认值"></a>Ⅱ - 函数参数的默认值</h3><h4 id="①-基本用法-1"><a href="#①-基本用法-1" class="headerlink" title="①  基本用法"></a>①  基本用法</h4><blockquote><p>ES6 之前, 不能直接为函数的参数指定默认值, 只能采用变通的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> y = y || <span class="string">&#x27;World&#x27;</span>; <span class="comment">//[或],当y为undefined时,将其赋值</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello World  --&gt;参数`y`等于空字符, 结果被改为默认值</span></span><br></pre></td></tr></table></figure><p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值, 如果没有, 则指定默认值为<code>World</code>. 这种写法的缺点在于, 如果参数<code>y</code>赋值了, 但是对应的布尔值为<code>false</code>, 则该赋值不起作用. 就像上面代码的最后一行, 参数<code>y</code>等于空字符, 结果被改为默认值. </p><p>为了避免这个问题, 通常需要先判断一下参数<code>y</code>是否被赋值, 如果没有, 再等于默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>) &#123;  y = <span class="string">&#x27;World&#x27;</span>; &#125;</span><br></pre></td></tr></table></figure><p>ES6 允许为函数的参数设置默认值, 即直接写在参数定义的后面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);&#125;</span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>可以看到 , ES6 的写法比 ES5 简洁许多, 而且非常自然. 下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">&gt;p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>除了简洁 , ES6 的写法还有两个好处: </p><ul><li>首先, 阅读代码的人, 可以立刻意识到哪些参数是可以省略的, 不用查看函数体或文档；</li><li>其次, 有利于将来的代码优化, 即使未来的版本在对外接口中, 彻底拿掉这个参数, 也不会导致以前的代码无法运行. </li></ul><p>参数变量是默认声明的, 所以不能用<code>let</code>或<code>const</code>再次声明,否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>使用参数默认值时, 函数不能有同名参数</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 不报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) &#123;&#125;</span><br><span class="line">&gt;<span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure><p>另外, 一个容易忽略的地方是, 参数默认值不是传值的, 而是每次都重新计算默认值表达式的值. 也就是说, 参数默认值是惰性求值的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(p);&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line">&gt;x = <span class="number">100</span>;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>p</code>的默认值是<code>x + 1</code>. 这时, 每次调用函数<code>foo</code>, 都会重新计算<code>x + 1</code>, 而不是默认<code>p</code>等于 100. </p></blockquote><h4 id="②-与解构赋值默认值结合使用"><a href="#②-与解构赋值默认值结合使用" class="headerlink" title="② 与解构赋值默认值结合使用"></a>② 与解构赋值默认值结合使用</h4><blockquote><p>参数默认值可以与解构赋值的默认值, 结合起来使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">&gt;<span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">&gt;<span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码只使用了对象的解构赋值默认值, 没有使用函数参数的默认值. 只有当函数<code>foo</code>的参数是一个对象时, 变量<code>x</code>和<code>y</code>才会通过解构赋值生成. 如果函数<code>foo</code>调用时没提供参数, 变量<code>x</code>和<code>y</code>就不会生成, 从而报错. 通过提供函数参数的默认值, 就可以避免这种情况. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>上面代码指定, 如果没有提供参数, 函数<code>foo</code>的参数默认为一个空对象. </p><p>下面是另一个解构赋值默认值的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中, 如果函数<code>fetch</code>的第二个参数是一个对象, 就可以为它的三个属性设置默认值. 这种写法不能省略第二个参数, 如果结合函数参数的默认值, 就可以省略第二个参数. 这时, 就出现了双重默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>fetch</code>没有第二个参数时, 函数参数的默认值就会生效, 然后才是解构赋值的默认值生效, 变量<code>method</code>才会取到默认值<code>GET</code>. </p><p>作为练习, 请问下面两种写法有什么差别？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 写法一</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123; <span class="keyword">return</span> [x, y]; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 写法二</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123; <span class="keyword">return</span> [x, y]; &#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值, 区别是写法一函数参数的默认值是空对象, 但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象, 但是没有设置对象解构赋值的默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 函数没有参数的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// x 有值 , y 无值的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-参数默认值的位置"><a href="#③-参数默认值的位置" class="headerlink" title="③  参数默认值的位置"></a>③  参数默认值的位置</h4><blockquote><p>通常情况下, 定义了默认值的参数, 应该是函数的尾参数. 因为这样比较容易看出来, 到底省略了哪些参数. 如果非尾部的参数设置默认值, 实际上这个参数是没法省略的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123; <span class="keyword">return</span> [x, y];&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) &#123; <span class="keyword">return</span> [x, y, z];&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 有默认值的参数都不是尾参数. 这时, 无法只省略该参数, 而不省略它后面的参数, 除非显式输入 <strong>undefined</strong> . </p><p>如果传入 <strong>undefined</strong> , 将触发该参数等于默认值,  <strong>null</strong> 则没有这个效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); &#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>x</code>参数对应 <strong>undefined</strong> , 结果触发了默认值, <code>y</code>参数等于 <strong>null</strong> , 就没有触发默认值. </p></blockquote><h4 id="④-函数的-length-属性"><a href="#④-函数的-length-属性" class="headerlink" title="④ 函数的 length 属性"></a>④ 函数的 length 属性</h4><blockquote><p>指定了默认值以后, 函数的<code>length</code>属性, 将返回没有指定默认值的参数个数. 也就是说, <code>指定了默认值后 , length属性将失真</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中, [ length ]属性的返回值, 等于函数的参数个数减去指定了默认值的参数个数. 比如, 上面最后一个函数, 定义了 3 个参数, 其中有一个参数<code>c</code>指定了默认值, 因此[ length ]属性等于<code>3</code>减去<code>1</code>, 最后得到<code>2</code>. </p><p>这是因为<code>length</code>属性的含义是, 该函数预期传入的参数个数. 某个参数指定默认值以后, 预期传入的参数个数就不包括这个参数了. 同理, 后文的 rest 参数也不会计入[ length ]属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">...args</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果设置了<code>默认值的参数不是尾参数</code>, 那么[ length ]属性也不再计入后面的参数了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-作用域"><a href="#⑤-作用域" class="headerlink" title="⑤  作用域"></a>⑤  作用域</h4><blockquote><p>一旦设置了参数的默认值, 函数进行声明初始化时, 参数会形成一个单独的作用域（context）. 等到初始化结束, 这个作用域就会消失. 这种语法行为, 在不设置参数默认值时, 是不会出现的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(y); &#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>y</code>的默认值等于变量<code>x</code>. 调用函数 [ f ] 时, 参数形成一个单独的作用域. 在这个作用域里面, 默认值变量<code>x</code>指向第一个参数<code>x</code>, 而不是全局变量<code>x</code>, 所以输出是<code>2</code>. </p><p>再看下面的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数 [ f ] 调用时, 参数<code>y = x</code>形成一个单独的作用域. 这个作用域里面, 变量<code>x</code>本身没有定义, 所以指向外层的全局变量<code>x</code>. 函数调用时, 函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>. </p><p>如果此时, 全局变量<code>x</code>不存在, 就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>下面这样写, 也会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = x</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>x = x</code>形成一个单独作用域. 实际执行的是<code>let x = x</code>, 由于暂时性死区的原因, 这行代码会报错”x 未定义“. </p><p>如果参数的默认值是一个函数, 该函数的作用域也遵守这个规则. 请看下面的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> foo = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">func = () =&gt; foo</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">bar</span>(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数, 返回值为变量<code>foo</code>. 函数参数形成的单独作用域里面, 并没有定义变量<code>foo</code>, 所以<code>foo</code>指向外层的全局变量<code>foo</code>, 因此输出<code>outer</code>. </p><p>如果写成下面这样, 就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">func = () =&gt; foo</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">bar</span>() <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 匿名函数里面的<code>foo</code>指向函数外层, 但是函数外层并没有声明变量<code>foo</code>, 所以就报错了. </p><p>下面是一个更复杂的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"> <span class="title function_">y</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="comment">//x == 1</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>foo</code>的参数形成一个单独作用域. 这个作用域里面, 首先声明了变量<code>x</code>, 然后声明了变量<code>y</code>, <code>y</code>的默认值是一个匿名函数. 这个匿名函数内部的变量<code>x</code>, 指向同一个作用域的第一个参数<code>x</code>. 函数<code>foo</code>内部又声明了一个内部变量<code>x</code>, 该变量与第一个参数<code>x</code>由于不是同一个作用域, 所以不是同一个变量, 因此执行<code>y</code>后, 内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变. </p><p>如果将<code>var x = 3</code>的<code>var</code>去除, 函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>, 与匿名函数内部的<code>x</code>是一致的, 所以最后输出的就是<code>2</code>, 而外层的全局变量<code>x</code>依然不受影响. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) &#123;</span><br><span class="line"> x = <span class="number">3</span>;</span><br><span class="line"> <span class="title function_">y</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br><span class="line">&gt;<span class="comment">//x== 1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-应用"><a href="#⑥-应用" class="headerlink" title="⑥ 应用"></a>⑥ 应用</h4><blockquote><p>利用参数默认值, 可以指定某一个参数不得省略, 如果省略就抛出一个错误. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">throwIfMissing</span>(<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) &#123;  <span class="keyword">return</span> mustBeProvided; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>()</span><br><span class="line">&gt;<span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>foo</code>函数, 如果调用的时候没有参数, 就会调用默认值<code>throwIfMissing</code>函数, 从而抛出一个错误. </p><p>从上面代码还可以看到, 参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号）, 这表明参数的默认值不是在定义时执行, 而是在运行时执行. 如果参数已经赋值, 默认值中的函数就不会运行. </p><p>另外, 可以将参数默认值设为 <strong>undefined</strong> , 表明这个参数是可以省略的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">optional = <span class="literal">undefined</span></span>) &#123; ··· &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-箭头函数-重点"><a href="#Ⅲ-箭头函数-重点" class="headerlink" title="Ⅲ - 箭头函数 (重点)"></a>Ⅲ - 箭头函数 (<code>重点</code>)</h3><blockquote><p>ES6最常见用法,这个必须要会</p></blockquote><h4 id="①-基本用法-2"><a href="#①-基本用法-2" class="headerlink" title="① 基本用法"></a>① 基本用法</h4><blockquote><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> v;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数, 就使用一个圆括号代表参数部分. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句, 就要使用大括号将它们括起来, 并且使用<code>return</code>语句返回. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p><code>由于大括号被解释为代码块, 所以如果箭头函数直接返回一个对象, 必须在对象外面加上括号, 否则会报错</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">getTempItem</span> = id =&gt; &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 不报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">getTempItem</span> = id =&gt; (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>下面是一种特殊情况, 虽然可以运行, 但会得到错误的结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 原始意图是返回一个对象<code>&#123; a: 1 &#125;</code>, 但是由于引擎认为大括号是代码块, 所以执行了一行语句<code>a: 1</code>. 这时, <code>a</code>可以被解释为语句的标签, 因此实际执行的语句是<code>1;</code>, 然后函数就结束了, 没有返回值. </p><p>如果箭头函数只有一行语句, 且不需要返回值, 可以采用下面的写法, 就不用写大括号了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> <span class="title function_">doesNotReturn</span>();</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">full</span> = (<span class="params">&#123; first, last &#125;</span>) =&gt; first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">full</span>(<span class="params">person</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">last</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">isEven</span> = n =&gt; n % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">//类型 boolean</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">square</span> = n =&gt; n * n;  <span class="comment">//类型 number</span></span><br></pre></td></tr></table></figure><p>上面代码只用了两行, 就定义了两个简单的工具函数. 如果不用箭头函数, 可能就要占用多行, 而且还不如现在这样写醒目. </p><p>箭头函数的一个用处是简化回调函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正常函数写法</span></span><br><span class="line">&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x * x;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 箭头函数写法</span></span><br><span class="line">&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>另一个栗子是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正常函数写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> result = values.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a - b;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 箭头函数写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> result = values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的栗子(<code>个人觉得很好用</code>). </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">numbers</span> = (<span class="params">...nums</span>) =&gt; nums;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">numbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">headAndTail</span> = (<span class="params">head, ...tail</span>) =&gt; [head, tail];<span class="comment">//rest参数需要放到最后</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">headAndTail</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-使用注意点"><a href="#②-使用注意点" class="headerlink" title="② 使用注意点"></a>② 使用注意点</h4><blockquote><p>箭头函数有几个使用注意点. </p><p>（1）函数体内的 [ this ] 对象, 就是定义时所在的对象, 而不是使用时所在的对象. </p><p>（2）不可以当作构造函数, 也就是说, 不可以使用<code>new</code>命令, 否则会抛出一个错误. </p><p>（3）不可以使用<code>arguments</code>对象, 该对象在函数体内不存在. 如果要用, <code>可以用 rest 参数代替</code>. </p><p>（4）不可以使用<code>yield</code>命令, 因此箭头函数<code>不能用作 Generator 函数</code>. –&gt;此类型函数在后方知识点会给出详解</p><blockquote><p>以下是详解举栗</p></blockquote><p>上面四点中, 第一点尤其值得注意. <code>[this]对象的指向是可变的, 但是在箭头函数中, 它是固定的</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">&gt;foo.<span class="title function_">call</span>(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;); <span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>setTimeout()</code>的参数是一个箭头函数, 这个箭头函数的定义生效是在<code>foo</code>函数生成时, 而它的真正执行要等到 100 毫秒后. 如果是普通函数, 执行时 [ this ] 应该指向全局对象<code>window</code>, 这时应该输出<code>21</code>. 但是, 箭头函数导致 [ this ] 总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>）, 所以打印出来的是<code>42</code>. </p><p>箭头函数可以让<code>setTimeout</code>里面的 [ this ] , 绑定定义时所在的作用域, 而不是指向运行时所在的作用域. 下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">s1</span> = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">s2</span> = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">// 箭头函数</span></span><br><span class="line">&gt;<span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">s1</span>++, <span class="number">1000</span>);</span><br><span class="line">&gt;<span class="comment">// 普通函数</span></span><br><span class="line">&gt;<span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">s2</span>++;</span><br><span class="line">&gt;&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> timer = <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s1: &#x27;</span>, timer.<span class="property">s1</span>), <span class="number">3100</span>);</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s2: &#x27;</span>, timer.<span class="property">s2</span>), <span class="number">3100</span>);</span><br><span class="line">&gt;<span class="comment">// s1: 3</span></span><br><span class="line">&gt;<span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Timer</code>函数内部设置了两个定时器, 分别使用了箭头函数和普通函数. 前者的 [ this ] 绑定定义时所在的作用域（即<code>Timer</code>函数）, 后者的 [ this ] 指向运行时所在的作用域（即全局对象）. 所以, 3100 毫秒之后, <code>timer.s1</code>被更新了 3 次, 而<code>timer.s2</code>一次都没更新. </p><p><code>箭头函数可以让[this指向]固定化, 这种特性很有利于封装回调函数</code>. 下面是一个栗子 , DOM 事件的回调函数封装在一个对象里面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line">&gt;<span class="attr">id</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">&gt;<span class="attr">init</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line"><span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">doSomething</span>(event.<span class="property">type</span>), <span class="literal">false</span>);</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;<span class="attr">doSomething</span>: <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>init</code>方法中, 使用了箭头函数, 这导致这个箭头函数里面的 [ this ] , 总是指向<code>handler</code>对象. 否则, 回调函数运行时, <code>this.doSomething</code>这一行会报错, 因为此时 [ this ] 指向<code>document</code>对象. </p><p>[ this ] 指向的固定化, 并不是因为箭头函数内部有绑定 [ this ] 的机制, 实际原因是箭头函数根本没有自己的 [ this ] , 导致内部的 [ this ] 就是外层代码块的 [ this ] . 正是因为它没有 [ this ] , 所以也就不能用作构造函数. </p><p>所以, 箭头函数转成 ES5 的代码如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, _this.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 转换后的 ES5 版本清楚地说明了, 箭头函数里面根本没有自己的 [ this ] , 而是引用外层的 [ this ] . </p><p>请问下面的代码之中有几个 [ this ] ？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> f = foo.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> t1 = f.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line">&gt;<span class="keyword">var</span> t2 = <span class="title function_">f</span>().<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line">&gt;<span class="keyword">var</span> t3 = <span class="title function_">f</span>()().<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure><p>上面代码之中, 只有一个 [ this ] , 就是函数<code>foo</code>的 [ this ] , 所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果. 因为所有的内层函数都是箭头函数, 都没有自己的 [ this ] , 它们的 [ this ] 其实都是最外层<code>foo</code>函数的 [ this ] . </p><p>除了 [ this ] , 以下三个变量在箭头函数之中也是不存在的, 指向外层函数的对应变量: <code>arguments</code>、<code>super</code>、<code>new.target</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;args:&#x27;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line">&gt;<span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 箭头函数内部的变量<code>arguments</code>, 其实是函数<code>foo</code>的<code>arguments</code>变量. </p><p>另外, 由于箭头函数没有自己的 [ this ] , 所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变 [ this ] 的指向. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> [</span><br><span class="line">&gt;(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">x</span>).<span class="title function_">bind</span>(&#123; <span class="attr">x</span>: <span class="string">&#x27;inner&#x27;</span> &#125;)()</span><br><span class="line">&gt;];</span><br><span class="line">&gt;&#125;).<span class="title function_">call</span>(&#123; <span class="attr">x</span>: <span class="string">&#x27;outer&#x27;</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [&#x27;outer&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 箭头函数没有自己的 [ this ] , 所以<code>bind</code>方法无效, 内部的 [ this ] 指向外部的 [ this ] . </p><p>长期以来 , JavaScript 语言的 [ this ] 对象一直是一个令人头痛的问题, 在对象方法中使用 [ this ] , 必须非常小心. <code>箭头函数&#39;绑定[this]&#39;, 很大程度上解决了这个困扰. </code></p></blockquote><h4 id="③-不适用场合"><a href="#③-不适用场合" class="headerlink" title="③ 不适用场合"></a>③ 不适用场合</h4><blockquote><p>由于箭头函数使得 [ this ] 从“动态”变成“静态”, 下面两个场合不应该使用箭头函数. </p><p>第一个场合是定义对象的方法, 且该方法内部包括 [ this ] . </p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="keyword">const</span> cat = &#123;</span><br><span class="line"> <span class="attr">lives</span>: <span class="number">9</span>,</span><br><span class="line"> <span class="attr">jumps</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">lives</span>--;&#125;</span><br><span class="line">&gt;&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>cat.jumps()</code>方法是一个箭头函数, 这是错误的. 调用<code>cat.jumps()</code>时, 如果是普通函数, 该方法内部的 [ this ] 指向<code>cat</code>；如果写成上面那样的箭头函数, 使得 [ this ] 指向全局对象, 因此不会得到预期结果. 这是<code>因为对象不构成单独的作用域</code>, 导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域. </p></blockquote><p>第二个场合是需要动态 [ this ] 的时候, 也不应使用箭头函数. </p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">&gt;&gt;button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&gt;&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码运行时, 点击按钮会报错, 因为<code>button</code>的监听函数是一个箭头函数, 导致里面的 [ this ] 就是全局对象. 如果改成普通函数,  [ this ] 就会动态指向被点击的按钮对象. </p></blockquote><p>另外, 如果函数体很复杂, 有许多行, 或者函数内部有大量的读写操作, 不单纯是为了计算值, 这时也不应该使用箭头函数, 而是要使用普通函数, 这样可以提高代码可读性</p></blockquote><h4 id="④-嵌套的箭头函数"><a href="#④-嵌套的箭头函数" class="headerlink" title="④ 嵌套的箭头函数"></a>④ 嵌套的箭头函数</h4><blockquote><p>箭头函数内部, 还可以再使用箭头函数. 下面是一个 ES5 语法的多重嵌套函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="keyword">function</span> (<span class="params">array</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="keyword">function</span> (<span class="params">afterValue</span>) &#123;</span><br><span class="line">     array.<span class="title function_">splice</span>(array.<span class="title function_">indexOf</span>(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">     <span class="keyword">return</span> array;</span><br><span class="line">   &#125;&#125;;</span><br><span class="line"> &#125;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">insert</span>(<span class="number">2</span>).<span class="title function_">into</span>([<span class="number">1</span>, <span class="number">3</span>]).<span class="title function_">after</span>(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面这个函数, 可以使用箭头函数改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">insert</span> = (<span class="params">value</span>) =&gt; (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</span><br><span class="line"> array.<span class="title function_">splice</span>(array.<span class="title function_">indexOf</span>(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line"> <span class="keyword">return</span> array;</span><br><span class="line">&gt;&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">insert</span>(<span class="number">2</span>).<span class="title function_">into</span>([<span class="number">1</span>, <span class="number">3</span>]).<span class="title function_">after</span>(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-部署管道机制-pipeline"><a href="#a-部署管道机制-pipeline" class="headerlink" title="a) 部署管道机制 (pipeline)"></a>a) 部署管道机制 (pipeline)</h5><blockquote><p>下面是一个部署管道机制 (pipeline)的栗子 : <code>即前一个函数的输出是后一个函数的输入</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">pipeline</span> = (<span class="params">...funcs</span>) =&gt;</span><br><span class="line"> <span class="function"><span class="params">val</span> =&gt;</span> funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">b</span>(a), val);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">plus1</span> = a =&gt; a + <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">mult2</span> = a =&gt; a * <span class="number">2</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> addThenMult = <span class="title function_">pipeline</span>(plus1, mult2);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">addThenMult</span>(<span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差, 也可以采用下面的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">plus1</span> = a =&gt; a + <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">mult2</span> = a =&gt; a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">mult2</span>(<span class="title function_">plus1</span>(<span class="number">5</span>))</span><br><span class="line">&gt;<span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>箭头函数还有一个功能, 就是可以很方便地改写 λ 演算. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// λ演算的写法</span></span><br><span class="line">&gt;fix = λf.(λx.<span class="title function_">f</span>(λv.<span class="title function_">x</span>(x)(v)))(λx.<span class="title function_">f</span>(λv.<span class="title function_">x</span>(x)(v)))</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6的写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">fix</span> = f =&gt; (<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">x</span>(x)(v)))</span><br><span class="line">              (<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">x</span>(x)(v)));</span><br></pre></td></tr></table></figure><p>上面两种写法, 几乎是一一对应的. 由于 λ 演算对于计算机科学非常重要, 这使得我们可以用 ES6 作为替代工具, 探索计算机科学. </p></blockquote><h5 id="b-高阶函数"><a href="#b-高阶函数" class="headerlink" title="b) 高阶函数"></a>b) 高阶函数</h5><blockquote><p>在我的理解中,实际上高阶函数本质上就与  [ 部署管道机制 ] 殊途同归,此处列出是为了更好做对比,防止以后遇到混淆</p><p>所谓高阶函数:<code>就是一个函数就可以接收另一个函数作为参数, 或者是返回一个函数</code>–&gt;常见的高阶函数有map、reduce、filter、sort等</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="variable constant_">ADD</span> =<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123; <span class="keyword">return</span> a+b &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">调用: <span class="title function_">ADD</span>(<span class="number">2</span>)(<span class="number">3</span>)即可获得结果</span><br></pre></td></tr></table></figure><blockquote><p>map</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;map接受一个函数作为参数, 不改变原来的数组, 只是返回一个全新的数组</span><br><span class="line">&gt;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item = <span class="number">2</span>)<span class="comment">// 输出[1,1,1,1,1]</span></span><br></pre></td></tr></table></figure><blockquote><p>reduce</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;reduce也是返回一个全新的数组. reduce接受一个函数作为参数, 这个函数要有两个形参, 代表数组中的前两项 , reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作</span><br><span class="line">&gt;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&gt;<span class="keyword">var</span> arr2 = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span> a+b)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><blockquote><p>filter</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;filter返回过滤后的数组. filter也接收一个函数作为参数, 这个函数将作用于数组中的每个元素, 根据该函数每次执行后返回的布尔值来保留结果, 如果是<span class="literal">true</span>就保留, 如果是<span class="literal">false</span>就过滤掉（这点与map要区分）</span><br><span class="line">&gt;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)<span class="comment">// [2,4]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-函数柯里化"><a href="#c-函数柯里化" class="headerlink" title="c) 函数柯里化"></a>c) 函数柯里化</h5><blockquote><p>此处列出是因为此知识点常与箭头函数搭配使用,而很多同学其实有在用却都不懂这个概念(大多数教程都不会刻意去普及概念),所以我觉得在此处列出,会对很多同学有所帮助,也能形成关联性更强的知识体系</p><blockquote><p>截取自网上的正解图例</p></blockquote><p> <img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210415161137977.png" alt="image-20210415161137977"></p><blockquote><p>关键就是<code>理解柯里化</code>, 其实可以把它理解成, 柯里化后, <code>将第一个参数变量存在函数里面了(闭包)</code>, 然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用, 比如</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br><span class="line">&gt;<span class="keyword">let</span> add2 = <span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">&gt;------------ 一般调用 ------------------------</span><br><span class="line">&gt;<span class="comment">//本来完成 add 这个操作, 应该是这样调用</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y</span><br><span class="line">&gt;<span class="title function_">add</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;------------- 柯里化后调用  ---------------------</span><br><span class="line">&gt;<span class="comment">// 而现在 add2 函数完成同样操作只需要一个参数, 这在函数式编程中广泛应用. </span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br><span class="line">&gt;<span class="keyword">let</span> add2 = <span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">&gt;<span class="comment">//详细解释一下, 就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数,并且此时 x = 2 , 所以此时调用</span></span><br><span class="line">&gt;<span class="title function_">add2</span>(<span class="number">3</span>) === <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-从-ES6-高阶箭头函数理解函数柯里化以及-部署管道机制"><a href="#d-从-ES6-高阶箭头函数理解函数柯里化以及-部署管道机制" class="headerlink" title="d) 从 ES6 高阶箭头函数理解函数柯里化以及 [ 部署管道机制 ]"></a>d) 从 ES6 高阶箭头函数理解函数柯里化以及 [ 部署管道机制 ]</h5><blockquote><ol><li>首先看到了这样的一个栗子: </li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> a + b</span><br></pre></td></tr></table></figure><ol start="2"><li>以上是一个很简单的相加函数, 把它转化成 ES5 的写法如下</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> add3 = <span class="title function_">add</span>(<span class="number">3</span>) <span class="comment">//add3表示一个指向函数的变量 可以当成函数调用名来用</span></span><br><span class="line">&gt;<span class="title function_">add3</span>(<span class="number">4</span>) === <span class="number">3</span> + <span class="number">4</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>再简化一下, 可以写成如下形式: </li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> add = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> param = a;</span><br><span class="line">   <span class="keyword">var</span> innerFun = <span class="keyword">function</span>(<span class="params">b</span>) &#123; <span class="keyword">return</span> param + b; &#125;</span><br><span class="line">   <span class="keyword">return</span> innerFun;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>虽然好像没什么意义, 但是很显然上述使用了闭包, 而且该函数的返回值是一个函数. 其实, 这就是<code>高阶函数的定义: 以函数为参数或者返回值是函数的函数. </code></li></ol><p> <img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210415160945789.png" alt="image-20210415160945789"> </p></blockquote><h3 id="Ⅳ-rest-参数-常用"><a href="#Ⅳ-rest-参数-常用" class="headerlink" title="Ⅳ - rest 参数 (常用)"></a>Ⅳ - rest 参数 (<code>常用</code>)</h3><blockquote><p>ES6 引入 rest 参数（形式为<code>...变量名</code>）, 用于获取函数的多余参数, 这样就不需要使用<code>arguments</code>对象了. rest 参数搭配的变量是一个数组, 该变量将多余的参数放入数组中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">   sum += val;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>add</code>函数是一个求和函数, 利用 rest 参数, 可以向该函数传入任意数目的参数. </p><p>下面是一个 rest 参数代替<code>arguments</code>变量的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// arguments变量的写法</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// rest参数的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br></pre></td></tr></table></figure><p>上面代码的两种写法, 比较后可以发现 , rest 参数的写法更自然也更简洁. </p><p><code>arguments</code>对象不是数组, 而是一个类似数组的对象. 所以为了使用数组的方法, 必须使用<code>Array.prototype.slice.call</code>先将其转为数组. <code>rest 参数就不存在这个问题, 它就是一个真正的数组, 数组特有的方法都可以使用</code>. 下面是一个利用 rest 参数改写数组<code>push</code>方法的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line"> items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">   array.<span class="title function_">push</span>(item);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> a = [];</span><br><span class="line">&gt;<span class="title function_">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>注意 , rest 参数之后不能再有其他参数（即只能是最后一个参数）, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, ...b, c</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>函数的<code>length</code>属性, 不包括 rest 参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">a</span>) &#123;&#125;).<span class="property">length</span>  <span class="comment">// 1</span></span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">...a</span>) &#123;&#125;).<span class="property">length</span>  <span class="comment">// 0</span></span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">a, ...b</span>) &#123;&#125;).<span class="property">length</span>  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-严格模式"><a href="#Ⅴ-严格模式" class="headerlink" title="Ⅴ - 严格模式"></a>Ⅴ - 严格模式</h3><blockquote><p>从 ES5 开始, 函数内部可以设定为严格模式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>ES2016 做了一点修改, <code>规定只要函数参数使用了默认值、解构赋值、或者扩展运算符, 那么函数内部就不能显式设定为严格模式, 否则会报错</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> doSomething = <span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">doSomething</span> = (<span class="params">...a</span>) =&gt; &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="comment">// 报错</span></span><br><span class="line"> <span class="title function_">doSomething</span>(<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">   <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">   <span class="comment">// code</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>这样规定的原因是, 函数内部的严格模式, 同时适用于函数体和函数参数. 但是, 函数执行的时候, 先执行函数参数, 然后再执行函数体. 这样就有一个不合理的地方, 只有从函数体之中, 才能知道参数是否应该以严格模式执行, 但是参数却应该先于函数体执行. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">value = <span class="number">070</span></span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>value</code>的默认值是八进制数<code>070</code>, 但是严格模式下不能用前缀<code>0</code>表示八进制, 所以应该报错. 但是实际上 , JavaScript 引擎会先成功执行<code>value = 070</code>, 然后进入函数体内部, 发现需要用严格模式执行, 这时才会报错. </p><p>虽然可以先解析函数体代码, 再执行参数代码, 但是这样无疑就增加了复杂性. 因此, 标准索性禁止了这种用法, 只要参数使用了默认值、解构赋值、或者扩展运算符, 就不能显式指定严格模式. </p><p>两种方法可以规避这种限制. 第一种是设定全局性的严格模式, 这是合法的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>第二种是把函数包在一个无参数的立即执行函数里面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> doSomething = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value = <span class="number">42</span></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;());</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅵ-name-属性"><a href="#Ⅵ-name-属性" class="headerlink" title="Ⅵ - name 属性"></a>Ⅵ - name 属性</h3><blockquote><p>函数的<code>name</code>属性, 返回该函数的函数名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;foo.<span class="property">name</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><p>这个属性早就被浏览器广泛支持, 但是直到 ES6 , 才将其写入了标准. </p><p>需要注意的是 , ES6 对这个属性的行为做出了一些修改. 如果将一个匿名函数赋值给一个变量 , ES5 的<code>name</code>属性, 会返回空字符串, 而 ES6 的<code>name</code>属性会返回实际的函数名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量 [ f ] 等于一个匿名函数 , ES5 和 ES6 的<code>name</code>属性返回的值不一样. </p><p>如果将一个具名函数赋值给一个变量, 则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> bar = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p><code>Function</code>构造函数返回的函数实例, <code>name</code>属性的值为<code>anonymous</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">new</span> <span class="title class_">Function</span>).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数, <code>name</code>属性值会加上<code>bound</code>前缀. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&gt;foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅶ-尾调用优化"><a href="#Ⅶ-尾调用优化" class="headerlink" title="Ⅶ - 尾调用优化"></a>Ⅶ - 尾调用优化</h3><blockquote><p>此处如果看不懂可以暂时跳过或者粗略看下,此部分一般情况不会用到:</p><p>尾调用优化默认关闭,各大浏览器（除了<code>safari</code>）根本就没部署尾调用优化；</p></blockquote><h4 id="①-什么是尾调用"><a href="#①-什么是尾调用" class="headerlink" title="① 什么是尾调用?"></a>① 什么是尾调用?</h4><blockquote><p>尾调用（Tail Call）是函数式编程的一个重要概念, 本身非常简单, 一句话就能说清楚, 就是指某个函数的最后一步是调用另一个函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">g</span>(x);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 函数 [ f ] 的最后一步是调用函数 [ g ] , 这就叫尾调用. </p><p>以下三种情况, 都不属于尾调用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 情况一</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> y = <span class="title function_">g</span>(x);</span><br><span class="line"> <span class="keyword">return</span> y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况二</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况三</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="title function_">g</span>(x);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 情况一是调用函数 [ g ] 之后, 还有赋值操作, 所以不属于尾调用, 即使语义完全一样. 情况二也属于调用后还有操作, 即使写在一行内. <code>情况三等同于下面的代码</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="title function_">g</span>(x);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>尾调用不一定出现在函数尾部, 只要是最后一步操作即可</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">m</span>(x)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">n</span>(x);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>m</code>和<code>n</code>都属于尾调用, 因为它们都是函数 [ f ] 的最后一步操作</p></blockquote><h4 id="②-尾调用优化"><a href="#②-尾调用优化" class="headerlink" title="② 尾调用优化"></a>② 尾调用优化</h4><blockquote><p>尾调用之所以与其他调用不同, 就在于它的特殊的调用位置. </p><p>我们知道, <code>函数调用会在内存形成一个&#39;调用记录&#39;, 又称 [调用帧 (call frame)]</code>, 保存调用位置和内部变量等信息. 如果在函数 [ A ] 的内部调用函数 [ B ] , 那么在 [ A ] 的调用帧上方, 还会形成一个 [ B ] 的调用帧. 等到 [ B ] 运行结束, 将结果返回到 [ A ] ,  [ B ] 的调用帧才会消失. 如果函数 [ B ] 内部还调用函数 [ C ] , 那就还有一个 [ C ] 的调用帧, 以此类推. <code>所有的调用帧, 就形成一个[调用栈 (call stack)]</code>. </p><p>尾调用由于是函数的最后一步操作, 所以不需要保留外层函数的调用帧, 因为调用位置、内部变量等信息都不会再用到了, <code>只要直接用内层函数的调用帧, 取代外层函数的调用帧就可以了</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">g</span>(m + n);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="title function_">g</span>(<span class="number">3</span>);&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title function_">g</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 如果函数 [ g ] 不是尾调用, 函数 [  f  ] 就需要保存内部变量<code>m</code>和<code>n</code>的值、 [ g ] 的调用位置等信息. 但由于调用 [ g ] 之后, 函数 [ <code>f</code> ] 就结束了, 所以执行到最后一步, 完全可以删除<code>f(x)</code>的调用帧, 只保留<code>g(3)</code>的调用帧. </p><p><code>这就叫做[尾调用优化 (Tail call optimization)]</code>:即只保留内层函数的调用帧. 如果所有函数都是尾调用, 那么完全可以做到每次执行时, 调用帧只有一项, 这将大大节省内存. 这就是“尾调用优化”的意义. </p><p>注意, 只有不再用到外层函数的内部变量, 内层函数的调用帧才会取代外层函数的调用帧, 否则就无法进行“尾调用优化”. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">addOne</span>(<span class="params">a</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">b</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> b + one;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">inner</span>(a);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化, 因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>. </p></blockquote><h4 id="③-尾递归"><a href="#③-尾递归" class="headerlink" title="③ 尾递归"></a>③ 尾递归</h4><blockquote><p>函数调用自身, 称为递归. 如果尾调用自身, 就称为尾递归. </p><p><code>递归非常耗费内存</code>, 因为需要同时保存成千上百个调用帧, 很容易发生[ 栈溢出错误 (stack overflow)]. <code>但对于尾递归来说, 由于只存在一个调用帧, 所以永远不会发生&#39;栈溢出&#39;错误</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码是一个阶乘函数, 计算<code>n</code>的阶乘, 最多需要保存<code>n</code>个调用记录, 复杂度 O(n) . </p><p>如果改写成尾递归, 只保留一个调用记录, 复杂度 O(1) . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>还有一个比较著名的栗子, 就是计算 Fibonacci 数列, 也能充分说明尾递归优化的重要性. </p><p>非尾递归的 Fibonacci 数列实现如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n) &#123;</span><br><span class="line"> <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>) + <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Fibonacci</span>(<span class="number">10</span>) <span class="comment">// 89</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci</span>(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci</span>(<span class="number">500</span>) <span class="comment">// 超时</span></span><br></pre></td></tr></table></figure><p>尾递归优化过的 Fibonacci 数列实现如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Fibonacci2</span> (n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Fibonacci2</span> (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Fibonacci2</span>(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci2</span>(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci2</span>(<span class="number">10000</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>由此可见, [ 尾调用优化 ]对递归操作意义重大, 所以一些函数式编程语言将其写入了语言规格. ES6 亦是如此, 第一次明确规定, 所有 ECMAScript 的实现, 都必须部署 [ 尾调用优化 ]. 这就是说, <code>ES6 中只要使用尾递归, 就不会发生栈溢出 (或者层层递归造成的超时), 相对节省内存</code>. </p></blockquote><h4 id="④-递归函数的改写"><a href="#④-递归函数的改写" class="headerlink" title="④ 递归函数的改写"></a>④ 递归函数的改写</h4><blockquote><p>尾递归的实现, 往往需要改写递归函数, 确保最后一步只调用自身. 做到这一点的方法, 就是把所有用到的内部变量改写成函数的参数. 比如上面的栗子, 阶乘函数 factorial 需要用到一个中间变量<code>total</code>, 那就把这个中间变量改写成函数的参数. 这样做的缺点就是不太直观, 第一眼很难看出来 : 为什么计算<code>5</code>的阶乘, 需要传入两个参数<code>5</code>和<code>1</code>？</p><p>两个方法可以解决这个问题. 方法一是在尾递归函数之外, 再提供一个正常形式的函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123; <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>, 调用尾递归函数<code>tailFactorial</code>, 看起来就正常多了. </p><p>函数式编程有一个概念, 叫做<code>柯里化 (currying)</code>, 意思是将多参数的函数转换成单参数的形式. 这里也可以使用柯里化. –&gt;不懂的看上方[④ 嵌套的箭头函数中的函数柯里化](#④ 嵌套的箭头函数 ) </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn, n</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, m, n);</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> factorial = <span class="title function_">currying</span>(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码通过柯里化, 将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>. </p><p>第二种方法就简单多了, 就是采用 ES6 的函数默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>total</code>有默认值<code>1</code>, 所以调用时不用提供这个值. </p><p>总结一下, 递归本质上是一种循环操作. 纯粹的函数式编程语言没有循环操作命令, 所有的循环都用递归实现, 这就是为什么尾递归对这些语言极其重要. 对于其他支持“尾调用优化”的语言（比如 Lua , ES6）, <code>只需要知道循环可以用递归代替, 而一旦使用递归, 就最好使用尾递归</code>. </p></blockquote><h4 id="⑤-严格模式"><a href="#⑤-严格模式" class="headerlink" title="⑤ 严格模式"></a>⑤ 严格模式</h4><blockquote><p><code>ES6 的尾调用优化只在严格模式下开启, 正常模式是无效的</code>. </p><p>这是因为在正常模式下, 函数内部有两个变量, 可以跟踪函数的调用栈. </p><ul><li><code>func.arguments</code>: 返回调用时函数的参数. </li><li><code>func.caller</code>: 返回调用当前函数的那个函数. </li></ul><p>尾调用优化发生时, 函数的调用栈会改写, 因此上面两个变量就会失真. 严格模式禁用这两个变量, 所以尾调用模式仅在严格模式下生效. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">restricted</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> restricted.<span class="property">caller</span>;    <span class="comment">// 报错</span></span><br><span class="line"> restricted.<span class="property">arguments</span>; <span class="comment">// 报错</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">restricted</span>();</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-利用-循环-替换-尾递归-优化的实现"><a href="#⑥-利用-循环-替换-尾递归-优化的实现" class="headerlink" title="⑥ 利用 循环 替换 尾递归 优化的实现"></a>⑥ 利用 循环 替换 尾递归 优化的实现</h4><blockquote><p>尾递归优化只在严格模式下生效, 那么正常模式下, 或者那些不支持该功能的环境中, 有没有办法也使用尾递归优化呢？回答是可以的, 就是自己实现尾递归优化. </p><p>它的原理非常简单. 尾递归之所以需要优化, 原因是调用栈太多, 造成溢出, 那么只要减少调用栈, 就不会溢出. 怎么做可以减少调用栈呢？<code>就是采用 [循环] 换掉 [递归]</code>. </p><p>下面是一个正常的递归函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (y &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>  <span class="keyword">return</span> x;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">&gt;<span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br><span class="line">&gt;<span class="comment">// 未捕获的RangeError:最大调用堆栈大小超过(…)  </span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>sum</code>是一个递归函数, 参数<code>x</code>是需要累加的值, 参数<code>y</code>控制递归次数. 一旦指定<code>sum</code>递归 100000 次, 就会报错, 提示超出调用栈的最大次数. </p></blockquote><h5 id="a-蹦床函数"><a href="#a-蹦床函数" class="headerlink" title="a)  蹦床函数"></a>a)  蹦床函数</h5><blockquote><p>蹦床函数（trampoline）可以将递归执行转为循环执行. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">trampoline</span>(<span class="params">f</span>) &#123;</span><br><span class="line"> <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123; f = <span class="title function_">f</span>();&#125;</span><br><span class="line"> <span class="keyword">return</span> f;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面就是蹦床函数的一个实现, 它接受一个函数<code>f</code>作为参数. 只要<code>f</code>执行后返回一个函数, 就继续执行. </p><p>注意:<code>这里是返回一个函数, 然后执行该函数, 而不是函数里面调用函数, 这样就避免了递归执行, 从而就消除了调用栈过大的问题</code>. </p><p>然后, 要做的就是将原来的递归函数, 改写为每一步返回另一个函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (y &gt; <span class="number">0</span>)  <span class="keyword">return</span> sum.<span class="title function_">bind</span>(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>sum</code>函数的每次执行, 都会返回自身的另一个版本. </p><p>现在, 使用蹦床函数执行<code>sum</code>, 就不会发生调用栈溢出. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">trampoline</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line">&gt;<span class="comment">// 100001</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-真正的尾递归优化"><a href="#b-真正的尾递归优化" class="headerlink" title="b) 真正的尾递归优化"></a>b) 真正的尾递归优化</h5><blockquote><p>蹦床函数并不是真正的尾递归优化, 下面的实现才是. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tco</span>(<span class="params">f</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> value;</span><br><span class="line"> <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">accumulator</span>(<span class="params"></span>) &#123;</span><br><span class="line">   accumulated.<span class="title function_">push</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">   <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">     active = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">while</span> (accumulated.<span class="property">length</span>) &#123;</span><br><span class="line">       value = f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, accumulated.<span class="title function_">shift</span>());</span><br><span class="line">     &#125;</span><br><span class="line">     active = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> sum = <span class="title function_">tco</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (y &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> x</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">&gt;<span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>tco</code>函数是尾递归优化的实现, 它的奥妙就在于状态变量<code>active</code>. 默认情况下, 这个变量是不激活的. 一旦进入尾递归优化的过程, 这个变量就激活了. 然后, 每一轮递归<code>sum</code>返回的都是 <strong>undefined</strong> , 所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数, 总是有值的, 这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行. 这样就很巧妙地将“递归”改成了“循环”, 而后一轮的参数会取代前一轮的参数, 保证了调用栈只有一层. </p></blockquote><h4 id="⑦-尾调用优化默认关闭"><a href="#⑦-尾调用优化默认关闭" class="headerlink" title="⑦ 尾调用优化默认关闭"></a>⑦ 尾调用优化默认关闭</h4><blockquote><p>看到这想必一定很好奇, 既然尾调用优化如此高效, 为何都默认关闭了这个特性呢？答案分为两方面: </p><ol><li>** <code>隐式优化问题</code> **: 由于引擎消除尾递归是隐式的, 函数是否符合尾调用而被消除了尾递归很难被程序员自己辨别；</li><li>** <code>调用栈丢失问题</code> **: 尾调用优化要求除掉尾调用执行时的调用堆栈, 这将导致执行流中的堆栈信息丢失. </li></ol><p>Chrome下使用尾递归写法的方法依旧出现调用栈溢出的原因在于: </p><ol><li>直接原因:  各大浏览器（除了<code>safari</code>）根本就没部署尾调用优化；</li><li>根本原因:  尾调用优化依旧有隐式优化和调用栈丢失的问题；</li></ol><p>既然尾调用优化是默认关闭的, 是不是说尾调用没什么用了呢？</p><blockquote><p>其实不然, 尾调用是函数式编程一个重要的概念, 合理的应用尾调用可以大大提高我们代码的可读性和可维护性, 相比带来的一点性能损失, 写更优雅更易读的代码更为的重要</p></blockquote></blockquote><h2 id="7、对象的拓展"><a href="#7、对象的拓展" class="headerlink" title="7、对象的拓展"></a>7、对象的拓展</h2><h3 id="Ⅰ-概括总结-4"><a href="#Ⅰ-概括总结-4" class="headerlink" title="Ⅰ- 概括总结"></a>Ⅰ- 概括总结</h3><blockquote><blockquote><p><strong>对象的新增方法与用法</strong></p></blockquote><ol><li><strong>简洁表示法</strong>: 直接写入变量和函数作为对象的属性和方法(<code>&#123; prop, method() &#123;&#125; &#125;</code>)</li><li> <strong>属性名表达式</strong>: 字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>, 不能与上同时使用)</li><li><strong>方法的name属性</strong>: 返回方法函数名 –&gt;此处与函数很像,因为本质上函数就是一种特殊对象</li></ol><ul><li>取值函数(getter)和存值函数(setter): <code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li><li>bind返回的函数: <code>bound 函数名</code></li><li>Function构造函数返回的函数实例: <code>anonymous</code></li></ul><ol start="4"><li> <strong>属性的可枚举性和遍历</strong>: 描述对象的<code>enumerable</code></li><li> <strong>super关键字</strong>: 指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li><li> <strong>Object.is()</strong>: 对比两值是否相等</li><li> <strong>Object.assign()</strong>: 合并对象(浅拷贝), 返回原对象  (<code>常用</code>)</li><li> <strong>Object.getPrototypeOf()</strong>: 返回对象的原型对象</li><li> <strong>Object.setPrototypeOf()</strong>: 设置对象的原型对象</li><li> <strong><strong>proto</strong></strong>: 返回或设置对象的原型对象</li></ol><blockquote><p><strong>属性遍历</strong></p></blockquote><ol><li>描述: <code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></li><li>遍历</li></ol><ul><li> [ for-in ] : 遍历对象<code>自身可继承可枚举</code>属性</li><li> [Object.keys()] : 返回对象<code>自身可枚举</code>属性键 [ key ] 组成的数组</li><li> [Object.getOwnPropertyNames()] : 返回对象<code>自身非Symbol</code>属性键 [ key ] 组成的数组</li><li><code>Object.getOwnPropertySymbols()</code>: 返回对象<code>自身Symbol</code>属性键 [ key ] 组成的数组</li><li><code>Reflect.ownKeys()</code>: 返回对象<code>自身全部</code>属性键 [ key ] 组成的数组</li></ul><ol start="3"><li>规则</li></ol><ul><li>首先遍历所有数值键, 按照数值升序排列</li><li>其次遍历所有字符串键, 按照加入时间升序排列</li><li>最后遍历所有Symbol键, 按照加入时间升序排列</li></ul></blockquote><h3 id="Ⅱ-属性的简洁表示"><a href="#Ⅱ-属性的简洁表示" class="headerlink" title="Ⅱ - 属性的简洁表示"></a>Ⅱ - 属性的简洁表示</h3><h4 id="①-属性的简写"><a href="#①-属性的简写" class="headerlink" title="① 属性的简写"></a>① 属性的简写</h4><blockquote><p>ES6 允许在大括号里面, 直接写入变量和函数, 作为对象的属性和方法. 这样的书写更加简洁. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">&gt;<span class="comment">//baz == &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>foo</code>直接写在大括号里面. 这时, 属性名就是变量名, 属性值就是变量值. 下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> &#123;x, y&#125;;&#125;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-方法的简写"><a href="#②-方法的简写" class="headerlink" title="② 方法的简写"></a>② 方法的简写</h4><blockquote><p>除了属性简写, 方法也可以简写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> o = &#123;</span><br><span class="line">&gt;<span class="title function_">method</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> o = &#123;</span><br><span class="line">&gt;<span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>; &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个实际的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> birth = <span class="string">&#x27;2000/01/01&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">&gt;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&gt;<span class="comment">//等同于birth: birth</span></span><br><span class="line">&gt;birth,</span><br><span class="line">&gt;<span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">&gt;<span class="title function_">hello</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>); &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值, 将会非常方便. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">getPoint</span>()</span><br><span class="line">&gt;<span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-简洁写法在CommonJS-模块的应用"><a href="#③-简洁写法在CommonJS-模块的应用" class="headerlink" title="③ 简洁写法在CommonJS 模块的应用"></a>③ 简洁写法在CommonJS 模块的应用</h4><blockquote><p>CommonJS 模块输出一组变量, 就非常合适使用简洁写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getItem</span> (key) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>; <span class="comment">//属性名表达式+三元表达式</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">setItem</span> (key, value) &#123;</span><br><span class="line">&gt;ms[key] = value;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">clear</span> () &#123;</span><br><span class="line">&gt;ms = &#123;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = &#123; getItem, setItem, clear &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">&gt;<span class="attr">getItem</span>: getItem,</span><br><span class="line">&gt;<span class="attr">setItem</span>: setItem,</span><br><span class="line">&gt;<span class="attr">clear</span>: clear</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-简洁写法在-属性-赋值器-和-取值器-中的应用"><a href="#④-简洁写法在-属性-赋值器-和-取值器-中的应用" class="headerlink" title="④ 简洁写法在 属性 赋值器 和 取值器 中的应用"></a>④ 简洁写法在 属性 赋值器 和 取值器 中的应用</h4><blockquote><p>属性的赋值器（setter）和取值器（getter）, 事实上也是采用这种写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> cart = &#123;</span><br><span class="line">&gt;<span class="attr">_wheels</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">&gt;get wheels () &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_wheels</span>;</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;set wheels (value) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">_wheels</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;数值太小了！&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">_wheels</span> = value;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-简洁写法在打印对象时的应用"><a href="#⑤-简洁写法在打印对象时的应用" class="headerlink" title="⑤ 简洁写法在打印对象时的应用"></a>⑤ 简洁写法在打印对象时的应用</h4><blockquote><p>简洁写法在打印对象时也很有用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> user = &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(user, foo)</span><br><span class="line">&gt;<span class="comment">// &#123;name: &quot;test&quot;&#125; &#123;bar: &quot;baz&quot;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;user, foo&#125;)</span><br><span class="line">&gt;<span class="comment">// &#123;user: &#123;name: &quot;test&quot;&#125;, foo: &#123;bar: &quot;baz&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>console.log</code>直接输出<code>user</code>和<code>foo</code>两个对象时, 就是两组键值对, 可能会混淆. 把它们放在大括号里面输出, 就变成了对象的简洁表示法, 每组键值对前面会打印对象名, 这样就比较清晰了. </p><p>注意, 简写的对象方法不能用作构造函数, 会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">new</span> obj.<span class="title function_">f</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>f</code>是一个简写的对象方法, 所以<code>obj.f</code>不能当作构造函数使用. </p></blockquote><h3 id="Ⅲ-方法的-name-属性"><a href="#Ⅲ-方法的-name-属性" class="headerlink" title="Ⅲ - 方法的 name 属性"></a>Ⅲ - 方法的 name 属性</h3><blockquote><p>与函数拓展中的name差不多,可以稍微过一眼即可</p><p>函数的<code>name</code>属性, 返回函数名. 对象方法也是函数, 因此也有<code>name</code>属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> person = &#123;</span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;person.<span class="property">sayName</span>.<span class="property">name</span>   <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 方法的<code>name</code>属性返回函数名（即方法名）. </p><p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>）, 则<code>name</code>属性不是在该方法上面, 而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面, 返回值是方法名前加上<code>get</code>和<code>set</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">foo</span>() &#123;&#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;obj.<span class="property">foo</span>.<span class="property">name</span></span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//返回指定对象上一个自有属性对应的属性描述符. （自有属性指的是直接赋予该对象的属性, 不需要从原型链上进行查找的属性）</span></span><br><span class="line"></span><br><span class="line">&gt;descriptor.<span class="property">get</span>.<span class="property">name</span> <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">&gt;descriptor.<span class="property">set</span>.<span class="property">name</span> <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure><p>有两种特殊情况: <code>bind</code>方法创造的函数, <code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数, <code>name</code>属性返回<code>anonymous</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> doSomething = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;doSomething.<span class="title function_">bind</span>().<span class="property">name</span> <span class="comment">// &quot;bound doSomething&quot;</span></span><br></pre></td></tr></table></figure><p>如果对象的方法是一个 Symbol 值, 那么<code>name</code>属性返回的是这个 Symbol 值的描述. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> key1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> key2 = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [key1]() &#123;&#125;,</span><br><span class="line"> [key2]() &#123;&#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;obj[key1].<span class="property">name</span> <span class="comment">// &quot;[description]&quot;</span></span><br><span class="line">&gt;obj[key2].<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>key1</code>对应的 Symbol 值有描述, <code>key2</code>没有. </p></blockquote><h3 id="Ⅳ-属性的可枚举性和遍历"><a href="#Ⅳ-属性的可枚举性和遍历" class="headerlink" title="Ⅳ - 属性的可枚举性和遍历"></a>Ⅳ - 属性的可枚举性和遍历</h3><h4 id="①-可枚举性"><a href="#①-可枚举性" class="headerlink" title="① 可枚举性"></a>① 可枚举性</h4><blockquote><p>对象的每个属性都有一个描述对象（Descriptor）, 用来控制该属性的行为.   [ Object.getOwnPropertyDescriptor ] 方法可以获取该属性的描述对象.   –&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">详见,点我传送</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">//  &#123;</span></span><br><span class="line">&gt;<span class="comment">//    value: 123,</span></span><br><span class="line">&gt;<span class="comment">//    writable: true,</span></span><br><span class="line">&gt;<span class="comment">//    enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//    configurable: true</span></span><br><span class="line">&gt;<span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><p>描述对象的<code> [ enumerable ] 属性, 称为“可枚举性”</code>, 如果该属性为 [ false ], 就表示某些操作会忽略当前属性. </p><p>目前, 有四个操作会忽略<code>enumerable</code>为 [ false ] 的属性. </p><ol><li><strong>for…in循环</strong>: 只遍历对象自身的和继承的可枚举的属性. </li><li><strong>Object.keys()</strong>: 返回对象自身的所有可枚举的属性的键名. </li><li><strong>JSON.stringify()</strong>: 只串行化对象自身的可枚举的属性. </li><li><strong>Object.assign()</strong>:  忽略<code>enumerable</code>为<code>false</code>的属性, 只拷贝对象自身的可枚举的属性. </li></ol><p>这四个操作之中, 前三个是 ES5 就有的, 最后一个 [ Object.assign() ] 是 ES6 新增的. 其中, 只有<code>for...in</code>会返回继承的属性, 其他三个方法都会忽略继承的属性, 只处理对象自身的属性. 实际上, 引入“可枚举”（<code>enumerable</code>）这个概念的最初目的, 就是让某些属性可以规避掉<code>for...in</code>操作, 不然所有内部属性和方法都会被遍历到. 比如, 对象原型的<code>toString</code>方法, 以及数组的<code>length</code>属性, 就通过“可枚举性”, 从而避免被<code>for...in</code>遍历到. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;toString&#x27;</span>).<span class="property">enumerable</span></span><br><span class="line">&gt;<span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>([], <span class="string">&#x27;length&#x27;</span>).<span class="property">enumerable</span></span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>, 因此<code>for...in</code>不会遍历到这两个继承自原型的属性. </p><p>另外 , ES6 规定, 所有 Class 的原型的方法都是不可枚举的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="keyword">class</span> &#123;<span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;&#125;.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo&#x27;</span>).<span class="property">enumerable</span></span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>总的来说, 操作中引入继承的属性会让问题复杂化, 大多数时候, 我们只关心对象自身的属性. 所以, <code>尽量不要用 [ for...in ] 循环, 而用 [ Object.keys() ] 代替</code>. </p></blockquote><h4 id="②-属性的遍历方法"><a href="#②-属性的遍历方法" class="headerlink" title="② 属性的遍历方法"></a>② 属性的遍历方法</h4><blockquote><p>ES6 一共有 5 种方法可以遍历对象的属性. </p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）. </p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组, 包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名. </p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组, 包含对象自身的所有属性（不含 Symbol 属性, 但是包括不可枚举属性）的键名. </p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组, 包含对象自身的所有 Symbol 属性的键名. </p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组, 包含对象自身的（不含继承的）所有键名, 不管键名是 Symbol 或字符串, 也不管是否可枚举. </p><p>以上的 5 种方法遍历对象的键名, 都遵守同样的属性遍历的次序规则. </p><ol><li>首先遍历所有数值键, 按照数值升序排列. </li><li>其次遍历所有字符串键, 按照加入时间升序排列. </li><li>最后遍历所有 Symbol 键, 按照加入时间升序排列. </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(&#123; [<span class="title class_">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line">&gt;<span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Reflect.ownKeys</code>方法返回一个数组, 包含了参数对象的所有属性. 这个数组的属性次序是这样的, 首先是数值属性<code>2</code>和<code>10</code>, 其次是字符串属性<code>b</code>和<code>a</code>, 最后是 Symbol 属性. </p></blockquote><h3 id="Ⅴ-super-关键字"><a href="#Ⅴ-super-关键字" class="headerlink" title="Ⅴ- super 关键字"></a>Ⅴ- super 关键字</h3><blockquote><p>我们知道, <code>this</code>关键字总是指向函数所在的当前对象 , ES6 又新增了另一个类似的关键字 [ super ], <code>指向当前对象的原型对象</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proto = &#123; <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line"> <span class="title function_">find</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line">&gt;obj.<span class="title function_">find</span>() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>obj.find()</code>方法之中, 通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性. </p><p>注意, <code>super</code>关键字表示原型对象时, 只能用在对象的方法之中, 用在其他地方都会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面三种<code>super</code>的用法都会报错, 因为对于 JavaScript 引擎来说, 这里的<code>super</code>都没有用在对象的方法之中. 第一种写法是<code>super</code>用在属性里面, 第二种和第三种写法是<code>super</code>用在一个函数里面, 然后赋值给<code>foo</code>属性. 目前, 只有对象方法的简写法可以让 JavaScript 引擎确认, 定义的是对象的方法. </p><p>JavaScript 引擎内部, <code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proto = &#123;</span><br><span class="line"> <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">x</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line"></span><br><span class="line">&gt;obj.<span class="title function_">foo</span>() <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法, 但是绑定的<code>this</code>却还是当前对象<code>obj</code>, 因此输出的就是<code>world</code>. </p></blockquote><h3 id="Ⅵ-对象的拓展运算符"><a href="#Ⅵ-对象的拓展运算符" class="headerlink" title="Ⅵ -  对象的拓展运算符  ( ... )"></a>Ⅵ -  对象的拓展运算符  ( <code>...</code> )</h3><h4 id="①-对象的赋值解构"><a href="#①-对象的赋值解构" class="headerlink" title="① 对象的赋值解构"></a>① 对象的赋值解构</h4><blockquote><p>对象的解构赋值用于从一个对象取值, 相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性, 分配到指定的对象上面. 所有的键和它们的值, 都会拷贝到新对象上面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">&gt;<span class="comment">//x == 1</span></span><br><span class="line">&gt;<span class="comment">//y == 2</span></span><br><span class="line">&gt;<span class="comment">//z == &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量 [ z ] 是解构赋值所在的对象. 它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>）, 将它们连同值一起拷贝过来. </p><p>由于解构赋值要求等号右边是一个对象, 所以如果等号右边是 <strong>undefined</strong> 或 <strong>null</strong> , 就会报错, 因为它们无法转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; ...z &#125; = <span class="literal">null</span>; <span class="comment">// 运行时错误</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; ...z &#125; = <span class="literal">undefined</span>; <span class="comment">// 运行时错误</span></span><br></pre></td></tr></table></figure><p>解构赋值必须是最后一个参数, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; ...x, y, z &#125; = someObject; <span class="comment">// 句法错误</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; x, ...y, ...z &#125; = someObject; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure><p>上面代码中, 解构赋值不是最后一个参数, 所以会报错. </p><p>注意 : <code>解构赋值的拷贝是浅拷贝</code>, 即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用, 而不是这个值的副本. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">&gt;obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>; <span class="comment">//对原对象进行修改操作</span></span><br><span class="line">&gt;x.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2  赋值解构出来的[x]对应的值也同样进行了修改</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>x</code>是解构赋值所在的对象, 拷贝了对象<code>obj</code>的<code>a</code>属性. <code>a</code>属性引用了一个对象, 修改这个对象的值, 会影响到解构赋值对它的引用. </p></blockquote><h4 id="②-扩展运算符的解构赋值"><a href="#②-扩展运算符的解构赋值" class="headerlink" title="② 扩展运算符的解构赋值"></a>② 扩展运算符的解构赋值</h4><blockquote><p>另外, 扩展运算符的解构赋值, 不能复制继承自原型对象的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;o2.<span class="property">__proto__</span> = o1;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">&gt;o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">&gt;o3.<span class="property">a</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>o3</code>复制了<code>o2</code>, 但是只复制了<code>o2</code>自身的属性, 没有复制它的原型对象<code>o1</code>的属性. </p><p>下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&gt;o.<span class="property">z</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; x, ...newObj &#125; = o;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; y, z &#125; = newObj;</span><br><span class="line">&gt;x <span class="comment">// 1</span></span><br><span class="line">&gt;y <span class="comment">// undefined</span></span><br><span class="line">&gt;z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>x</code>是单纯的解构赋值, 所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值, 只能读取对象<code>o</code>自身的属性, 所以变量<code>z</code>可以赋值成功, 变量<code>y</code>取不到值. ES6 规定, 变量声明语句之中, 如果使用解构赋值, 扩展运算符后面必须是一个变量名, 而不能是一个解构赋值表达式, 所以上面代码引入了中间变量<code>newObj</code>, 如果写成下面这样会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">&gt;<span class="comment">// SyntaxError: ... must be followed by an identifier in declaration contexts</span></span><br><span class="line">&gt;<span class="comment">// SyntaxError:… 在声明上下文中必须后跟标识符  </span></span><br></pre></td></tr></table></figure><p>解构赋值的一个用处, 是扩展某个函数的参数, 引入其他操作. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">&gt;<span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">baseFunction</span>(restConfig);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数, 函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展, 能够接受多余的参数, 并且保留原始函数的行为. </p></blockquote><h4 id="③-扩展运算符"><a href="#③-扩展运算符" class="headerlink" title="③ 扩展运算符"></a>③ 扩展运算符</h4><blockquote><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性, 拷贝到当前对象之中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">&gt;<span class="comment">// n == &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>由于数组是特殊的对象, 所以对象的扩展运算符也可以用于数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> foo = &#123; ...[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] &#125;;</span><br><span class="line">&gt;foo</span><br><span class="line">&gt;<span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空对象, 则没有任何效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line">&gt;<span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>如果扩展运算符后面不是对象, 则会自动将其转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(1)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="number">1</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 扩展运算符后面是整数<code>1</code>, 会自动转为数值的包装对象<code>Number&#123;1&#125;</code>. 由于该对象没有自身属性, 所以返回一个空对象. </p><p>下面的栗子都是类似的道理. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(true)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="literal">true</span>&#125; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(undefined)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="literal">undefined</span>&#125; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(null)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="literal">null</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>但是, 如果扩展运算符后面是字符串, 它会自动转成一个类似数组的对象, 因此返回的不是空对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;...<span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line">&gt;<span class="comment">// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>对象的扩展运算符等同于使用 [ Object.assign() ] 方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于 浅拷贝</span></span><br><span class="line">&gt;<span class="keyword">let</span> aClone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><p>上面的栗子只是拷贝了对象实例的属性, 如果想完整克隆一个对象, 还拷贝对象原型的属性, 可以采用下面的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 写法一</span></span><br><span class="line">&gt;<span class="keyword">const</span> clone1 = &#123;</span><br><span class="line"> <span class="attr">__proto__</span>: <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), <span class="comment">//利用[getPrototypeOf]获取原型,将其附加到自身原型上</span></span><br><span class="line"> ...obj</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写法二</span></span><br><span class="line">&gt;<span class="keyword">const</span> clone2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)),</span><br><span class="line"> obj</span><br><span class="line">&gt;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写法三</span></span><br><span class="line">&gt;<span class="keyword">const</span> clone3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure><p>上面代码中, 写法一的 [  [ <code>__proto__</code> ]  ] 属性在非浏览器的环境不一定部署, 因此推荐使用写法二和写法三. </p><p>扩展运算符可以用于合并两个对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> ab = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性, 放在扩展运算符后面, 则扩展运算符内部的同名属性会被覆盖掉. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithOverrides = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中,<code>a</code>对象的 [ x ] 属性和 [ y ] 属性, <code>拷贝到新对象后会被同名的 [x,y] 属性覆盖掉</code>. </p><p>这用来修改现有对象部分的属性就很方便了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> newVersion = &#123;</span><br><span class="line"> ...previousVersion,</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;New Name&#x27;</span> <span class="comment">//  重写name属性</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>newVersion</code>对象自定义了<code>name</code>属性, 其他属性全部复制自<code>previousVersion</code>对象. </p><p>如果把自定义属性放在扩展运算符前面, 就变成了设置新对象的默认属性值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;; <span class="comment">//如果a中没有 x、y 属性,则相当于赋默认值.有则覆盖</span></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithDefaults = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithDefaults = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br></pre></td></tr></table></figure><p>与数组的扩展运算符一样, 对象的扩展运算符后面可以跟表达式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</span><br><span class="line"> <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>扩展运算符的参数对象之中, 如果有取值函数<code>get</code>, 这个函数是会执行的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = &#123;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">x</span>() &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;not throw yet&#x27;</span>);&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&gt;<span class="keyword">let</span> aWithXGetter = &#123; ...a &#125;; <span class="comment">// 报错  --&gt;因为[get]会自动执行,就不是赋值解构操作了</span></span><br></pre></td></tr></table></figure><p>上面栗子中, 取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行, 导致报错. </p></blockquote><h3 id="Ⅶ-对象的新增方法"><a href="#Ⅶ-对象的新增方法" class="headerlink" title="Ⅶ -  对象的新增方法"></a>Ⅶ -  对象的新增方法</h3><blockquote><p>本来不想将这些新增方法<code>摘录</code>举例至此,但后面开发(源码学习)过程中发现这些方法应用频繁,所以还是罗列出来,</p><p>同时并不止是es6部分,而是将ES系列常用的都列举于此,此部分相对容易混淆,可以先看一遍,在自己开发过程使用到的时候再去巩固及加深理解</p></blockquote><h4 id="①-Object-is"><a href="#①-Object-is" class="headerlink" title="① Object.is()"></a>① Object.is()</h4><blockquote><p>ES5 比较两个值是否相等，只有两个运算符: 相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）. 它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>. JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等. </p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题.  [ Object.is ] 就是部署这个算法的新方法. 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个: 一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line">&gt;<span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 [ Object.is ] . –&gt;其实就是将无法判断的两个特殊清空特殊处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">     <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">     <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 针对NaN的情况</span></span><br><span class="line">   <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Object-assign"><a href="#②-Object-assign" class="headerlink" title="② Object.assign()"></a>② Object.assign()</h4><blockquote><p>开发中常能见到,这个方法还是要着重了解的,需要注意的就是此方法为:** <code>浅拷贝</code> **</p></blockquote><h5 id="a-基本用法"><a href="#a-基本用法" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><p>[ Object.assign() ] 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">&gt;target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>[ Object.assign() ] 方法的第一个参数是目标对象，后面的参数都是源对象. </p><p>注意: 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则<code>后面的属性会覆盖前面的属性</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">&gt;target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数， [ Object.assign() ] 会直接返回该参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>由于 <strong>undefined</strong> 和 <strong>null</strong> 无法转成对象，所以如果它们作为参数，就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同. 首先，这些参数都会转成对象，如果无法转成对象，就会跳过. 这意味着，如果 <strong>undefined</strong> 和 <strong>null</strong> 不在首参数，就不会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错. 但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, v1, v2, v3);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略. 这是因为只有字符串的包装对象，会产生可枚举属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line">&gt;<span class="title class_">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line">&gt;<span class="title class_">Object</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被 [ Object.assign() ] 拷贝的. 只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝. </p><p>[ Object.assign() ] 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> &#125;)</span><br><span class="line">&gt;)</span><br><span class="line">&gt;<span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ Object.assign() ] 要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去. </p><p>属性名为 Symbol 值的属性，也会被 [ Object.assign() ] 拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="title class_">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line">&gt;<span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-注意点"><a href="#b-注意点" class="headerlink" title="b) 注意点"></a>b) 注意点</h5><h6 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="( 1 ) 浅拷贝"></a>( 1 ) 浅拷贝</h6><blockquote><p>[ Object.assign() ] 方法实行的是浅拷贝，而不是深拷贝. 也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">&gt;obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">&gt;obj2.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象， [ Object.assign() ] 拷贝得到的是这个对象的引用. 这个对象的任何变化，都会反映到目标对象上面. </p></blockquote><h6 id="2-同名属性的替换"><a href="#2-同名属性的替换" class="headerlink" title="( 2 ) 同名属性的替换"></a>( 2 ) 同名属性的替换</h6><blockquote><p>对于这种嵌套的对象，一旦遇到同名属性， [ Object.assign() ] 的处理方法是替换，而不是添加. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line">&gt;<span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line">&gt;<span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到 <strong>{ a: { b: ‘hello’, d: ‘e’ } }</strong> 的结果. 这通常不是开发者想要的，需要特别小心. </p><p>一些函数库提供 [ Object.assign() ] 的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并. </p></blockquote><h6 id="3-数组的处理"><a href="#3-数组的处理" class="headerlink" title="( 3 ) 数组的处理"></a>( 3 ) 数组的处理</h6><blockquote><p>[ Object.assign() ] 可以用来处理数组，但是会把数组视为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&gt;<span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ Object.assign() ] 把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>. </p></blockquote><h6 id="4-取值函数的处理"><a href="#4-取值函数的处理" class="headerlink" title="( 4 ) 取值函数的处理"></a>( 4 ) 取值函数的处理</h6><blockquote><p>[ Object.assign() ] 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> source = &#123;  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line">&gt;<span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数， [ Object.assign() ] 不会复制这个取值函数，只会拿到值以后，将这个值复制过去</p></blockquote><h5 id="c-常见用途"><a href="#c-常见用途" class="headerlink" title="c) 常见用途"></a>c) 常见用途</h5><h6 id="1-为对象添加属性"><a href="#1-为对象添加属性" class="headerlink" title="( 1 ) 为对象添加属性"></a>( 1 ) 为对象添加属性</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;   <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;) &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过 [ Object.assign() ] 方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例. </p></blockquote><h6 id="2-为对象添加方法"><a href="#2-为对象添加方法" class="headerlink" title="( 2 ) 为对象添加方法"></a>( 2 ) 为对象添加方法</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line"> <span class="title function_">someMethod</span>(<span class="params">arg1, arg2</span>) &#123;&#125;,</span><br><span class="line"> <span class="title function_">anotherMethod</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于下面的写法</span></span><br><span class="line">&gt;<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">someMethod</span> = <span class="keyword">function</span> (<span class="params">arg1, arg2</span>) &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">anotherMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中. </p></blockquote><h6 id="3-克隆对象"><a href="#3-克隆对象" class="headerlink" title="( 3 ) 克隆对象"></a>( 3 ) 克隆对象</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123; <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin) &#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆. </p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值. 如果想要保持继承链，可以采用下面的代码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> originProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(origin);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(originProto), origin);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>[ Object.getPrototypeOf() ] 方法:返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）. </p></blockquote><h6 id="4-合并多个对象"><a href="#4-合并多个对象" class="headerlink" title="( 4 ) 合并多个对象"></a>( 4 ) 合并多个对象</h6><blockquote><p>将多个对象合并到某个对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">merge</span> =(<span class="params">target, ...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">merge</span> =(<span class="params">...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure></blockquote><h6 id="5-为属性指定默认值"><a href="#5-为属性指定默认值" class="headerlink" title="( 5 ) 为属性指定默认值"></a>( 5 ) 为属性指定默认值</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line"> <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line"> options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options); <span class="comment">//利用其如果有同名属性,后面属性值会覆盖前面属性值的特性实现</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(options);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中， [ DEFAULTS ] 对象是默认值， <strong>options</strong>  对象是用户提供的参数.  [ Object.assign() ] 方法将 [ DEFAULTS ] 和 <strong>options</strong> 合并成一个新对象，如果两者有同名属性，则 <strong>options</strong> 的属性值会覆盖 [ DEFAULTS ] 的属性值. </p><p>注意，由于存在浅拷贝的问题， [ DEFAULTS ] 对象和 <strong>options</strong>  对象的所有属性的值，最好都是简单类型，不要指向另一个对象. 否则， [ DEFAULTS ] 对象的该属性很可能不起作用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line"> <span class="attr">url</span>: &#123;</span><br><span class="line">   <span class="attr">host</span>: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">   <span class="attr">port</span>: <span class="number">7070</span></span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line"> options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options); <span class="comment">//利用其如果有同名属性,后面属性值会覆盖前面属性值的特性实现</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(options);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">processContent</span>(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line">&gt;<span class="comment">// &#123;</span></span><br><span class="line">&gt;<span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line">&gt;<span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变. 实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了. </p></blockquote><h4 id="③-getOwnPropertyDescriptors"><a href="#③-getOwnPropertyDescriptors" class="headerlink" title="③ getOwnPropertyDescriptors()"></a>③ getOwnPropertyDescriptors()</h4><blockquote><p>此方法在开发前期基本很少用到,在源码阅读的时候比较容易遇到</p></blockquote><h5 id="a-基本用法-1"><a href="#a-基本用法-1" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><p>ES5 的  [ Object.getOwnPropertyDescriptor() ] 方法用来获取一个对象的所有自身属性的描述符. . ES2017 引入了 [ Object.getOwnPropertyDescriptors() ] 方法，返回指定对象所有自身属性（非继承属性）的描述对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">&gt;<span class="comment">// &#123; foo:</span></span><br><span class="line">&gt;<span class="comment">//    &#123; value: 123,</span></span><br><span class="line">&gt;<span class="comment">//      writable: true,</span></span><br><span class="line">&gt;<span class="comment">//      enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//      configurable: true &#125;,</span></span><br><span class="line">&gt;<span class="comment">//   bar:</span></span><br><span class="line">&gt;<span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line">&gt;<span class="comment">//      set: undefined,</span></span><br><span class="line">&gt;<span class="comment">//      enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//      configurable: true &#125;</span></span><br><span class="line">&gt;<span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ Object.getOwnPropertyDescriptors() ] 方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象. </p></blockquote><h5 id="b-方法的实现"><a href="#b-方法的实现" class="headerlink" title="b) 方法的实现"></a>b) 方法的实现</h5><blockquote><p>该方法的实现非常容易. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组. </span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">&gt;result[key] = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-此方法引入目的与常用用法"><a href="#c-此方法引入目的与常用用法" class="headerlink" title="c) 此方法引入目的与常用用法"></a>c) 此方法引入目的与常用用法</h5><h6 id="1-解决-Object-assign-无法正确拷贝-get-属性和-set-属性的问题"><a href="#1-解决-Object-assign-无法正确拷贝-get-属性和-set-属性的问题" class="headerlink" title="( 1 ) 解决 [ Object.assign() ] 无法正确拷贝 [ get ] 属性和 [set ] 属性的问题."></a>( 1 ) 解决 [ Object.assign() ] 无法正确拷贝 [ get ] 属性和 [set ] 属性的问题.</h6><blockquote><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> source = &#123;</span><br><span class="line">&gt;<span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target1, source);  <span class="comment">//结果该属性的值变成了 undefined . </span></span><br><span class="line">&gt;<span class="comment">//此时获取其属性信息进行查看</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#123; value: undefined,</span></span><br><span class="line">&gt;<span class="comment">//   writable: true,</span></span><br><span class="line">&gt;<span class="comment">//   enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了 <strong>undefined</strong> . 这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法. </p><p>这时， [ Object.getOwnPropertyDescriptors() ] 方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> source = &#123;</span><br><span class="line">&gt;<span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//1. Object.defineProperties()方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象. </span></span><br><span class="line">&gt;<span class="comment">//2. 先将[source]属性获取出来,配合 [ Object.defineProperties() ]方法实现正确拷贝</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(target2, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source));</span><br><span class="line">&gt;<span class="comment">//此时再次获取其属性信息进行查看</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target2, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#123; get: undefined,</span></span><br><span class="line">&gt;<span class="comment">//   set: [Function: set foo],</span></span><br><span class="line">&gt;<span class="comment">//   enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，两个对象合并的逻辑可以写成一个函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//其实就是用[ Object.defineProperties() ]方法返回的数据再用 [Object.defineProperties()]方法进行修改或定义属性</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">shallowMerge</span> = (<span class="params">target, source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(</span><br><span class="line">&gt;target,</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h6 id="2-将对象属性克隆到一个新对象-–-gt-浅拷贝"><a href="#2-将对象属性克隆到一个新对象-–-gt-浅拷贝" class="headerlink" title="( 2 ) 将对象属性克隆到一个新对象  –&gt; 浅拷贝"></a>( 2 ) 将对象属性克隆到一个新对象  –&gt; <code>浅拷贝</code></h6><blockquote><p>[ Object.getOwnPropertyDescriptors() ] 方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象. 这属于浅拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//该Object.create()方法创建一个新对象，使用现有对象作为新创建对象的原型( proto ). </span></span><br><span class="line">&gt;<span class="comment">//Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）. </span></span><br><span class="line">&gt;<span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 或者 --&gt;本质上一摸一样,只是用了箭头函数的方式写了,更简洁明了</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">shallowClone</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象<code>obj</code>. </p></blockquote><h6 id="3-继承对象"><a href="#3-继承对象" class="headerlink" title="( 3 ) 继承对象"></a>( 3 ) 继承对象</h6><blockquote><p>另外， [ Object.getOwnPropertyDescriptors() ] 方法可以实现一个对象继承另一个对象. 以前，继承另一个对象，常常写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt;<span class="attr">__proto__</span>: prot,</span><br><span class="line">&gt;<span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>ES6 规定 [  [ <code>__proto__</code> ]  ] 只有浏览器要部署，其他环境不用部署. 如果去除 [  [ <code>__proto__</code> ]  ] ，上面代码就要改成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//该Object.create()方法创建一个新对象，使用现有对象作为新创建对象的原型( proto ). </span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prot);</span><br><span class="line">&gt;obj.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">create</span>(prot),</span><br><span class="line">&gt;&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>有了 [ Object.getOwnPropertyDescriptors() ] ，我们就有了另一种写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">&gt;prot,</span><br><span class="line">&gt;<span class="comment">//获取对象原型属性</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h6 id="4-实现-Mixin（混入）模式"><a href="#4-实现-Mixin（混入）模式" class="headerlink" title="( 4 ) 实现 Mixin（混入）模式"></a>( 4 ) 实现 Mixin（混入）模式</h6><blockquote><p>[ Object.getOwnPropertyDescriptors() ] 也可以用来实现 Mixin（混入）模式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">mix</span> = (<span class="params">object</span>) =&gt; (&#123;</span><br><span class="line">&gt;<span class="attr">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.<span class="title function_">reduce</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">&gt;c, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(mixin)</span><br><span class="line">&gt;), object)</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// multiple mixins example</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> d = <span class="title function_">mix</span>(c).<span class="title function_">with</span>(a, b);</span><br><span class="line"></span><br><span class="line">&gt;d.<span class="property">c</span> <span class="comment">// &quot;c&quot;</span></span><br><span class="line">&gt;d.<span class="property">b</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line">&gt;d.<span class="property">a</span> <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作. </p><p>出于完整性的考虑， [ Object.getOwnPropertyDescriptors() ] 进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法. </p></blockquote><h4 id="④-proto-属性及其读、写操作"><a href="#④-proto-属性及其读、写操作" class="headerlink" title="④   [ __proto__ ]  属性及其读、写操作"></a>④   [ <code>__proto__</code> ]  属性及其读、写操作</h4><blockquote><p>JavaScript 语言的对象继承是通过原型链实现的. ES6 提供了更多原型对象的操作方法. </p></blockquote><h5 id="a-proto-属性"><a href="#a-proto-属性" class="headerlink" title="a)   [ __proto__ ]  属性"></a>a)   [ <code>__proto__</code> ]  属性</h5><blockquote><p>[  <code>__proto__</code>  ] 属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）. 目前，所有浏览器（包括 IE11）都部署了这个属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// es5 的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;obj.<span class="property">__proto__</span> = someOtherObj;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// es6 的写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someOtherObj);</span><br><span class="line">&gt;obj.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是  [ <code>__proto__</code> ]  前后的双下划线，说明它本质上是一个<strong>内部属性</strong>，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6. 标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的. 因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的[ Object.setPrototypeOf() ]（<code>写操作</code>）、[ Object.getPrototypeOf() ]（<code>读操作</code>）、<code>Object.create()</code>（生成操作）代替. </p><p>实现上， [  <code>__proto__</code>  ] 调用的是<code>Object.prototype.__proto__</code>，具体实现如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;__proto__&#x27;</span>, &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> _thisObj = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(_thisObj);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">proto</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">undefined</span> || <span class="variable language_">this</span> === <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">   <span class="keyword">if</span> (!<span class="title function_">isObject</span>(<span class="variable language_">this</span>))  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="title function_">isObject</span>(proto)) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">let</span> status = <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, proto);</span><br><span class="line">   <span class="keyword">if</span> (!status)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Object</span>(value) === value;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了 [  [ <code>__proto__</code> ]  ] 属性，该属性的值就是对象的原型. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">&gt;<span class="comment">// null</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-Object-setPrototypeOf-–-gt-写操作"><a href="#b-Object-setPrototypeOf-–-gt-写操作" class="headerlink" title="b) Object.setPrototypeOf()  –&gt;写操作"></a>b) Object.setPrototypeOf()  –&gt;写操作</h5><blockquote><p>[ Object.setPrototypeOf() ] 方法的作用与 [ <code>__proto__</code> ] 相同，用来设置一个对象的原型对象（prototype），返回参数对象本身. 它是 ES6 正式推荐的设置原型对象的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 格式</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 用法</span></span><br><span class="line">&gt;<span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">obj, proto</span>) &#123;</span><br><span class="line"> obj.<span class="property">__proto__</span> = proto;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line"></span><br><span class="line">&gt;proto.<span class="property">y</span> = <span class="number">20</span>;</span><br><span class="line">&gt;proto.<span class="property">z</span> = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">&gt;obj.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">&gt;obj.<span class="property">y</span> <span class="comment">// 20</span></span><br><span class="line">&gt;obj.<span class="property">z</span> <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性. </p><p>如果第一个参数不是对象，会自动转为对象. 但是由于返回的还是第一个参数，所以这个操作不会产生任何效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于 <strong>undefined</strong> 和 <strong>null</strong> 无法转为对象，所以如果第一个参数是 <strong>undefined</strong> 或 <strong>null</strong> ，就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-Object-getPrototypeOf"><a href="#c-Object-getPrototypeOf" class="headerlink" title="c) Object.getPrototypeOf()"></a>c) Object.getPrototypeOf()</h5><blockquote><p>该方法与 [ Object.setPrototypeOf() ] 方法配套，用于读取一个对象的原型对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure><p>下面是一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> rec = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span><span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(rec, <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，会被自动转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>)</span><br><span class="line">&gt;<span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>) === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数是 <strong>undefined</strong> 或 <strong>null</strong> ，它们无法转为对象，所以会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">undefined</span>)</span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-对象的keys-、values-、entries-方法"><a href="#⑤-对象的keys-、values-、entries-方法" class="headerlink" title="⑤  对象的keys()、values()、entries() 方法"></a>⑤  对象的keys()、values()、entries() 方法</h4><blockquote><p>这三个方法不得不说挺常用的,所以此处虽不是ES6的,但仍然在此处先给出 –&gt; 推测有的同学会只看ES6部分就不继续看了:dog:</p></blockquote><h5 id="a-Object-keys"><a href="#a-Object-keys" class="headerlink" title="a) Object.keys()"></a>a) Object.keys()</h5><blockquote><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的 [ Object.values() ] 和 [ Object.entries() ] ，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3&#125;</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-Object-values"><a href="#b-Object-values" class="headerlink" title="b) Object.values()"></a>b) Object.values()</h5><blockquote><p>[ Object.values() ] 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>. </p><p>[ Object.values() ] 只返回对象自身的可遍历属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ Object.create() ] 方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>， [ Object.values() ] 不会返回这个属性. 只要把<code>enumerable</code>改成<code>true</code>， [ Object.values() ] 就会返回属性<code>p</code>的值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>:</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure><p>[ Object.values() ] 会过滤属性名为 Symbol 值的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果 [ Object.values() ] 方法的参数是一个字符串，会返回各个字符组成的一个数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串会先转成一个类似数组的对象. 字符串的每个字符，就是该对象的一个属性. 因此， [ Object.values() ] 返回每个属性的键值，就是各个字符组成的一个数组. </p><p>如果参数不是对象， [ Object.values() ] 会先将其转为对象. 由于数值和布尔值的包装对象，都不会为实例添加非继承的属性. 所以， [ Object.values() ] 会返回空数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-Object-entries"><a href="#c-Object-entries" class="headerlink" title="c) Object.entries()"></a>c) Object.entries()</h5><blockquote><p>[ Object.entries() ] 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><p>除了返回值不一样，该方法的行为与 [ Object.values() ] 基本一致. </p><p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">entries</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，原对象有两个属性， [ Object.entries() ] 只输出属性名非 Symbol 值的属性. 将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性. </p><p>[ Object.entries() ] 的基本用途是遍历对象的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">   <span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// &quot;one&quot;: 1</span></span><br><span class="line">&gt;<span class="comment">// &quot;two&quot;: 2</span></span><br></pre></td></tr></table></figure><p>[ Object.entries() ] 方法的另一个用处是，将对象转为真正的<code>Map</code>结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line">&gt;map <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>自己实现 [ Object.entries() ] 方法，非常简单. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// Generator函数的版本</span></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">   <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 非Generator函数的版本</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> arr = [];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">   arr.<span class="title function_">push</span>([key, obj[key]]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-Object-fromEntries"><a href="#⑥-Object-fromEntries" class="headerlink" title="⑥ Object.fromEntries()"></a>⑥ Object.fromEntries()</h4><blockquote><p><code>Object.fromEntries()</code>方法是 [ Object.entries() ] 的逆操作，用于将一个键值对数组转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line"> [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">&gt;])</span><br><span class="line">&gt;<span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line">&gt;<span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map)</span><br><span class="line">&gt;<span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>))</span><br><span class="line">&gt;<span class="comment">// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="8、数组的拓展"><a href="#8、数组的拓展" class="headerlink" title="8、数组的拓展"></a>8、数组的拓展</h2><blockquote><p>对于前端而言,数组的操作是最频繁的,因为从服务端获取到的基本都是数组格式数据,其中方法最好是认真掌握</p></blockquote><h3 id="Ⅰ-概括与总结-1"><a href="#Ⅰ-概括与总结-1" class="headerlink" title="Ⅰ- 概括与总结"></a>Ⅰ- 概括与总结</h3><blockquote><blockquote><p><strong>新增的拓展</strong></p></blockquote><ul><li> <strong>扩展运算符(…)</strong>: 转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread参数</code>的逆运算)</li><li> <strong>Array.from()</strong>: 转换具有 [ Iterator接口 ] 的数据结构为真正数组，返回新数组</li></ul><ol><li>类数组对象: <code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>可遍历对象: <code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ol><ul><li> <strong>Array.of()</strong>: 转换一组值为真正数组，返回新数组</li><li> <strong>实例方法</strong></li></ul><ol><li><strong>copyWithin()</strong>: 把指定位置的成员复制到其他位置，返回原数组</li><li><strong>find()</strong>: 返回第一个符合条件的成员</li><li><strong>findIndex()</strong>: 返回第一个符合条件的成员索引值</li><li><strong>fill()</strong>: 根据指定值填充整个数组，返回原数组</li><li><strong>keys()</strong>: 返回以索引值为遍历器的对象</li><li><strong>values()</strong>: 返回以属性值为遍历器的对象</li><li><strong>entries()</strong>: 返回以索引值和属性值为遍历器的对象</li><li><strong>其他</strong>:毕竟只是概述,不过多列举,详细看下方</li></ol><ul><li> <strong>其他常用方法</strong>:此处将数组常用方法在下方详细部分列出 (不仅是ES6)</li><li> <strong>数组空位</strong>: ES6明确将数组空位转为 <strong>undefined</strong> (空位处理规不一，建议避免出现)</li></ul><blockquote><p><strong>扩展运算符在数组中的应用</strong></p></blockquote><ul><li>克隆数组: <code>const arr = [...arr1]</code></li><li>合并数组: <code>const arr = [...arr1, ...arr2]</code></li><li>拼接数组: <code>arr.push(...arr1)</code></li><li>代替apply: <code>Math.max.apply(null, [x, y])</code> =&gt; <code>Math.max(...[x, y])</code></li><li>转换字符串为数组: <code>[...&quot;hello&quot;]</code></li><li>转换类数组对象为数组: <code>[...Arguments, ...NodeList]</code></li><li>转换可遍历对象为数组: <code>[...String, ...Set, ...Map, ...Generator]</code></li><li>与数组解构赋值结合: <code>const [x, ...rest/spread] = [1, 2, 3]</code></li><li>计算Unicode字符长度: <code>Array.from(&quot;hello&quot;).length</code> =&gt; <code>[...&quot;hello&quot;].length</code></li></ul><blockquote><p><strong>重点难点</strong></p></blockquote><ul><li>使用[ keys() ]、[ values() ]、[ entries() ]返回的遍历器对象，可用 [ for-of ] 自动遍历或<code>next()</code>手动遍历</li></ul></blockquote><h3 id="Ⅱ-扩展运算符"><a href="#Ⅱ-扩展运算符" class="headerlink" title="Ⅱ - 扩展运算符"></a>Ⅱ - 扩展运算符</h3><h4 id="①-含义"><a href="#①-含义" class="headerlink" title="①  含义"></a>①  含义</h4><blockquote><p>扩展运算符（spread）是三个点（<code>...</code>）. 它好比 <code>rest 参数的逆运算</code>，将一个数组转为用逗号分隔的参数序列. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt;<span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">&gt;[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line">&gt;<span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p><code>该运算符主要用于函数调用</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line"> array.<span class="title function_">push</span>(...items);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">&gt;<span class="title function_">add</span>(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们都使用了扩展运算符. 该运算符将一个数组，变为参数序列. </p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line">&gt;<span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">&gt;<span class="title function_">f</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>扩展运算符后面还可以放置表达式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [</span><br><span class="line"> ...(x &gt; <span class="number">0</span> ? [<span class="string">&#x27;a&#x27;</span>] : []),</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">&gt;];</span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空数组，则不产生任何效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...[], <span class="number">1</span>]</span><br><span class="line">&gt;<span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p>注意，<code>只有函数调用时，扩展运算符才可以放在圆括号中</code>，否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&gt;<span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>((...[<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">&gt;<span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&gt;<span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用. </p></blockquote><h4 id="②-替代函数的-apply-方法"><a href="#②-替代函数的-apply-方法" class="headerlink" title="② 替代函数的 apply 方法"></a>② 替代函数的 apply 方法</h4><blockquote><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的写法</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6的写法</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的栗子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的写法</span></span><br><span class="line">&gt;<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的写法</span></span><br><span class="line">&gt;<span class="title class_">Math</span>.<span class="title function_">max</span>(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值. 有了扩展运算符以后，就可以直接用<code>Math.max</code>了. </p><p>另一个栗子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5的 写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">apply</span>(arr1, arr2);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法. 有了扩展运算符，就可以直接将数组传入<code>push</code>方法. </p><p>下面是另外一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;<span class="keyword">new</span> (<span class="title class_">Date</span>.<span class="property">bind</span>.<span class="title function_">apply</span>(<span class="title class_">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-扩展运算符的应用"><a href="#③-扩展运算符的应用" class="headerlink" title="③ 扩展运算符的应用"></a>③ 扩展运算符的应用</h4><h5 id="a-复制数组"><a href="#a-复制数组" class="headerlink" title="a) 复制数组"></a>a) 复制数组</h5><blockquote><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组 [<code> 浅拷贝</code>]. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">&gt;a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">&gt;a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针. 修改<code>a2</code>，会直接导致<code>a1</code>的变化. </p><p>ES5 只能用变通方法来复制数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> a2 = a1.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line">&gt;a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">&gt;a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响. </p><p>扩展运算符提供了复制数组的简便写法.  –&gt;这样就不会造成影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="comment">// 写法一</span></span><br><span class="line">&gt;<span class="keyword">const</span> a2 = [...a1];</span><br><span class="line">&gt;<span class="comment">// 写法二</span></span><br><span class="line">&gt;<span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆. </p><p><code>注意</code>:如果内部是引用数据类型,是不会改动到内部的引用,不懂的继续看下面 [ 合并数组 ] 的举例</p></blockquote><h5 id="b-合并数组"><a href="#b-合并数组" class="headerlink" title="b) 合并数组"></a>b) 合并数组</h5><blockquote><p>扩展运算符提供了数组合并的新写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5 的合并数组</span></span><br><span class="line">&gt;arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line">&gt;<span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的合并数组</span></span><br><span class="line">&gt;[...arr1, ...arr2, ...arr3]</span><br><span class="line">&gt;<span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>不过，这两种方法都是浅拷贝 ( 指的是内部数据如 { foo: 1 } 是存地址 ) ，使用的时候需要注意. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line">&gt;<span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> a3 = a1.<span class="title function_">concat</span>(a2);</span><br><span class="line">&gt;<span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">&gt;a3[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br><span class="line">&gt;a4[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>[ a3 ] 和 [ a4 ] 是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝</code>. 如果修改了引用指向的值，会同步反映到新数组. </p></blockquote><h5 id="c-与解构赋值结合"><a href="#c-与解构赋值结合" class="headerlink" title="c) 与解构赋值结合"></a>c) 与解构赋值结合</h5><blockquote><p>扩展运算符可以与解构赋值结合起来，用于生成数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;a = list[<span class="number">0</span>], rest = list.<span class="title function_">slice</span>(<span class="number">1</span>) <span class="comment">//此处是先取出第一个,然后从下标1处将其后的数据截取出</span></span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;[a, ...rest] = list</span><br></pre></td></tr></table></figure><p>下面是另外一些栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="comment">//first == 1</span></span><br><span class="line">&gt;<span class="comment">//rest  == [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">&gt;<span class="comment">//first == undefined</span></span><br><span class="line">&gt;<span class="comment">//rest  == []</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">&gt;<span class="comment">//first  == &quot;foo&quot;</span></span><br><span class="line">&gt;<span class="comment">//rest   == []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-字符串"><a href="#d-字符串" class="headerlink" title="d) 字符串"></a>d) 字符串</h5><blockquote><p>扩展运算符还可以将字符串转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line">&gt;<span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>.<span class="property">length</span> <span class="comment">// 4</span></span><br><span class="line">&gt;[...<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>].<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题. 因此，正确返回字符串长度的函数，可以像下面这样写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">length</span>(<span class="params">str</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> [...str].<span class="property">length</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">length</span>(<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题. 因此，最好都用扩展运算符改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> str = <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;y\uDE80\uD83Dx&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;[...str].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;y\uD83D\uDE80x&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确. </p></blockquote><h5 id="e-实现了-Iterator-接口的对象"><a href="#e-实现了-Iterator-接口的对象" class="headerlink" title="e) 实现了 Iterator 接口的对象"></a>e) 实现了 Iterator 接口的对象</h5><blockquote><p>任何定义了遍历器（Iterator）接口的对象 [此处不懂可以跳过先看下方,有给出详情]，都可以用扩展运算符转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象. 它不是数组，而是一个类似数组的对象. 这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*() &#123;</span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">let</span> num = <span class="variable language_">this</span>.<span class="title function_">valueOf</span>();</span><br><span class="line"> <span class="keyword">while</span> (i &lt; num) &#123;  <span class="keyword">yield</span> i++; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="number">5</span>]) <span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>上面代码中，先定义了<code>Number</code>对象的遍历器接口，扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后，就会调用这个接口，就会返回自定义的结果. </p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line"> <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错. 这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组.<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p></blockquote><h5 id="f-Map-和-Set-结构，Generator-函数"><a href="#f-Map-和-Set-结构，Generator-函数" class="headerlink" title="f) Map 和 Set 结构，Generator 函数"></a>f) Map 和 Set 结构，Generator 函数</h5><blockquote><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> go = <span class="keyword">function</span>*()&#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;[...<span class="title function_">go</span>()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组. </p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure></blockquote><p>=======</p><h5 id="f-Map-和-Set-结构，Generator-函数-1"><a href="#f-Map-和-Set-结构，Generator-函数-1" class="headerlink" title="f) Map 和 Set 结构，Generator 函数"></a>f) Map 和 Set 结构，Generator 函数</h5><blockquote><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> go = <span class="keyword">function</span>*()&#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;[...<span class="title function_">go</span>()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组. </p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Array-from"><a href="#Ⅲ-Array-from" class="headerlink" title="Ⅲ - Array.from()"></a>Ⅲ - Array.from()</h3><blockquote><p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代. </p></blockquote><h4 id="①-简单举例"><a href="#①-简单举例" class="headerlink" title="① 简单举例"></a>① 简单举例</h4><blockquote><p><code>Array.from</code>方法用于将两类对象转为真正的数组: 类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）. </p><p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">&gt;<span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">&gt;<span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5的写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// ES6的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-实际应用场景举栗"><a href="#②-实际应用场景举栗" class="headerlink" title="② 实际应用场景举栗"></a>② 实际应用场景举栗</h4><blockquote><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象. <code>Array.from</code>都可以将它们转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// NodeList对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(ps).<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> p.<span class="property">textContent</span>.<span class="property">length</span> &gt; <span class="number">100</span>;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// arguments对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>filter</code>方法. </p><p>只要是部署了 Iterator 接口的数据结构，<code>Array.from</code>都能将其转为数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(namesSet) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被<code>Array.from</code>转为真正的数组. </p><p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组 (上面有提到). </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// arguments对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// NodeList对象</span></span><br><span class="line">&gt;[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-不适用场景"><a href="#③-不适用场景" class="headerlink" title="③ 不适用场景"></a>③ 不适用场景</h4><blockquote><p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换. </p><p><code>Array.from</code>方法还支持类似数组的对象. 所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性. 因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是 <strong>undefined</strong> . 扩展运算符转换不了这个对象. </p><p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> toArray = (<span class="function">() =&gt;</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="property">from</span> ? <span class="title class_">Array</span>.<span class="property">from</span> : <span class="function"><span class="params">obj</span> =&gt;</span> [].<span class="property">slice</span>.<span class="title function_">call</span>(obj)</span><br><span class="line">&gt;)();</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-第二个参数的作用"><a href="#④-第二个参数的作用" class="headerlink" title="④ 第二个参数的作用"></a>④ 第二个参数的作用</h4><blockquote><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line">&gt;<span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p>下面的栗子是取出一组 DOM 节点的文本内容. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> spans = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;span.name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// map()</span></span><br><span class="line">&gt;<span class="keyword">let</span> names1 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.<span class="property">textContent</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Array.from()</span></span><br><span class="line">&gt;<span class="keyword">let</span> names2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.<span class="property">textContent</span>)</span><br></pre></td></tr></table></figure><p>下面的栗子将数组中布尔值为<code>false</code>的成员转为<code>0</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n || <span class="number">0</span>)</span><br><span class="line">&gt;<span class="comment">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure><p>另一个栗子是返回各种数据的类型. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">typesOf</span> () &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">typeof</span> value)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">typesOf</span>(<span class="literal">null</span>, [], <span class="title class_">NaN</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;object&#x27;, &#x27;object&#x27;, &#x27;number&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>. </p><p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能. 这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, <span class="function">() =&gt;</span> <span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;jack&#x27;, &#x27;jack&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数. 这种特性可以让该方法的用法变得非常灵活. </p><p><code>Array.from()</code>的另一个应用是: 将字符串转为数组，然后返回字符串的长度. 因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于<code>\uFFFF</code>的 Unicode 字符，算作两个字符的 bug. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">countSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(string).<span class="property">length</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-Array-of"><a href="#Ⅳ-Array-of" class="headerlink" title="Ⅳ- Array.of ( )"></a>Ⅳ- Array.of ( )</h3><h4 id="①-基本使用"><a href="#①-基本使用" class="headerlink" title="① 基本使用"></a>① 基本使用</h4><blockquote><p>[ Array.of ]方法用于将一组值，转换为数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足. 因为参数个数的不同，会导致<code>Array()</code>的行为有差异. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line">&gt;<span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样. 只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组. 参数个数只有一个时，实际上是指定数组的长度. </p><p>[ Array.of ]基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载. 它的行为非常统一. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>() <span class="comment">// []</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>[ Array.of ]总是返回参数值组成的数组. 如果没有参数，就返回一个空数组. </p></blockquote><h4 id="②-原生模拟-Array-of"><a href="#②-原生模拟-Array-of" class="headerlink" title="② 原生模拟 [ Array.of ]"></a>② 原生模拟 [ Array.of ]</h4><blockquote><p><code>Array.of</code>方法可以用下面的代码模拟实现. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ArrayOf</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-数组的实例方法"><a href="#Ⅴ-数组的实例方法" class="headerlink" title="Ⅴ- 数组的实例方法"></a>Ⅴ- 数组的实例方法</h3><blockquote><p>所谓实例方法,简单来说就是实例化后可以用 <code>[数组].方法名()</code>的方式调用的一类方法,其中有几个很常用,可以重点理解</p></blockquote><h4 id="①-数组实例的-copyWithin"><a href="#①-数组实例的-copyWithin" class="headerlink" title="①  数组实例的 copyWithin()"></a>①  数组实例的 copyWithin()</h4><blockquote><p>数组实例的 [ copyWithin() ] 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组. 也就是说，使用这个方法，<code>会修改当前数组</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">copyWithin</span>(target, start = <span class="number">0</span>, end = <span class="variable language_">this</span>.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><p>它接受三个参数. </p><ul><li>target（必需）: 从该位置开始替换数据. 如果为负值，表示倒数. </li><li>start（可选）: 从该位置开始读取数据，默认为 0. 如果为负值，表示从末尾开始计算. </li><li>end（可选）: 到该位置前停止读取数据，默认等于数组长度. 如果为负值，表示从末尾开始计算. </li></ul><p>这三个参数都应该是数值，如果不是，会自动转为数值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">&gt;<span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2. </p><p>下面是更多栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//从三号位开始读取,到四号位结束,得到[4],将其替换到0号位</span></span><br><span class="line">&gt;<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, -<span class="number">2</span>, -<span class="number">1</span>) <span class="comment">//从倒数2号位开始读取,到倒数一号位结束,得到[4],将其替换到0号位</span></span><br><span class="line">&gt;<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">&gt;[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">&gt;<span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line">&gt;<span class="keyword">let</span> i32a = <span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;i32a.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&gt;<span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line">&gt;<span class="comment">// 需要采用下面的写法</span></span><br><span class="line">&gt;[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&gt;<span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-数组实例的-find-和-findIndex"><a href="#②-数组实例的-find-和-findIndex" class="headerlink" title="② 数组实例的 find() 和 findIndex()"></a>② 数组实例的 find() 和 findIndex()</h4><blockquote><p>数组实例的 [ find ] 方法，用于找出第一个符合条件的数组成员. 它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员. 如果没有符合条件的成员，则返回 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line">&gt;<span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>上面代码找出数组中第一个小于 0 的成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&gt;&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中，[ find ] 方法的回调函数可以接受三个参数，依次为<code>当前的值、当前的位置和原数组</code>. </p><p>数组实例的 [ findIndex] 方法的用法与 [ find ] 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&gt;&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> v &gt; <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">&gt;[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].<span class="title function_">find</span>(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>上面的代码中， [ find ] 函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象. </p><p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的 [ indexOf ] 方法的不足. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">y</span> =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, y)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ indexOf ] 方法无法识别数组的<code>NaN</code>成员，但是 [ findIndex] 方法可以借助 [ Object.is ] 方法做到. </p></blockquote><h4 id="③-数组实例的-entries-，keys-和-values"><a href="#③-数组实例的-entries-，keys-和-values" class="headerlink" title="③ 数组实例的 entries()，keys() 和 values()"></a>③ 数组实例的 entries()，keys() 和 values()</h4><blockquote><p>ES6 提供三个新的方法——[ entries() ]，[ keys() ] 和 [ values() ]——用于遍历数组. 它们都返回一个遍历器对象.可以用<code>for...of</code>循环进行遍历，唯一的区别是[ keys() ]是对键名的遍历、[ values() ]是对键值的遍历，[ entries() ]是对键值对的遍历. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(index);&#125;</span><br><span class="line">&gt;<span class="comment">// 0</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);&#125;</span><br><span class="line">&gt;<span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&gt;<span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);&#125;</span><br><span class="line">&gt;<span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line">&gt;<span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> entries = letter.<span class="title function_">entries</span>();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-数组实例的-includes"><a href="#④-数组实例的-includes" class="headerlink" title="④ 数组实例的 includes()"></a>④ 数组实例的 includes()</h4><blockquote><p>[ Array.prototype.includes ] 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 [ includes ] 方法类似. ES2016 引入了该方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>. 如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>没有该方法之前，我们通常使用数组的 [ indexOf ] 方法，检查是否包含某个值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(el) !== -<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>[ indexOf ] 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观. 二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)</span><br><span class="line">&gt;<span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>[ includes ] 使用的是不一样的判断算法，就没有这个问题. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> contains = (<span class="function">() =&gt;</span></span><br><span class="line"> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span></span><br><span class="line">   ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.<span class="title function_">includes</span>(value)</span><br><span class="line">   : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.<span class="title function_">some</span>(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">&gt;)();</span><br><span class="line">&gt;<span class="title function_">contains</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;baz&#x27;</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与 [ includes ] 区分. </p><ul><li>Map 结构的<code>has</code>方法，是用来查找键名的，比如 [ Map.prototype.has(key) ] 、 [ WeakMap.prototype.has(key) ] 、 [ Reflect.has(target, propertyKey) ] . </li><li>Set 结构的<code>has</code>方法，是用来查找值的，比如 [ Set.prototype.has(value) ] 、 [ WeakSet.prototype.has(value) ] . </li></ul></blockquote><h4 id="⑤-数组实例的-flat-，flatMap"><a href="#⑤-数组实例的-flat-，flatMap" class="headerlink" title="⑤ 数组实例的 flat()，flatMap()"></a>⑤ 数组实例的 flat()，flatMap()</h4><blockquote><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组. 该方法返回一个新数组，对原数据没有影响. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>上面代码中，原数组的成员里面有一个数组， [ flat() ] 方法将子数组的成员取出来，添加在原来的位置. </p><p>[ flat() ] 默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 [ flat() ] 方法的参数写成一个整数，表示想要拉平的层数，默认为1. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ flat() ] 的参数为2，表示要“拉平”两层的嵌套数组. </p><p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>如果原数组有空位， [ flat() ] 方法会跳过空位</code>.  –&gt; 这个可以用作去除数组中空位,特殊场景好用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">flat</span>()</span><br><span class="line">&gt;<span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure><p>[ flatMap() ] 方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行 [ flat() ] 方法. 该方法返回一个新数组，不改变原数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">&gt;[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">&gt;<span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><p>[ flatMap() ] 只能展开一层数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line">&gt;<span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此 [ flatMap() ] 返回的还是一个嵌套数组. </p><p>[ flatMap() ] 方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr.<span class="title function_">flatMap</span>(<span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">currentValue[, index[, array]]</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;[, thisArg])</span><br></pre></td></tr></table></figure><p>[ flatMap() ] 方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>. </p></blockquote><h4 id="⑥-数组实例的-filter-–-gt-常用"><a href="#⑥-数组实例的-filter-–-gt-常用" class="headerlink" title="⑥ 数组实例的 filter() –&gt;常用"></a>⑥ 数组实例的 filter() –&gt;<code>常用</code></h4><blockquote><p><code>此方法非常常用</code>,一定要掌握的</p><p><code>filter()</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素.  不会改变原有数组</p></blockquote><h5 id="a-筛选对象数组中符合条件的"><a href="#a-筛选对象数组中符合条件的" class="headerlink" title="a) 筛选对象数组中符合条件的"></a>a) 筛选对象数组中符合条件的</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">Arr</span> = [</span><br><span class="line"> &#123; <span class="attr">look</span>: <span class="string">&#x27;帅&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;@hongjilin&#x27;</span>&#125;,</span><br><span class="line"> &#123; <span class="attr">look</span>: <span class="string">&#x27;很帅&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>&#125;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Arr</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> === <span class="string">&#x27;努力学习的汪&#x27;</span> )) <span class="comment">//&#123; look: &#x27;很帅&#x27;, name: &#x27;努力学习的汪&#x27; &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-筛选对象数组中不符合条件的"><a href="#b-筛选对象数组中不符合条件的" class="headerlink" title="b) 筛选对象数组中不符合条件的"></a>b) 筛选对象数组中不符合条件的</h5><blockquote><p>同样操作上面的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Arr</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">look</span> !== <span class="string">&#x27;很帅&#x27;</span> )) <span class="comment">//&#123; look: &#x27;帅&#x27;, name: &#x27;@hongjilin&#x27;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-去除数组中的空字符串、undefined、null"><a href="#c-去除数组中的空字符串、undefined、null" class="headerlink" title="c) 去除数组中的空字符串、undefined、null"></a>c) 去除数组中的空字符串、undefined、null</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> undefinedArr = [<span class="string">&#x27;这是undefined数组&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="literal">undefined</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="literal">undefined</span>]</span><br><span class="line">&gt;<span class="keyword">const</span> nullArr = [<span class="string">&#x27;这是null数组&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="literal">null</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="literal">null</span>]</span><br><span class="line">&gt;<span class="keyword">const</span> stringArr = [<span class="string">&#x27;这是空字符串数组&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="string">&#x27;&#x27;</span>] <span class="comment">//空字符串里面不能包含空格</span></span><br><span class="line">&gt;<span class="keyword">let</span> newArr =[] <span class="comment">//定义一个新数组来测试承接</span></span><br><span class="line">&gt;<span class="comment">//过滤 undefined</span></span><br><span class="line">&gt;newArr= undefinedArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)  <span class="comment">//log: [&quot;这是undefined数组&quot;, &quot;2&quot;, &quot;努力学习的汪&quot;]</span></span><br><span class="line">&gt;<span class="comment">//过滤 null</span></span><br><span class="line">&gt;newArr = nullArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">//log: [&quot;这是null数组&quot;, &quot;2&quot;, &quot;努力学习的汪&quot;]</span></span><br><span class="line">&gt;<span class="comment">//过滤空字符串</span></span><br><span class="line">newArr = stringArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">//log: [&quot;这是空字符串数组&quot;, &quot;2&quot;, &quot;努力学习的汪&quot;]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-筛选字符串、数字数组符合条件项"><a href="#d-筛选字符串、数字数组符合条件项" class="headerlink" title="d) 筛选字符串、数字数组符合条件项"></a>d) 筛选字符串、数字数组符合条件项</h5><blockquote><p>其实与上方对象数组筛选差不多,但稍微还是有所差别,举例出来,方便理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> numberArr = [<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>, <span class="number">96</span>,<span class="number">50</span>]</span><br><span class="line">&gt;<span class="keyword">const</span> stringArr = [<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;44&#x27;</span>,<span class="string">&#x27;42&#x27;</span>]</span><br><span class="line">&gt;<span class="keyword">let</span> newArr = []</span><br><span class="line">&gt;<span class="comment">//筛选数组中符合条件项</span></span><br><span class="line">&gt;newArr= numberArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;<span class="number">40</span>)  </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)   <span class="comment">//log: [50, 96, 50]</span></span><br><span class="line">&gt;<span class="comment">//过滤字符串数组符合条件项</span></span><br><span class="line">&gt;<span class="comment">//item.indexOf(&#x27;2&#x27;)是查找字符串中含有[&#x27;2&#x27;]的下标,当不含有时,返回-1</span></span><br><span class="line">&gt;newArr = stringArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">indexOf</span>(<span class="string">&#x27;2&#x27;</span>)&lt;<span class="number">0</span>) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)   <span class="comment">//log: [&quot;10&quot;, &quot;44&quot;]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="e-数组去重"><a href="#e-数组去重" class="headerlink" title="e) 数组去重"></a>e) 数组去重</h5><blockquote><p>可以利用 [ filter ] 方法实现去重,当然去重方式非常多,这里也是一种思路</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">x, index,self</span>)=&gt;</span>self.<span class="title function_">indexOf</span>(x)===index)  </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]</span></span><br></pre></td></tr></table></figure><p>这里列一个ES6提供的去重新方法 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//具体详情在下方 [Set] 相关知识点笔记中会给出</span></span><br><span class="line">&gt;<span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="title class_">NaN</span>,<span class="title class_">NaN</span>]</span><br><span class="line">&gt;<span class="keyword">let</span> res=<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));<span class="comment">//&#123;1,2,&quot;1&quot;,null,undefined,NaN&#125;</span></span><br><span class="line">&gt;<span class="comment">//or</span></span><br><span class="line">&gt;<span class="keyword">let</span> newarr=[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑦-数组实例的-map-–-gt-常用"><a href="#⑦-数组实例的-map-–-gt-常用" class="headerlink" title="⑦ 数组实例的 map() –&gt;常用"></a>⑦ 数组实例的 map() –&gt;<code>常用</code></h4><blockquote><p>定义: 对数组中的每个元素进行处理，得到新的数组；</p><p>特点: 不改变原有数据的结构和数据</p></blockquote><h5 id="a-常用方法举例"><a href="#a-常用方法举例" class="headerlink" title="a) 常用方法举例"></a>a) 常用方法举例</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> newArray = array.<span class="title function_">map</span>( <span class="function"><span class="params">value</span> =&gt;</span> value + <span class="number">1</span> ); <span class="comment">//此处用的箭头函数写法,看不懂的要回头看前方函数部分</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">//log: [2, 4, 7, 10]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(array);    <span class="comment">//log: [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-类似方法"><a href="#b-类似方法" class="headerlink" title="b) 类似方法"></a>b) 类似方法</h5><blockquote><p>类似效果实现方法:  for in , for , foreach</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> newArray2 = [];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> array) &#123; newArray2.<span class="title function_">push</span>(array[i] + <span class="number">1</span>)&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> newArray3 = [];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123; newArray3.<span class="title function_">push</span>(array[i] + <span class="number">1</span>)&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> newArray4 = [];</span><br><span class="line">&gt;array.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123; newArray4.<span class="title function_">push</span>(key * key)&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray2); <span class="comment">//log: [2, 4, 7, 10]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray3); <span class="comment">//log: [2, 4, 7, 10]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray4); <span class="comment">//log: [1, 9, 36, 81]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(array);<span class="comment">//log: [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure><p>与上述方法的区别:</p><ul><li>.map()方法使用return，进行回调；其他方法可不需要. </li><li>.map()方法直接对数组的每个元素进行操作，返回相同数组长度的数组；其他方法可扩展数组的长度. </li><li>.map() 不会对空数组进行检测. </li></ul></blockquote><h5 id="c-与-filter-区别"><a href="#c-与-filter-区别" class="headerlink" title="c) 与 filter() 区别"></a>c) 与 filter() 区别</h5><blockquote><p> [ filter() ] 主要用作筛选,并不会对数组中元素进行处理,只会根据匹配条件返回数组中符合条件元素;</p><p>[ map() ] 常用作将符合条件的元素进行加工,再返回出去的场景</p></blockquote><h4 id="⑧-数组实例的-some-、every"><a href="#⑧-数组实例的-some-、every" class="headerlink" title="⑧ 数组实例的 some() 、every()"></a>⑧ 数组实例的 some() 、every()</h4><blockquote><p><strong>some()</strong> : 方法测试数组中是不是至少有1个元素通过了被提供的函数测试. 它返回的是一个Boolean类型的值. </p><p><strong>every()</strong>: 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试. 它返回一个布尔值. </p></blockquote><h3 id="Ⅵ-数组的空位"><a href="#Ⅵ-数组的空位" class="headerlink" title="Ⅵ - 数组的空位"></a>Ⅵ - 数组的空位</h3><blockquote><p>数组的空位指，数组的某一个位置没有任何值. 比如，<code>Array</code>构造函数返回的数组都是空位. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组. </p><p>注意，空位不是<strong>undefined</strong>，一个位置的值等于<strong>undefined</strong>，依然是有值的. <code>空位是没有任何值</code>，[ in ]运算符可以说明这一点. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line">&gt;<span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值. </p><p>ES5 对空位的处理，已经很不一致了，<strong>大多数情况下会忽略空位</strong>. </p><ul><li>forEach(), filter(), reduce(),  every()  和 some() 都会跳过空位. </li><li> map() 会跳过空位，但会保留这个值</li><li> join()  和 toString() 会将空位视为 undefined ，而 <strong>undefined</strong> 和 <strong>null</strong>会被处理成空字符串. </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// forEach方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// filter方法</span></span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// every方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reduce方法</span></span><br><span class="line">&gt;[<span class="number">1</span>,,<span class="number">2</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// some方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">some</span>(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// map方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// join方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].<span class="title function_">join</span>(<span class="string">&#x27;#&#x27;</span>) <span class="comment">// &quot;#a##&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// toString方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].<span class="title function_">toString</span>() <span class="comment">// &quot;,a,,&quot;</span></span><br></pre></td></tr></table></figure><p>ES6 则是明确将空位转为 <strong>undefined</strong>. </p><p><code>Array.from</code>方法会将数组的空位，转为 <strong>undefined</strong>，也就是说，这个方法不会忽略空位. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">&gt;<span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><p>扩展运算符（<code>...</code>）也会将空位转为 <strong>undefined</strong>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">&gt;<span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><p><code>copyWithin()</code>会连空位一起拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,,].<span class="title function_">copyWithin</span>(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,&quot;a&quot;,,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p><code>fill()</code>会将空位视为正常的数组位置. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环也会遍历空位. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [, ,];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 1</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们. 如果改成<code>map</code>方法遍历，空位是会跳过的. </p><p>[ entries() ]、[ keys() ]、[ values() ]、<code>find()</code>和<code>findIndex()</code>会将空位处理成 <strong>undefined</strong>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// entries()</span></span><br><span class="line">&gt;[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">entries</span>()] <span class="comment">// [[0,undefined], [1,&quot;a&quot;]]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// keys()</span></span><br><span class="line">&gt;[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">keys</span>()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// values()</span></span><br><span class="line">&gt;[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">values</span>()] <span class="comment">// [undefined,&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// find()</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// findIndex()</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>由于空位的处理规则非常不统一，所以建议避免出现空位. </p></blockquote><h3 id="Ⅶ-Array-prototype-sort-的排序稳定性"><a href="#Ⅶ-Array-prototype-sort-的排序稳定性" class="headerlink" title="Ⅶ - Array.prototype.sort() 的排序稳定性"></a>Ⅶ - Array.prototype.sort() 的排序稳定性</h3><blockquote><p>排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [</span><br><span class="line"> <span class="string">&#x27;peach&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;straw&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;spork&#x27;</span></span><br><span class="line">&gt;];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">stableSorting</span> = (<span class="params">s1, s2</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;arr.<span class="title function_">sort</span>(stableSorting)</span><br><span class="line">&gt;<span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码对数组<code>arr</code>按照首字母进行排序. 排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致，所以排序算法<code>stableSorting</code>是稳定排序. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">unstableSorting</span> = (<span class="params">s1, s2</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt;= s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;arr.<span class="title function_">sort</span>(unstableSorting)</span><br><span class="line">&gt;<span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，排序结果是<code>spork</code>在<code>straw</code>前面，跟原始顺序相反，所以排序算法<code>unstableSorting</code>是不稳定的. </p><p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的. 不稳定排序的主要缺点是，多重排序时可能会产生问题. 假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序. 开发者可能会先按名字排序，再按姓氏进行排序. 如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果. 如果是不稳定的，就不行. </p><p>早先的 ECMAScript 没有规定，<code>Array.prototype.sort()</code>的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的. <a href="https://github.com/tc39/ecma262/pull/1340">ES2019</a> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定. 这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的. </p></blockquote><h2 id="9、正则的拓展"><a href="#9、正则的拓展" class="headerlink" title="9、正则的拓展"></a>9、正则的拓展</h2><blockquote><p>首先要学好正则基础再来看此部分(或者直接暂时跳过),不然的话,大概率你会在这里看不下去的!!!</p><p>如果对于正则技术不是很急需的也可以先跳过,相对而言ES6正则刚需没那么大</p><p>对于正则基础笔记本人也有进行详细且系统的梳理,需要的可以去看看       –&gt;  <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">正则表达式学习笔记</a></strong> </p></blockquote><h3 id="Ⅰ-概括与总结-2"><a href="#Ⅰ-概括与总结-2" class="headerlink" title="Ⅰ- 概括与总结"></a>Ⅰ- 概括与总结</h3><blockquote><ul><li><strong>变更RegExp构造函数入参</strong>: 允许首参数为<code>正则对象</code>，尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</li><li> <strong>正则方法调用变更</strong>: 字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></li><li><strong>u修饰符</strong>: Unicode模式修饰符，正确处理大于 [ \uFFFF ] 的 [ Unicode字符 ]</li><li><code>点字符</code>(.)</li><li><code>Unicode表示法</code></li><li><code>量词</code></li><li><code>预定义模式</code></li><li><code>i修饰符</code></li><li><code>转义</code></li><li> <strong>y修饰符</strong>: 粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</li><li> <strong>unicode</strong>: 是否设置<code>u修饰符</code></li><li> <strong>sticky</strong>: 是否设置<code>y修饰符</code></li><li> <strong>flags</strong>: 返回正则表达式的修饰符</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>y修饰符</code>隐含头部匹配标志<code>^</code></li><li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配，必须与<code>g修饰符</code>联用才能返回所有匹配</li></ul></blockquote><h3 id="Ⅱ-RegExp-构造函数"><a href="#Ⅱ-RegExp-构造函数" class="headerlink" title="Ⅱ - RegExp 构造函数"></a>Ⅱ - RegExp 构造函数</h3><blockquote><p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况. </p><p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag 标志）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为. 如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符. 而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>).<span class="property">flags</span></span><br><span class="line">&gt;<span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖. </p></blockquote><h3 id="Ⅲ-字符串的正则方法"><a href="#Ⅲ-字符串的正则方法" class="headerlink" title="Ⅲ -  字符串的正则方法"></a>Ⅲ -  字符串的正则方法</h3><blockquote><p>字符串对象共有 4 个方法，可以使用正则表达式: <code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>. </p><p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上. </p><ul><li>[ String.prototype.match ] 调用 <code>RegExp.prototype[Symbol.match]</code></li><li>[ String.prototype.replace ]  调用 <code>RegExp.prototype[Symbol.replace]</code></li><li>[ String.prototype.search ]  调用 <code>RegExp.prototype[Symbol.search]</code></li><li>[ String.prototype.split ]  调用 <code>RegExp.prototype[Symbol.split]</code></li></ul></blockquote><h3 id="Ⅳ-u-修饰符"><a href="#Ⅳ-u-修饰符" class="headerlink" title="Ⅳ -  u 修饰符"></a>Ⅳ -  u 修饰符</h3><blockquote><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符. 也就是说，会正确处理四个字节的 UTF-16 编码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\uD83D/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^\uD83D/</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符. 但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>. 加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>. </p><p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为:</p></blockquote><h4 id="①-点字符"><a href="#①-点字符" class="headerlink" title="① 点字符"></a>① 点字符</h4><blockquote><p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符. 对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，必须加上<code>u</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line">&gt;<span class="regexp">/^.$/</span>.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^.$/u</span>.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败. </p></blockquote><h4 id="②-Unicode-字符表示法"><a href="#②-Unicode-字符表示法" class="headerlink" title="② Unicode 字符表示法"></a>② Unicode 字符表示法</h4><blockquote><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/\u&#123;61&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/\u&#123;61&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/\u&#123;20BB7&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\u&#123;61&#125;</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>. </p></blockquote><h4 id="③-量词"><a href="#③-量词" class="headerlink" title="③ 量词"></a>③ 量词</h4><blockquote><p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/a&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/a&#123;2&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/𠮷&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/𠮷&#123;2&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-预定义模式"><a href="#④-预定义模式" class="headerlink" title="④ 预定义模式"></a>④ 预定义模式</h4><blockquote><p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\S$/</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^\S$/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>\S</code>是预定义模式，匹配所有非空白字符. 只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符. </p><p>利用这一点，可以写出一个正确返回字符串长度的函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">codePointLength</span>(<span class="params">text</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> result = text.<span class="title function_">match</span>(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line"> <span class="keyword">return</span> result ? result.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;𠮷𠮷&#x27;</span>;</span><br><span class="line">&gt;s.<span class="property">length</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="title function_">codePointLength</span>(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-i-修饰符"><a href="#⑤-i-修饰符" class="headerlink" title="⑤ i 修饰符"></a>⑤ i 修饰符</h4><blockquote><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/[a-z]/iu</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符. </p></blockquote><h4 id="⑥-转义"><a href="#⑥-转义" class="headerlink" title="⑥ 转义"></a>⑥ 转义</h4><blockquote><p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\,</code>）无效，而在<code>u</code>模式会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/\,/</span> <span class="comment">// /\,/</span></span><br><span class="line">&gt;<span class="regexp">/\,/u</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错. </p></blockquote><h4 id="⑦-RegExp-prototype-unicode-属性"><a href="#⑦-RegExp-prototype-unicode-属性" class="headerlink" title="⑦ RegExp.prototype.unicode 属性"></a>⑦ RegExp.prototype.unicode 属性</h4><blockquote><p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="property">unicode</span> <span class="comment">// false</span></span><br><span class="line">&gt;r2.<span class="property">unicode</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，正则表达式是否设置了<code>u</code>修饰符，可以从<code>unicode</code>属性看出来. </p></blockquote><h3 id="Ⅴ-y-修饰符"><a href="#Ⅴ-y-修饰符" class="headerlink" title="Ⅴ -  y 修饰符"></a>Ⅴ -  y 修饰符</h3><blockquote><p>提前剧透，<code>y</code>修饰符号相当于 <code>/g</code>隐含了头部匹配的标志<code>^</code>. 带着这个思维就相对容易理解下方的<code>粘连</code>一次</p></blockquote><h4 id="①-正常使用举例说明"><a href="#①-正常使用举例说明" class="headerlink" title="① 正常使用举例说明"></a>① 正常使用举例说明</h4><blockquote><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符. 实际上相当于默认加了一个<code>^</code></p><p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始. 不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]  --&gt;此时剩余字符串[_aa_a]</span></span><br><span class="line">&gt;r2.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]  --&gt;此时剩余字符串[_aa_a]</span></span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">&gt;r2.<span class="title function_">exec</span>(s) <span class="comment">// null     --&gt;y必须从第一个位置开始匹配,实际上相当于默认加了一个`^`,所以匹配不到</span></span><br></pre></td></tr></table></figure><p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符. 这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>. 由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>. </p><p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">&gt;r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa_&quot;]</span></span><br><span class="line">&gt;r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa_&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码每次匹配，都是从剩余字符串的头部开始. </p></blockquote><h4 id="②-使用lastIndex属性进行说明"><a href="#②-使用lastIndex属性进行说明" class="headerlink" title="② 使用lastIndex属性进行说明"></a>② 使用<code>lastIndex</code>属性进行说明</h4><blockquote><p>使用<code>lastIndex</code>属性，可以更好地说明<code>y</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/g</span>;</span><br><span class="line">&gt;<span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 匹配成功</span></span><br><span class="line">&gt;<span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">&gt;match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>lastIndex</code>属性指定每次搜索的开始位置，<code>g</code>修饰符从这个位置开始向后搜索，直到发现匹配为止. </p><p><code>y</code>修饰符同样遵守<code>lastIndex</code>属性，但是要求必须在<code>lastIndex</code>指定的位置发现匹配. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/y</span>;</span><br><span class="line">&gt;<span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line">&gt;<span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">3</span>;</span><br><span class="line">&gt;<span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line">&gt;<span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">&gt;match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>实际上，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/b/y</span>.<span class="title function_">exec</span>(<span class="string">&#x27;aba&#x27;</span>)<span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>. <code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效. </p></blockquote><h4 id="③-使用字符串对象的replace方法的举例"><a href="#③-使用字符串对象的replace方法的举例" class="headerlink" title="③ 使用字符串对象的replace方法的举例"></a>③ 使用字符串对象的<code>replace</code>方法的举例</h4><blockquote><p>下面是字符串对象的<code>replace</code>方法的例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/gy</span>;</span><br><span class="line">&gt;<span class="string">&#x27;aaxa&#x27;</span>.<span class="title function_">replace</span>(<span class="variable constant_">REGEX</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;--xa&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，最后一个<code>a</code>因为不是出现在下一次匹配的头部，所以不会被替换. </p><p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line">&gt;<span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure><p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">TOKEN_Y</span> = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">TOKEN_G</span>  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = [];</span><br><span class="line"> <span class="keyword">let</span> match;</span><br><span class="line"> <span class="keyword">while</span> (match = <span class="variable constant_">TOKEN_REGEX</span>.<span class="title function_">exec</span>(str)) &#123;</span><br><span class="line">   result.<span class="title function_">push</span>(match[<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的. 但是，一旦出现非法字符，两者的行为就不一样了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27; ]</span></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误. </p></blockquote><h4 id="④-RegExp-prototype-sticky-属性"><a href="#④-RegExp-prototype-sticky-属性" class="headerlink" title="④ RegExp.prototype.sticky 属性"></a>④ RegExp.prototype.sticky 属性</h4><blockquote><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">&gt;r.<span class="property">sticky</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅵ-s-修饰符-dotAll-模式"><a href="#Ⅵ-s-修饰符-dotAll-模式" class="headerlink" title="Ⅵ - s 修饰符: dotAll 模式"></a>Ⅵ - s 修饰符: dotAll 模式</h3><blockquote><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外. 一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）. </p><p>所谓行终止符，就是该字符表示一行的终结. 以下四个字符属于“行终止符”. </p><ul><li>U+000A 换行符（<code>\n</code>）</li><li>U+000D 回车符（<code>\r</code>）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为<code>.</code>不匹配<code>\n</code>，所以正则表达式返回<code>false</code>. </p><p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo[^]bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种解决方案毕竟不太符合直觉， <a href="https://github.com/tc39/proposal-regexp-dotall-flag">ES2018</a> 引入<code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>s.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符. 所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line">&gt;<span class="comment">// 另一种写法</span></span><br><span class="line">&gt;<span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line">&gt;re.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;re.<span class="property">dotAll</span> <span class="comment">// true</span></span><br><span class="line">&gt;re.<span class="property">flags</span> <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure><p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾. </p></blockquote><h3 id="Ⅶ-RegExp-prototype-flags-属性"><a href="#Ⅶ-RegExp-prototype-flags-属性" class="headerlink" title="Ⅶ - RegExp.prototype.flags 属性"></a>Ⅶ - RegExp.prototype.flags 属性</h3><blockquote><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的 source 属性</span></span><br><span class="line">&gt;<span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">&gt;<span class="regexp">/abc/ig</span>.<span class="property">source</span></span><br><span class="line">&gt;<span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的 flags 属性</span></span><br><span class="line">&gt;<span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">&gt;<span class="regexp">/abc/ig</span>.<span class="property">flags</span></span><br><span class="line">&gt;<span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅷ-Unicode-属性类"><a href="#Ⅷ-Unicode-属性类" class="headerlink" title="Ⅷ - Unicode 属性类"></a>Ⅷ - Unicode 属性类</h3><blockquote><p>ES2018 <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">引入</a>了一种新的类的写法<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">&gt;regexGreekSymbol.<span class="title function_">test</span>(<span class="string">&#x27;π&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>\p&#123;Script=Greek&#125;</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功. </p><p>Unicode 属性类要指定属性名和属性值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyName</span>=<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure><p>对于某些属性，可以只写属性名，或者只写属性值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyName</span>&#125;</span><br><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure><p><code>\P&#123;…&#125;</code>是<code>\p&#123;…&#125;</code>的反向匹配，即匹配不满足条件的字符. </p><p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符. 如果不加<code>u</code>修饰符，正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript 预留了这两个类. </p><p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功. </p><p><code>\p&#123;Number&#125;</code>甚至能匹配罗马数字. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 匹配所有数字</span></span><br><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;²³¹¼½¾&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;㉛㉜㉝&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面是其他一些例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 匹配所有空格</span></span><br><span class="line">&gt;\p&#123;<span class="title class_">White</span>_Space&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">&gt;[\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">&gt;[^\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配 Emoji</span></span><br><span class="line">&gt;<span class="regexp">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line">&gt;<span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">&gt;regexArrows.<span class="title function_">test</span>(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅸ-具名组匹配"><a href="#Ⅸ-具名组匹配" class="headerlink" title="Ⅸ - 具名组匹配"></a>Ⅸ - 具名组匹配</h3><h4 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h4><blockquote><p>正则表达式使用圆括号进行组匹配. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，正则表达式里面有三组圆括号. 使用<code>exec</code>方法，就可以将这三组匹配结果提取出来. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">&gt;<span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">&gt;<span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号. </p><p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line">&gt;<span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line">&gt;<span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加 [ “问号 + 尖括号 + 组名” ] （<code>?&lt;year&gt;</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名. 同时，数字序号（<code>matchObj[1]</code>）依然有效. </p><p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的. 如果组的顺序变了，也不用改变匹配后的处理代码. </p><p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_OPT_A</span> = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_OPT_A</span>.<span class="title function_">exec</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;matchObj.<span class="property">groups</span>.<span class="property">as</span> <span class="comment">// undefined</span></span><br><span class="line">&gt;<span class="string">&#x27;as&#x27;</span> <span class="keyword">in</span> matchObj.<span class="property">groups</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的. </p></blockquote><h4 id="②-解构赋值和替换"><a href="#②-解构赋值和替换" class="headerlink" title="② 解构赋值和替换"></a>② 解构赋值和替换</h4><blockquote><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.<span class="title function_">exec</span>(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">&gt;one  <span class="comment">// foo</span></span><br><span class="line">&gt;two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式. </p><p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture1, <span class="comment">// 第一个组匹配 2015</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture2, <span class="comment">// 第二个组匹配 01</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture3, <span class="comment">// 第三个组匹配 02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  position, <span class="comment">// 匹配开始的位置 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  S, <span class="comment">// 原字符串 2015-01-02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>具名组匹配在原来的基础上，新增了最后一个函数参数: 具名组构成的一个对象. 函数内部可以直接对这个对象进行解构赋值. </p></blockquote><h4 id="③-引用"><a href="#③-引用" class="headerlink" title="③ 引用"></a>③ 引用</h4><blockquote><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>数字引用（<code>\1</code>）依然有效. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这两种引用语法还可以同时使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅹ-String-prototype-matchAll"><a href="#Ⅹ-String-prototype-matchAll" class="headerlink" title="Ⅹ - String.prototype.matchAll()"></a>Ⅹ - String.prototype.matchAll()</h3><blockquote><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> matches = [];</span><br><span class="line">&gt;<span class="keyword">var</span> match;</span><br><span class="line">&gt;<span class="keyword">while</span> (match = regex.<span class="title function_">exec</span>(string)) &#123;</span><br><span class="line"> matches.<span class="title function_">push</span>(match);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;matches</span><br><span class="line">&gt;<span class="comment">// [</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮. </p><p><a href="https://github.com/tc39/proposal-string-matchall">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配. 不过，它返回的是一个遍历器（Iterator），而不是数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出. 相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源. </p><p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 转为数组的方法一</span></span><br><span class="line">&gt;[...string.<span class="title function_">matchAll</span>(regex)]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 转为数组的方法二</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex))</span><br></pre></td></tr></table></figure></blockquote><h2 id="10、Symbol总"><a href="#10、Symbol总" class="headerlink" title="10、Symbol总"></a>10、Symbol总</h2><h3 id="Ⅰ-概述与总结"><a href="#Ⅰ-概述与总结" class="headerlink" title="Ⅰ- 概述与总结"></a>Ⅰ- 概述与总结</h3><blockquote><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突. 比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突. 如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突. 这就是 ES6 引入<code>Symbol</code>的原因. </p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值. 它是 JavaScript 语言的<code>第七种数据类型</code>，前六种是: <code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）. </p><ol><li>定义: 独一无二的值,类似于一种标识唯一性的ID</li><li>声明: <code>const set = Symbol(str)</code></li><li>入参: 字符串(可选)</li><li>方法: </li></ol><ul><li><strong>Symbol()</strong>: 创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</li><li><strong>Symbol.for()</strong>: 创建以参数作为描述的<code>Symbol值</code>，如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建，登记在全局环境)</li><li><strong>Symbol.keyFor()</strong>: 返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li><li><strong>Object.getOwnPropertySymbols()</strong>: 返回对象中所有用作属性名的<code>Symbol值</code>的数组</li></ul><ol start="5"><li>内置</li></ol><ul><li><strong>Symbol.hasInstance</strong>: 指向一个内部方法，当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li><li><strong>Symbol.isConcatSpreadable</strong>: 指向一个布尔，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li><li><strong>Symbol.species</strong>: 指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li><li><strong>Symbol.match</strong>: 指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li><li><strong>Symbol.replace</strong>: 指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li><li><strong>Symbol.search</strong>: 指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li><li><strong>Symbol.split</strong>: 指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li><li><strong>Symbol.iterator</strong>: 指向一个默认遍历器方法，当实例对象执行 [ for-of ] 时会调用指定的默认遍历器</li><li><strong>Symbol.toPrimitive</strong>: 指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li><li><strong>Symbol.toStringTag</strong>: 指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li><li><strong>Symbol.unscopables</strong>: 指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li></ul><blockquote><p>数据类型</p></blockquote><ul><li><strong>Undefined</strong></li><li><strong>Null</strong></li><li><strong>String</strong></li><li><strong>Number</strong></li><li><strong>Boolean</strong></li><li><strong>Object</strong>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li><li><strong>Symbol</strong></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt">bigint</a>，  –&gt;<strong>BigInt</strong> 是一种数字类型的数据</li></ul><blockquote><p>应用场景</p></blockquote><ol><li><p>唯一化对象属性名: 属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</p></li><li><p>消除<code>魔术字符串</code>: 在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</p></li></ol><ul><li><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值. 风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替. </p></li><li><p>```js<br>function getResults(param){</p><pre><code>if(param == &#39;努力学习的汪&#39;) console.log(&#39;魔术字符串&#39;)</code></pre><p>}<br>// 函数中赋值 ‘努力学习的汪’,所以 ‘努力学习的汪’ 这个字符串就是魔术字符串<br>getResults(‘努力学习的汪’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;3. 遍历属性名: 无法通过 [ for-in ] 、 [ for-of ] 、 [Object.keys()] 、 [Object.getOwnPropertyNames()] 、`JSON.stringify()`返回，只能通过`Object.getOwnPropertySymbols`返回</span><br><span class="line"></span><br><span class="line">&gt;4. 启用模块的Singleton模式: 调用一个类在任何时候返回同一个实例(`window`和`global`)，使用`Symbol.for()`来模拟全局的`Singleton模式`</span><br><span class="line"></span><br><span class="line">&gt;&gt; 重点难点</span><br><span class="line"></span><br><span class="line">&gt;- `Symbol()`生成一个原始类型的值不是对象，因此`Symbol()`前不能使用`new命令`</span><br><span class="line">&gt;- `Symbol()`参数表示对当前`Symbol值`的描述，相同参数的`Symbol()`返回值不相等</span><br><span class="line">&gt;- `Symbol值`不能与其他类型的值进行运算</span><br><span class="line">&gt;- `Symbol值`可通过`String()`或`toString()`显式转为字符串</span><br><span class="line">&gt;- `Symbol值`作为对象属性名时，此属性是公开属性，但不是私有属性</span><br><span class="line">&gt;- `Symbol值`作为对象属性名时，只能用方括号运算符(`[]`)读取，不能用点运算符(`.`)读取</span><br><span class="line">&gt;- `Symbol值`作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义`非私有但又只用于内部的方法`</span><br><span class="line"></span><br><span class="line">### Ⅱ - 举个简单的例子</span><br><span class="line"></span><br><span class="line">Symbol 值通过`Symbol`函数生成. 这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型. 凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突. </span><br><span class="line"></span><br><span class="line">注意，`Symbol`函数前不能使用`new`命令，否则会报错. 这是因为生成的 Symbol 是一个原始类型的值，不是对象. 也就是说，由于 Symbol 值不是对象，所以不能添加属性. 基本上，它是一种`类似于字符串的数据类型`. </span><br><span class="line"></span><br><span class="line">`Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分. </span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let s1 = Symbol(&#x27;努力学习的汪&#x27;);</span><br><span class="line">let s2 = Symbol(&#x27;hongjilin&#x27;);</span><br><span class="line"></span><br><span class="line">s1 // Symbol(努力学习的汪)  注意:此处是 Symbol 值</span><br><span class="line">s2 // Symbol(hongjilin)</span><br><span class="line"></span><br><span class="line">s1.toString() // &quot;Symbol(努力学习的汪)&quot; 注意 此处是字符串</span><br><span class="line">s2.toString() // &quot;Symbol(hongjilin)&quot;</span><br></pre></td></tr></table></figure></li></ul><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826181302853.png" alt="image-20210826181302853">  </p><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值. 如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分. 有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值. </p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)  --&gt; [ Symbol 值 ]</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826181625657.png" alt="image-20210826181625657"> </p><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的. </p><p>Symbol 值不能与其他类型的值进行运算，会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是，Symbol 值可以显式转为字符串. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br></pre></td></tr></table></figure><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="title class_">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;&#125;</span><br><span class="line"><span class="title class_">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Symbol-prototype-description"><a href="#Ⅲ-Symbol-prototype-description" class="headerlink" title="Ⅲ - Symbol.prototype.description"></a>Ⅲ - Symbol.prototype.description</h3><blockquote><p>创建 Symbol 的时候，可以添加一个描述. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sym</code>的描述就是字符串<code>努力学习的汪</code>. </p><p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">String</span>(sym) <span class="comment">// &quot;Symbol(努力学习的汪)&quot;</span></span><br><span class="line">&gt;sym.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(努力学习的汪)&quot;</span></span><br></pre></td></tr></table></figure><p>上面的用法不是很方便. <a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;sym.<span class="property">description</span> <span class="comment">// &quot;努力学习的汪&quot;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826183246668.png" alt="image-20210826183246668"> </p></blockquote><h3 id="Ⅳ-作为属性名的-Symbol"><a href="#Ⅳ-作为属性名的-Symbol" class="headerlink" title="Ⅳ - 作为属性名的 Symbol"></a>Ⅳ - 作为属性名的 Symbol</h3><h4 id="①-举个栗子"><a href="#①-举个栗子" class="headerlink" title="① 举个栗子:"></a>① 举个栗子:</h4><blockquote><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性. 这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第一种写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">&gt;a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第二种写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;</span><br><span class="line"> [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第三种写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">&gt;a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和 [ Object.defineProperty ] ，将对象的属性名指定为一个 Symbol 值. </p></blockquote><h4 id="②-不能用点运算符"><a href="#②-不能用点运算符" class="headerlink" title="② 不能用点运算符"></a>② 不能用点运算符</h4><blockquote><p>注意，Symbol 值作为对象属性名时，不能用点运算符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//不可这样用,这样用就没效果了</span></span><br><span class="line">&gt;a.<span class="property">mySymbol</span> = <span class="string">&#x27;努力学习的汪!&#x27;</span>; <span class="comment">//因为点运算符后面总是字符串，所以不会读取`mySymbol`作为标识名所指代的那个值，导致`a`的属性名实际上是一个字符串，而不是一个 Symbol 值. </span></span><br><span class="line">&gt;a[mySymbol] <span class="comment">// undefined     --&gt;此处以 创建的Symbol值 作为key名进行读取</span></span><br><span class="line">&gt;a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;努力学习的汪!&quot;  --&gt;此处就是字符串作为key名进行读取</span></span><br></pre></td></tr></table></figure><p><img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826183751378.png" alt="image-20210826183751378"> </p><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值. </p><p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line">&gt;[s]: <span class="keyword">function</span> (<span class="params">arg</span>) &#123; ... &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值. </p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line">&gt;[s](arg) &#123; ... &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Symbol-类型用于定义常量"><a href="#③-Symbol-类型用于定义常量" class="headerlink" title="③ Symbol 类型用于定义常量"></a>③ Symbol 类型用于定义常量</h4><blockquote><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> log = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;log.<span class="property">levels</span> = &#123;</span><br><span class="line">&gt;<span class="attr">DEBUG</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;debug&#x27;</span>),</span><br><span class="line">&gt;<span class="attr">INFO</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">&gt;<span class="attr">WARN</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;warn&#x27;</span>)</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">DEBUG</span>, <span class="string">&#x27;debug message&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">INFO</span>, <span class="string">&#x27;info message&#x27;</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">COLOR_RED</span>    = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">COLOR_GREEN</span>  = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getComplement</span>(<span class="params">color</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">switch</span> (color) &#123;</span><br><span class="line">&gt;<span class="keyword">case</span> <span class="attr">COLOR_RED</span>:</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable constant_">COLOR_GREEN</span>;</span><br><span class="line">&gt;<span class="keyword">case</span> <span class="attr">COLOR_GREEN</span>:</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable constant_">COLOR_RED</span>;</span><br><span class="line">&gt;<span class="attr">default</span>:</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Undefined color&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作. </p><p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性. </p></blockquote><h4 id="④-应用实例-消除魔术字符串"><a href="#④-应用实例-消除魔术字符串" class="headerlink" title="④ 应用实例:消除魔术字符串"></a>④ 应用实例:消除魔术字符串</h4><h5 id="a-魔术字符串"><a href="#a-魔术字符串" class="headerlink" title="a) 魔术字符串"></a>a) 魔术字符串</h5><blockquote><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值. 风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getResults</span>(<span class="params">param</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(param == <span class="string">&#x27;努力学习的汪&#x27;</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;魔术字符串&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 函数中赋值 &#x27;努力学习的汪&#x27;,所以 &#x27;努力学习的汪&#x27; 这个字符串就是魔术字符串</span></span><br><span class="line">&gt;<span class="title function_">getResults</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串. 它多次出现，与代码形成“强耦合”，不利于将来的修改和维护. </p></blockquote><h5 id="b-常用的消除魔术字符串的方法"><a href="#b-常用的消除魔术字符串的方法" class="headerlink" title="b) 常用的消除魔术字符串的方法"></a>b) 常用的消除魔术字符串的方法</h5><blockquote><p>常用的消除魔术字符串的方法，就是把它写成一个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> name=<span class="string">&#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getResults</span>(<span class="params">param</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(param == name) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;消除魔术字符串&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">getResults</span>(name) <span class="comment">//消除魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们把<code>努力学习的汪</code>写成 [ name ] 属性，这样就消除了强耦合. </p></blockquote><h5 id="c-改用Symbol值"><a href="#c-改用Symbol值" class="headerlink" title="c) 改用Symbol值"></a>c) 改用Symbol值</h5><blockquote><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可. 因此，这里就很适合改用 Symbol 值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> name=<span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getResults</span>(<span class="params">param</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(param == name) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Symbol消除魔术字符串&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">getResults</span>(name)  <span class="comment">// Symbol消除魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，除了将<code>努力学习的汪</code>的值设为一个 Symbol，其他地方都不用修改. </p></blockquote><h3 id="Ⅴ-属性名的遍历"><a href="#Ⅴ-属性名的遍历" class="headerlink" title="Ⅴ - 属性名的遍历"></a>Ⅴ - 属性名的遍历</h3><h4 id="①-概念引出"><a href="#①-概念引出" class="headerlink" title="①  概念引出"></a>①  概念引出</h4><blockquote><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被 [Object.keys()] 、 [Object.getOwnPropertyNames()] 、<code>JSON.stringify()</code>返回. </p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名. 该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&gt;obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line">&gt;objectSymbols<span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名. </p></blockquote><h4 id="②-获取Symbol键名方式"><a href="#②-获取Symbol键名方式" class="headerlink" title="② 获取Symbol键名方式"></a>② 获取Symbol键名方式</h4><blockquote><p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> name = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> obj=&#123;</span><br><span class="line">   [name]:<span class="string">&#x27;Symbol:努力学习的汪&#x27;</span>,  <span class="comment">//赋一个Symbol属性</span></span><br><span class="line">   <span class="attr">other</span>:<span class="string">&#x27;正常属性&#x27;</span>   <span class="comment">//给一个正常属性做对比</span></span><br><span class="line">    <span class="comment">//使用symbol创建对象属性</span></span><br><span class="line">   [<span class="title function_">symbol</span>(<span class="string">&#x27;say&#x27;</span>)]:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以说话&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ for --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">//只打印一个 other</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ Object.keys --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> objKeys=<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)  <span class="comment">//打印一个 [ &quot;other&quot; ]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(objKeys) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ Object.getOwnPropertyNames --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">PropertyNames</span>=<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) <span class="comment">// 打印一个 [ &quot;other&quot; ]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PropertyNames</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ Object.getOwnPropertySymbols --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">PropertySymbols</span>= <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PropertySymbols</span>)</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830141637812.png" alt="image-20210830141637812"> 上面代码中，使用<code>for...in</code>循环和 [Object.getOwnPropertyNames()] 方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法. </p></blockquote><h4 id="③-获取所有类型的键名"><a href="#③-获取所有类型的键名" class="headerlink" title="③ 获取所有类型的键名"></a>③ 获取所有类型的键名</h4><blockquote><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">enum</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">nonEnum</span>: <span class="number">3</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)</span><br><span class="line">&gt;<span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-利用特性-营造-非私有的内部方法的效果"><a href="#④-利用特性-营造-非私有的内部方法的效果" class="headerlink" title="④ 利用特性 营造 非私有的内部方法的效果"></a>④ 利用特性 营造 非私有的内部方法的效果</h4><blockquote><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到. 我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> size = <span class="title class_">Symbol</span>(<span class="string">&#x27;私有&#x27;</span>); <span class="comment">//可以 Symbol(&#x27;字符串&#x27;),也可以不要Symbol(),但加了会更有辨识度</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Collection</span> &#123; <span class="comment">//注意,此类中的所有size属性都是指的上方  Symbol(&#x27;私有&#x27;)</span></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>[size] = <span class="number">0</span>; <span class="comment">//此处构造函数初始化时 给 [size]进行了初始化赋值--&gt;[Symbol(&#x27;私有&#x27;)]=0</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">add</span>(<span class="params">item</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>[<span class="variable language_">this</span>[size]] = item; <span class="comment">//此时 1. 先取出 this[size] 的值,此时为0,作为新的key,存入item </span></span><br><span class="line">   <span class="variable language_">this</span>[size]++;   <span class="comment">//此时 this[size] == 1 </span></span><br><span class="line">   <span class="comment">//第一次调用 log:Collection &#123;0: &quot;调用一次添加&quot;, Symbol(私有): 1&#125;  </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">sizeOf</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> instance[size];  <span class="comment">// 返回传入实例中的 size 属性</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 先获取初始化时数据 --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的size属性值&#x27;</span>,<span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x)) <span class="comment">// 此时的size属性值 0</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x)        <span class="comment">//Collection &#123;Symbol(私有): 0&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 调用一次添加 --------------&#x27;</span>)</span><br><span class="line">&gt;x.<span class="title function_">add</span>(<span class="string">&#x27;调用一次添加&#x27;</span>); <span class="comment">//调用一次添加</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的size属性值&#x27;</span>,<span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x)) <span class="comment">//此时的size属性值 1</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//Collection &#123;0: &quot;调用一次添加&quot;, Symbol(私有): 1&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 调用两次添加 --------------&#x27;</span>)</span><br><span class="line">&gt;x.<span class="title function_">add</span>(<span class="string">&#x27;调用2次添加&#x27;</span>); <span class="comment">//第二次调用</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的size属性值&#x27;</span>,<span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x)) <span class="comment">// 此时的size属性值 2</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// Collection &#123;0: &quot;调用一次添加&quot;, 1: &quot;调用2次添加&quot;, Symbol(私有): 2&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 查看不同方法取出的key --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(x)) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(x)) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(x)) <span class="comment">// [Symbol(私有)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830145632266.png" alt="image-20210830145632266"> 上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它. 这就造成了一种非私有的内部方法的效果. </p></blockquote><h3 id="Ⅵ-Symbol-for-，Symbol-keyFor"><a href="#Ⅵ-Symbol-for-，Symbol-keyFor" class="headerlink" title="Ⅵ - Symbol.for()，Symbol.keyFor()"></a>Ⅵ - Symbol.for()，Symbol.keyFor()</h3><h4 id="①-Symbol-for"><a href="#①-Symbol-for" class="headerlink" title="① Symbol.for()"></a>① Symbol.for()</h4><blockquote><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点. 它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值. 如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;hongjilin&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;hongjilin&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> h1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> h2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2 ,h1 === h2)</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830150415159.png" alt="image-20210830150415159"> 上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值. </p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol. 它们的区别是 : </p><blockquote><ul><li>前者会被登记在全局环境中供搜索，后者不会. </li><li><code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值. </li><li>如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值;</li><li>但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值. </li></ul></blockquote></blockquote><h4 id="②-Symbol-keyFor"><a href="#②-Symbol-keyFor" class="headerlink" title="② Symbol.keyFor()"></a>② Symbol.keyFor()</h4><blockquote><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1)) <span class="comment">// &quot;努力学习的汪&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830151409178.png" alt="image-20210830151409178"> 上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>. </p><p>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>); <span class="comment">//在函数内部:局部作用域中运行</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> x = <span class="title function_">foo</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> y = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830151530178.png" alt="image-20210830151530178"> 上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的. 所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值. </p><p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">&gt;iframe.<span class="property">src</span> = <span class="title class_">String</span>(<span class="variable language_">window</span>.<span class="property">location</span>);</span><br><span class="line">&gt;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"></span><br><span class="line">&gt;iframe.<span class="property">contentWindow</span>.<span class="property">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到. </p></blockquote><h3 id="Ⅶ-应用实例-模块的-Singleton-模式"><a href="#Ⅶ-应用实例-模块的-Singleton-模式" class="headerlink" title="Ⅶ - 应用实例: 模块的 Singleton 模式"></a>Ⅶ - 应用实例: 模块的 Singleton 模式</h3><h4 id="①-模块的-Singleton-模式"><a href="#①-模块的-Singleton-模式" class="headerlink" title="① 模块的 Singleton 模式"></a>① 模块的 Singleton 模式</h4><blockquote><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例. </p><p>对于 Node 来说，模块文件可以看成是一个类. 怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// mod.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">userName</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">if</span> (!<span class="variable language_">global</span>.<span class="property">_userName</span>)  <span class="variable language_">global</span>.<span class="property">_userName</span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>.<span class="property">_userName</span>;</span><br></pre></td></tr></table></figure><p>然后，加载上面的<code>mod.js</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">foo</span>);<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例. </p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">global</span>.<span class="property">_userName</span> = &#123; <span class="attr">userName</span>: <span class="string">&#x27;不努力学习的单身汪&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">userName</span>); <span class="comment">// 不努力学习的单身汪</span></span><br></pre></td></tr></table></figure><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真. </p></blockquote><h4 id="②-Symbol-for-的应用"><a href="#②-Symbol-for-的应用" class="headerlink" title="②  Symbol.for() 的应用"></a>②  Symbol.for() 的应用</h4><blockquote><p>为了防止这种情况出现，我们就可以使用 Symbol. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// mod.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;userName&#x27;</span>); <span class="comment">//此处使用Symbol.for()进行生成,目的为多次加载此js,生成的symbol都相同</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">userName</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> (!<span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>])  <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>] = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>];</span><br></pre></td></tr></table></figure><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//仍可以改写,但通常不会被无意间覆盖.会写出这个代码通常就是故意要覆盖的</span></span><br><span class="line">&gt;<span class="variable language_">global</span>[<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;userName&#x27;</span>)] = &#123; <span class="attr">userName</span>: <span class="string">&#x27;不努力学习的单身汪&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Symbol-的应用"><a href="#③-Symbol-的应用" class="headerlink" title="③ Symbol() 的应用"></a>③ Symbol() 的应用</h4><blockquote><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// mod.js</span></span><br><span class="line">&gt;<span class="comment">//不使用Symbol.for(),而是直接使用Symbol(),这样就确保不会被改写,理解吃力的话要重新看下上面的方法描述</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;userName&#x27;</span>); </span><br><span class="line">&gt;<span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>. 但这样也有一个问题:</p><blockquote><p>就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的. 虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠. </p></blockquote></blockquote><h3 id="Ⅷ-内置的-Symbol-值"><a href="#Ⅷ-内置的-Symbol-值" class="headerlink" title="Ⅷ - 内置的 Symbol 值"></a>Ⅷ - 内置的 Symbol 值</h3><blockquote><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法. </p><p>对于新手来说用的很少,可以暂时先跳过此部分,此处举例几个</p></blockquote><h4 id="①-Symbol-hasInstance"><a href="#①-Symbol-hasInstance" class="headerlink" title="① Symbol.hasInstance"></a>① Symbol.hasInstance</h4><h5 id="a-方法介绍"><a href="#a-方法介绍" class="headerlink" title="a) 方法介绍"></a>a) 方法介绍</h5><blockquote><p>对象的 [Symbol.hasInstance] 属性，指向一个内部方法. 当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法. 比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>()) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830161934219.png" alt="image-20210830161934219"></p></blockquote><h5 id="b-举个栗子"><a href="#b-举个栗子" class="headerlink" title="b) 举个栗子"></a>b) 举个栗子</h5><blockquote><p>下面是另一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">   <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="title class_">Array</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](obj) &#123; <span class="comment">//静态方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>()); <span class="comment">// true //我是调用的动态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>]([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,]));<span class="comment">//true //我是调用的动态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">//true 我是调用静态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](<span class="number">2</span>));<span class="comment">//true 我是调用了静态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">//false 因为修改了静态方法(不传入值返回肯定是false). x本身就是MyClass的实例，如果注释了静态方法就会返回true. </span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830162419619.png" alt="image-20210830162419619"></p></blockquote><h4 id="②-Symbol-isConcatSpreadable"><a href="#②-Symbol-isConcatSpreadable" class="headerlink" title="② Symbol.isConcatSpreadable"></a>② Symbol.isConcatSpreadable</h4><blockquote><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr1 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr1, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">&gt;arr1[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">&gt;arr2[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr2, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>. 该属性等于<code>true</code>时，也有展开的效果. </p><p>类似数组的对象正好相反，默认不展开. 它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;obj[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(args);</span><br><span class="line">   <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(args);</span><br><span class="line"> &#125;</span><br><span class="line"> get [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title function_">A1</span>();</span><br><span class="line">&gt;a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">&gt;a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title function_">A2</span>();</span><br><span class="line">&gt;a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">&gt;a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>(a1).<span class="title function_">concat</span>(a2)</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果. </p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同. </p></blockquote><h4 id="③-其他"><a href="#③-其他" class="headerlink" title="③ 其他"></a>③ 其他</h4><blockquote><p>几个内置方法不常用,需要时可以往上查阅,便暂不赘述</p></blockquote><h2 id="11、Set-数据结构"><a href="#11、Set-数据结构" class="headerlink" title="11、Set 数据结构"></a>11、Set 数据结构</h2><blockquote><p><code>常用</code></p></blockquote><h3 id="Ⅰ-概括与总结-3"><a href="#Ⅰ-概括与总结-3" class="headerlink" title="Ⅰ - 概括与总结"></a>Ⅰ - 概括与总结</h3><h4 id="①-Set"><a href="#①-Set" class="headerlink" title="① Set"></a>① Set</h4><blockquote><ul><li>定义: 类似于数组的数据结构，成员值都是唯一且没有重复的值</li><li>声明: <code>const set = new Set(arr)</code></li><li>入参: 具有<code>Iterator接口</code>的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数，返回Set</li><li><strong>size</strong>: 返回实例成员总数</li><li>方法</li><li><strong>add()</strong>: 添加值，返回实例</li><li><strong>delete()</strong>: 删除值，返回布尔</li><li><strong>has()</strong>: 检查值，返回布尔</li><li><strong>clear()</strong>: 清除所有成员</li><li><strong>keys()</strong>: 返回以属性值为遍历器的对象</li><li><strong>values()</strong>: 返回以属性值为遍历器的对象</li><li><strong>entries()</strong>: 返回以属性值和属性值为遍历器的对象</li><li><strong>forEach()</strong>: 使用回调函数遍历每个成员</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>去重字符串: <code>[...new Set(str)].join(&quot;&quot;)</code></li><li>去重数组: <code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组</li><li>声明: <code>const a = new Set(arr1)</code></li><li>并集: <code>new Set([...a, ...b])</code></li><li>交集: <code>new Set([...a].filter(v =&gt; b.has(v)))</code>  //此处的has指的是set自带的方法</li><li>差集: <code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li><li>映射集合</li><li>声明: <code>let set = new Set(arr)</code></li><li>映射: <code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>遍历顺序: 插入顺序</li><li>没有键只有值，可认为键和值两值相等</li><li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li><li>添加相同的对象时，会认为是不同的对象</li><li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li><li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul></blockquote><h4 id="②-WeakSet"><a href="#②-WeakSet" class="headerlink" title="② WeakSet"></a>② WeakSet</h4><blockquote><ul><li>定义: 和Set结构类似，成员值只能是对象</li><li>声明: <code>const set = new WeakSet(arr)</code></li><li>入参: 具有<code>Iterator接口</code>的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数，返回WeakSet</li><li>方法</li><li><strong>add()</strong>: 添加值，返回实例</li><li><strong>delete()</strong>: 删除值，返回布尔</li><li><strong>has()</strong>: 检查值，返回布尔</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>储存DOM节点: DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息: 只要这些对象在外部消失，它在<code>WeakSet结构</code>中的引用就会自动消去</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>成员都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li><li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet结构不可遍历</code></li><li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul></blockquote><h3 id="Ⅱ-基本用法-1"><a href="#Ⅱ-基本用法-1" class="headerlink" title="Ⅱ -  基本用法"></a>Ⅱ -  基本用法</h3><h4 id="①-基础示例"><a href="#①-基础示例" class="headerlink" title="① 基础示例"></a>① 基础示例</h4><blockquote><p>ES6 提供了新的数据结构 Set. 它类似于数组，但是成员的值都是唯一的，没有重复的值. </p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;[<span class="string">&#x27;努&#x27;</span>,<span class="string">&#x27;努&#x27;</span>,<span class="string">&#x27;力&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;的&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;汪&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> s.<span class="title function_">add</span>(item));</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s) <span class="comment">//Set(5) &#123;&quot;努&quot;, &quot;力&quot;, &quot;学习&quot;, &quot;的&quot;, &quot;汪&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830172842921.png" alt="image-20210830172842921"><br>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值. </p></blockquote><h4 id="②-接受一个数组作为参数"><a href="#②-接受一个数组作为参数" class="headerlink" title="② 接受一个数组作为参数"></a>② 接受一个数组作为参数</h4><blockquote><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...set]) <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="property">size</span>) <span class="comment">// 5</span></span><br><span class="line">&gt;<span class="comment">// 例三</span></span><br><span class="line">&gt;<span class="keyword">const</span> setDiv = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(setDiv.<span class="property">size</span>) <span class="comment">// 这个就根据你的当前页面梳理而定</span></span><br><span class="line">&gt;<span class="comment">// 类似于</span></span><br><span class="line">&gt;<span class="keyword">const</span> setDIV = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;<span class="variable language_">document</span></span><br><span class="line">.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">.<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> setDIV.<span class="title function_">add</span>(div));</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(setDiv.<span class="property">size</span>) <span class="comment">// 这个就根据你的当前页面梳理而定</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830173525573.png" alt="image-20210830173525573"> 上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数. </p></blockquote><h4 id="③-用于数组或字符串去重"><a href="#③-用于数组或字符串去重" class="headerlink" title="③ 用于数组或字符串去重"></a>③ 用于数组或字符串去重</h4><blockquote><p>上面代码也展示了一种去除数组重复成员的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 去除数组的重复成员</span></span><br><span class="line">&gt;[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-不会发生类型转换"><a href="#④-不会发生类型转换" class="headerlink" title="④ 不会发生类型转换"></a>④ 不会发生类型转换</h4><blockquote><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值. Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line">&gt;set.<span class="title function_">add</span>(a);</span><br><span class="line">&gt;set.<span class="title function_">add</span>(b);</span><br><span class="line">&gt;set <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个. 这表明，在 Set 内部，两个<code>NaN</code>是相等的. </p><p>另外，两个对象总是不相等的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(set,set.<span class="property">size</span>) <span class="comment">//Set(1) &#123;&#123;…&#125;&#125; 1</span></span><br><span class="line">&gt;set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(set,set.<span class="property">size</span>) <span class="comment">//Set(2) &#123;&#123;…&#125;, &#123;…&#125;&#125; 2</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830173927525.png" alt="image-20210830173927525"> </p></blockquote><h3 id="Ⅲ-Set-实例的属性和方法"><a href="#Ⅲ-Set-实例的属性和方法" class="headerlink" title="Ⅲ - Set 实例的属性和方法"></a>Ⅲ - Set 实例的属性和方法</h3><blockquote><p>Set 结构的实例有以下属性. </p><ul><li><code>Set.prototype.constructor</code>: 构造函数，默认就是<code>Set</code>函数. </li><li><code>Set.prototype.size</code>: 返回<code>Set</code>实例的成员总数. </li></ul><p>Set 实例的方法分为两大类: 操作方法（用于操作数据）和遍历方法（用于遍历成员）. 下面先介绍四个操作方法. </p><ul><li><code>Set.prototype.add(value)</code>: 添加某个值，返回 Set 结构本身. </li><li><code>Set.prototype.delete(value)</code>: 删除某个值，返回一个布尔值，表示删除是否成功. </li><li><code>Set.prototype.has(value)</code>: 返回一个布尔值，表示该值是否为<code>Set</code>的成员. </li><li><code>Set.prototype.clear()</code>: 清除所有成员，没有返回值. </li></ul><p>上面这些属性和方法的实例如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">&gt;s.<span class="title function_">add</span>(<span class="number">6</span>).<span class="title function_">add</span>(<span class="number">6</span>).<span class="title function_">add</span>(<span class="string">&#x27;努力&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;学习的汪&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;学习的汪&#x27;</span>);<span class="comment">// 注意 [6] [学习的汪] 被加入了两次</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s,s.<span class="property">size</span>) <span class="comment">// Set(3) &#123;6, &quot;努力&quot;, &quot;学习的汪&quot;&#125; 3</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="number">6</span>))  <span class="comment">//true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="string">&#x27;努力&#x27;</span>))  <span class="comment">//true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="string">&#x27;努力学习的单身汪&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line">&gt;<span class="comment">//删除 [ 6 ]</span></span><br><span class="line">&gt;s.<span class="title function_">delete</span>(<span class="number">6</span>); </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="number">6</span>))  <span class="comment">// false</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s,s.<span class="property">size</span>)  <span class="comment">//Set(2) &#123;&quot;努力&quot;, &quot;学习的汪&quot;&#125; 2</span></span><br></pre></td></tr></table></figure><p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 对象的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> properties = &#123;</span><br><span class="line"> <span class="string">&#x27;width&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;height&#x27;</span>: <span class="number">1</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">if</span> (properties[someName]) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;对象的写法&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Set的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;properties.<span class="title function_">add</span>(<span class="string">&#x27;width&#x27;</span>);</span><br><span class="line">&gt;properties.<span class="title function_">add</span>(<span class="string">&#x27;height&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">if</span> (properties.<span class="title function_">has</span>(someName))<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Set的写法&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>Array.from</code>方法可以将 Set 结构转为数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;<span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-遍历操作"><a href="#Ⅳ-遍历操作" class="headerlink" title="Ⅳ - 遍历操作"></a>Ⅳ - 遍历操作</h3><blockquote><p>Set 结构的实例有四个遍历方法，可以用于遍历成员. </p><ul><li><code>Set.prototype.keys()</code>: 返回键名的遍历器</li><li><code>Set.prototype.values()</code>: 返回键值的遍历器</li><li><code>Set.prototype.entries()</code>: 返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>: 使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序. 这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用</p></blockquote><h4 id="①-keys-，values-，entries"><a href="#①-keys-，values-，entries" class="headerlink" title="① keys()，values()，entries()"></a>① <code>keys()</code>，<code>values()</code>，<code>entries()</code></h4><blockquote><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》）. 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------  set.keys()  -------------&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------  set.values()  -------------&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------  set.entries()  -------------&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(item) &#125;</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830180145744.png" alt="image-20210830180145744"> 上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等. </p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">values</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>]);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) &#125;</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830180417020.png" alt="image-20210830180417020">  </p></blockquote><h4 id="②-forEach"><a href="#②-forEach" class="headerlink" title="② forEach()"></a>② forEach()</h4><blockquote><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的大帅哥&#x27;</span>]);</span><br><span class="line">&gt;set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830180645571.png" alt="image-20210830180645571"> </p><blockquote><ul><li>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数. </li><li>该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）. </li><li>这里需要注意，Set 结构的键名就是键值（两者是同一个值)，因此第一个参数与第二个参数的值永远都是一样的. </li></ul></blockquote><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象. </p></blockquote><h4 id="③-遍历的应用"><a href="#③-遍历的应用" class="headerlink" title="③ 遍历的应用"></a>③ 遍历的应用</h4><blockquote><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>]);</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...set]; <span class="comment">// [&quot;努力&quot;, &quot;学习&quot;, &quot;的汪&quot;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>,<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>,<span class="string">&#x27;不学习&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">//  [&quot;努力&quot;, &quot;的汪&quot;, &quot;学习&quot;, &quot;不学习&quot;]</span></span><br></pre></td></tr></table></figure><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line">&gt;<span class="comment">// 返回Set结构: &#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line">&gt;<span class="comment">// 返回Set结构: &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 并集</span></span><br><span class="line">&gt;<span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line">&gt;<span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 交集</span></span><br><span class="line">&gt;<span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line">&gt;<span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line">&gt;<span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line">&gt;<span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-改变原来的-Set-结构"><a href="#Ⅴ-改变原来的-Set-结构" class="headerlink" title="Ⅴ -  改变原来的 Set 结构"></a>Ⅴ -  改变原来的 Set 结构</h3><blockquote><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法. 一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 方法一</span></span><br><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line">&gt;<span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 方法二</span></span><br><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line">&gt;<span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构. </p></blockquote><h3 id="Ⅵ-WeakSet"><a href="#Ⅵ-WeakSet" class="headerlink" title="Ⅵ - WeakSet"></a>Ⅵ - WeakSet</h3><blockquote><p>到目前为止本人对于此知识点( WeakSet )实践遇到较少,所以此处笔记主要为知识点摘录,后续若实践遇到,再来补充自己理解</p></blockquote><h4 id="①-含义-1"><a href="#①-含义-1" class="headerlink" title="① 含义"></a>① 含义</h4><blockquote><p>WeakSet 结构与 Set 类似，也是不重复的值的集合. 但是，它与 Set 有两个区别. </p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">&gt;ws.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">&gt;ws.<span class="title function_">add</span>(<span class="title class_">Symbol</span>())</span><br><span class="line">&gt;<span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象. </p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中. </p><p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存. 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏. WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题. 因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息. 只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失. </p><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失. 另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历. </p><p>这些特点同样适用于本章后面要介绍的 WeakMap 结构. </p></blockquote><h4 id="②-语法"><a href="#②-语法" class="headerlink" title="② 语法"></a>② 语法</h4><blockquote><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数. （实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数. ）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line">&gt;<span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组. 将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员. </p><p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身. 这意味着，数组的成员只能是对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(b);</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错. </p><p>WeakSet 结构有以下三个方法. </p><ul><li><strong>WeakSet.prototype.add(value)</strong>: 向 WeakSet 实例添加一个新成员. </li><li><strong>WeakSet.prototype.delete(value)</strong>: 清除 WeakSet 实例的指定成员. </li><li><strong>WeakSet.prototype.has(value)</strong>: 返回一个布尔值，表示某个值是否在 WeakSet 实例之中. </li></ul><p>下面是一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">add</span>(<span class="variable language_">window</span>);</span><br><span class="line">&gt;ws.<span class="title function_">add</span>(obj);</span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">has</span>(<span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">&gt;ws.<span class="title function_">has</span>(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">delete</span>(<span class="variable language_">window</span>);</span><br><span class="line">&gt;ws.<span class="title function_">has</span>(<span class="variable language_">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;ws.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">&gt;ws.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功. </p><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了. WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏. </p><p>下面是 WeakSet 的另一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   foos.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> method () &#123;</span><br><span class="line">   <span class="keyword">if</span> (!foos.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在Foo的实例上调用！&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用. 这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏. </p></blockquote><h3 id="Ⅶ-做个题目吧"><a href="#Ⅶ-做个题目吧" class="headerlink" title="Ⅶ - 做个题目吧"></a>Ⅶ - 做个题目吧</h3><blockquote><p>光说不练假把式,试着回答几个问题检测下是否理解Set 数据结构</p></blockquote><h3 id="①-代码阅读题1"><a href="#①-代码阅读题1" class="headerlink" title="① 代码阅读题1:"></a>① 代码阅读题1:</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">s.<span class="title function_">add</span>([<span class="number">1</span>]);</span><br><span class="line">s.<span class="title function_">add</span>([<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">size</span>);</span><br></pre></td></tr></table></figure><p><strong>问: 打印出来的size的值是多少？</strong></p><p>答: 2，两个[1]定义的是两个不同的数组，在内存中的存储地址不同，所以是不同的值</p></blockquote><h3 id="②-代码阅读题2"><a href="#②-代码阅读题2" class="headerlink" title="② 代码阅读题2:"></a>② 代码阅读题2:</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> str=<span class="string">&#x27;abstract&#x27;</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...str]).<span class="property">size</span>);<span class="comment">//6  重复的无法加入</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="12、Map-数据结构"><a href="#12、Map-数据结构" class="headerlink" title="12、Map 数据结构"></a>12、Map 数据结构</h2><h3 id="Ⅰ-概括与总结-4"><a href="#Ⅰ-概括与总结-4" class="headerlink" title="Ⅰ - 概括与总结"></a>Ⅰ - 概括与总结</h3><h4 id="①-Map"><a href="#①-Map" class="headerlink" title="①  Map"></a>①  Map</h4><blockquote><ul><li>定义: 类似于对象的数据结构，成员键是任何类型的值</li><li>声明: <code>const set = new Map(arr)</code></li><li>入参: 具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数，返回Map</li><li><strong>size</strong>: 返回实例成员总数</li><li>方法</li><li><strong>get()</strong>: 返回键值对</li><li><strong>set()</strong>: 添加键值对，返回实例</li><li><strong>delete()</strong>: 删除键值对，返回布尔</li><li><strong>has()</strong>: 检查键值对，返回布尔</li><li><strong>clear()</strong>: 清除所有成员</li><li><strong>keys()</strong>: 返回以键为遍历器的对象</li><li><strong>values()</strong>: 返回以值为遍历器的对象</li><li><strong>entries()</strong>: 返回以键和值为遍历器的对象</li><li><strong>forEach()</strong>: 使用回调函数遍历每个成员</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>遍历顺序: 插入顺序</li><li>对同一个键多次赋值，后面的值将覆盖前面的值</li><li>对同一个对象的引用，被视为一个键</li><li>对同样值的两个实例，被视为两个键</li><li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li><li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li><li><code>Object结构</code>提供<code>字符串—值</code>的对应，<code>Map结构</code>提供<code>值—值</code>的对应</li></ul></blockquote><h4 id="②-WeakMap"><a href="#②-WeakMap" class="headerlink" title="② WeakMap"></a>② WeakMap</h4><blockquote><ul><li>定义: 和Map结构类似，成员键只能是对象</li><li>声明: <code>const set = new WeakMap(arr)</code></li><li>入参: 具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数，返回WeakMap</li><li>方法</li><li><strong>get()</strong>: 返回键值对</li><li><strong>set()</strong>: 添加键值对，返回实例</li><li><strong>delete()</strong>: 删除键值对，返回布尔</li><li><strong>has()</strong>: 检查键值对，返回布尔</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>储存DOM节点: DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性: 内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>成员键都是<code>弱引用</code>，垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap结构不可遍历</code></li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap结构</code>中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的<code>只是键而不是值</code>，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul></blockquote><h3 id="Ⅱ-含义和基本用法"><a href="#Ⅱ-含义和基本用法" class="headerlink" title="Ⅱ - 含义和基本用法"></a>Ⅱ - 含义和基本用法</h3><h4 id="①-map-出现的意义"><a href="#①-map-出现的意义" class="headerlink" title="① map()出现的意义"></a>① map()出现的意义</h4><blockquote><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键. 这给它的使用带来了很大的限制. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">//取得的 HTMLDivElement 元素对象</span></span><br><span class="line"></span><br><span class="line">&gt;data[element] = <span class="string">&#x27;努力学习的汪&#x27;</span>; <span class="comment">//尝试将其当作key 并赋值</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(element) <span class="comment">// &quot;&lt;div&gt;...&lt;/div&gt;&quot;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="string">&#x27;[object HTMLDivElement]&#x27;</span>]) <span class="comment">// &quot;努力学习的汪&quot;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830183644910.png" alt="image-20210830183644910"> 上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>. </p><p>为了解决这个问题，ES6 提供了 Map 数据结构. 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键. 也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现. 如果你需要“键值对”的数据结构，Map 比 Object 更合适. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> o = &#123; <span class="attr">name</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m) <span class="comment">//Map(0) &#123;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------  写入O属性 ----------&#x27;</span>)</span><br><span class="line">&gt;m.<span class="title function_">set</span>(o, <span class="string">&#x27;努力学习的汪&#x27;</span>) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">keys</span>())  <span class="comment">//MapIterator &#123;&#123;…&#125;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(o))  <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m) <span class="comment">//Map(1) &#123;&#123;…&#125; =&gt; &quot;努力学习的汪&quot;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------  删除O属性 ----------&#x27;</span>)</span><br><span class="line">&gt;m.<span class="title function_">delete</span>(o) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m)  <span class="comment">//Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830184513952.png" alt="image-20210830184513952"> </p><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键. </p></blockquote><h4 id="②-接受数组作为参数"><a href="#②-接受数组作为参数" class="headerlink" title="② 接受数组作为参数"></a>② 接受数组作为参数</h4><blockquote><p>上面的例子展示了如何向 Map 添加成员. 作为构造函数，Map 也可以接受一个数组作为参数. 该数组的成员是一个个表示键值对的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">&gt;[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line">&gt;[<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">&gt;]);</span><br><span class="line">&gt;map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">&gt;map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;努力学习的汪&quot;</span></span><br><span class="line">&gt;map.<span class="title function_">has</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>. </p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> items = [</span><br><span class="line">&gt;[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line">&gt;[<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;items.<span class="title function_">forEach</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.<span class="title function_">set</span>(key, value)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数. 这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([</span><br><span class="line">&gt;[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line">&gt;[<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">&gt;]);</span><br><span class="line">&gt;<span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>(set);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m1)              <span class="comment">//Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;bar&quot; =&gt; 2&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m1.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>))  <span class="comment">//努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m2)<span class="comment">//Map(1) &#123;&quot;baz&quot; =&gt; 3&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>(m2);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m3) <span class="comment">//Map(1) &#123;&quot;baz&quot; =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831095025529.png" alt="image-20210831095025529"> </p><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象. </p></blockquote><h4 id="③-对同一个键多次赋值，后面的值将覆盖前面的值"><a href="#③-对同一个键多次赋值，后面的值将覆盖前面的值" class="headerlink" title="③ 对同一个键多次赋值，后面的值将覆盖前面的值"></a>③ 对同一个键多次赋值，后面的值将覆盖前面的值</h4><blockquote><p>如果对同一个键多次赋值，后面的值将覆盖前面的值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;hongjilin&#x27;</span>).<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">//Map(1) &#123;1 =&gt; &quot;努力学习的汪&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831094538046.png" alt="image-20210831094538046"> 上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值. </p><p>如果读取一个未知的键，则返回<code>undefined</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">get</span>(<span class="string">&#x27;随便输入的键值&#x27;</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-只有对同一个对象的引用，Map-结构才将其视为同一个键"><a href="#④-只有对同一个对象的引用，Map-结构才将其视为同一个键" class="headerlink" title="④  只有对同一个对象的引用，Map 结构才将其视为同一个键"></a>④  只有对同一个对象的引用，Map 结构才将其视为同一个键</h4><blockquote><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键. 这一点要非常小心. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="comment">//实际上下方两个 [&#x27;name&#x27;] 是不同实例,相当于只是语法糖 [&#x27;name&#x27;] == 等同 ==&gt; new Array(&#x27;name&#x27;)</span></span><br><span class="line">&gt;map.<span class="title function_">set</span>([<span class="string">&#x27;name&#x27;</span>], <span class="string">&#x27;努力学习的汪&#x27;</span>); </span><br><span class="line">&gt;map.<span class="title function_">get</span>([<span class="string">&#x27;name&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>. </p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> k1 = [<span class="string">&#x27;name&#x27;</span>];   <span class="comment">//实际上相当于是语法糖 [&#x27;name&#x27;] == 等同 ==&gt; new Array(&#x27;name&#x27;)</span></span><br><span class="line">&gt;<span class="keyword">const</span> k2 = [<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&gt;map.<span class="title function_">set</span>(k1, <span class="number">111</span>).<span class="title function_">set</span>(k2, <span class="number">222</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map)  <span class="comment">// Map(2) &#123;Array(1) =&gt; 111, Array(1) =&gt; 222&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(k1),map.<span class="title function_">get</span>(k2))  <span class="comment">// 111 222</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831095859490.png" alt="image-20210831095859490"> </p><p>上面代码中，变量 [ k1 ] 和 [ k2 ] 的值是一样的，但是它们在 Map 结构中被视为两个键. </p><p>由上可知，<code>Map 的键实际上是跟内存地址绑定的</code>，只要内存地址不一样，就视为两个键. 这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名. </p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键. 另外，<code>undefined</code>和<code>null</code>也是两个不同的键. 虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="title class_">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-实例的属性和操作方法"><a href="#Ⅲ-实例的属性和操作方法" class="headerlink" title="Ⅲ -  实例的属性和操作方法"></a>Ⅲ -  实例的属性和操作方法</h3><blockquote><p>Map 结构的实例有以下属性和操作方法.  </p></blockquote><h4 id="①-size-属性"><a href="#①-size-属性" class="headerlink" title="① size 属性"></a>① size 属性</h4><blockquote><p><code>size</code>属性返回 Map 结构的成员总数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Map-prototype-set-key-value"><a href="#②-Map-prototype-set-key-value" class="headerlink" title="② Map.prototype.set(key, value)"></a>② Map.prototype.set(key, value)</h4><blockquote><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构. 如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="number">666</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;xxxx&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m)  <span class="comment">//Map(3) &#123;&quot;age&quot; =&gt; 18, 666 =&gt; &quot;努力学习的汪&quot;, undefined =&gt; &quot;xxxx&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;努力&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;学习&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map)    <span class="comment">//Map(3) &#123;1 =&gt; &quot;努力&quot;, 2 =&gt; &quot;学习&quot;, 3 =&gt; &quot;的汪&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831101956692.png" alt="image-20210831101956692"> </p></blockquote><h4 id="③-Map-prototype-get-key"><a href="#③-Map-prototype-get-key" class="headerlink" title="③  Map.prototype.get(key)"></a>③  Map.prototype.get(key)</h4><blockquote><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Learn ES6&#x27;</span>)&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> name = &#123;name : <span class="string">&quot;hongjilin&quot;</span>&#125;</span><br><span class="line">&gt;m.<span class="title function_">set</span>(hello, <span class="string">&#x27;你好 ES6&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(name, <span class="string">&#x27;努力学习的汪&#x27;</span>) <span class="comment">// 键是对象</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;字符串名字&#x27;</span>) <span class="comment">// 键是字符串</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;键是函数:&quot;</span>,m.<span class="title function_">get</span>(hello),<span class="string">&quot;;键是对象:&quot;</span>,m.<span class="title function_">get</span>(name),<span class="string">&quot;;键是字符串:&quot;</span>,m.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;找不到的键&#x27;</span>,m.<span class="title function_">get</span>(<span class="string">&#x27;找不到的键&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831102632292.png" alt="image-20210831102632292"> </p></blockquote><h4 id="④-Map-prototype-has-key"><a href="#④-Map-prototype-has-key" class="headerlink" title="④ Map.prototype.has(key)"></a>④ Map.prototype.has(key)</h4><blockquote><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="number">666</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;xxxx&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;age&#x27;</span>))   <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="number">666</span>))  <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="literal">undefined</span>))    <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;不存在的键&#x27;</span>))  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Map-prototype-delete-key"><a href="#⑤-Map-prototype-delete-key" class="headerlink" title="⑤ Map.prototype.delete(key)"></a>⑤ Map.prototype.delete(key)</h4><blockquote><p><code>delete</code>方法删除某个键，返回<code>true</code>. 如果删除失败，返回<code>false</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;undefined!&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m,m.<span class="title function_">has</span>(<span class="literal">undefined</span>)) <span class="comment">// Map(1) &#123;undefined =&gt; &quot;undefined!&quot;&#125; true</span></span><br><span class="line"></span><br><span class="line">&gt;m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m,m.<span class="title function_">has</span>(<span class="literal">undefined</span>)) <span class="comment">// Map(0) &#123;&#125; false</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-Map-prototype-clear"><a href="#⑥-Map-prototype-clear" class="headerlink" title="⑥ Map.prototype.clear()"></a>⑥ Map.prototype.clear()</h4><blockquote><p><code>clear</code>方法清除所有成员，没有返回值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br><span class="line">&gt;map.<span class="title function_">clear</span>()</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-遍历方法"><a href="#Ⅳ-遍历方法" class="headerlink" title="Ⅳ -  遍历方法"></a>Ⅳ -  遍历方法</h3><blockquote><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法. </p><ul><li><code>Map.prototype.keys()</code>: 返回键名的遍历器. </li><li><code>Map.prototype.values()</code>: 返回键值的遍历器. </li><li><code>Map.prototype.entries()</code>: 返回所有成员的遍历器. </li><li><code>Map.prototype.forEach()</code>: 遍历 Map 的所有成员. </li></ul></blockquote><h4 id="①-Map-的遍历顺序就是插入顺序"><a href="#①-Map-的遍历顺序就是插入顺序" class="headerlink" title="① Map 的遍历顺序就是插入顺序"></a>① Map 的遍历顺序就是插入顺序</h4><blockquote><p>需要特别注意的是，Map 的遍历顺序就是插入顺序. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;handsome&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">&gt;]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------- keys() ---------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------- values() ---------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------- entries() ---------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]) &#125;</span><br><span class="line">&gt;<span class="comment">// 或者</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value) &#125;</span><br><span class="line">&gt;<span class="comment">// 等同于使用map.entries()</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value) &#125;</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831104307237.png" alt="image-20210831104307237">  上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性)，就是<code>entries</code>方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === map.<span class="property">entries</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Map-结构转为数组结构"><a href="#②-Map-结构转为数组结构" class="headerlink" title="② Map 结构转为数组结构"></a>② Map 结构转为数组结构</h4><blockquote><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([ [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],[<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],[<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>] ]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">keys</span>()])<span class="comment">// [1, 2, 3]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">values</span>()])<span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">entries</span>()])<span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map])<span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>( [...map].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>) );</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map1) <span class="comment">// Map(2) &#123;1 =&gt; &quot;a&quot;, 2 =&gt; &quot;b&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>( [...map].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;*&#x27;</span> + v]) );</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map2) <span class="comment">//Map(3) &#123;2 =&gt; &quot;*a&quot;, 4 =&gt; &quot;*b&quot;, 6 =&gt; &quot;*c&quot;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Map-的-forEach-方法"><a href="#③-Map-的-forEach-方法" class="headerlink" title="③ Map 的  forEach()  方法"></a>③ Map 的  <code>forEach()</code>  方法</h4><blockquote><p>Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>. 下面举个栗子说明:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;不读书&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> reporter = &#123;</span><br><span class="line"> <span class="attr">report</span>: <span class="keyword">function</span>(<span class="params">key, value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//第二个参数绑定后,可以通过this取得其内部属性方法</span></span><br><span class="line">&gt;map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;<span class="variable language_">this</span>.<span class="title function_">report</span>(key, value); &#125;, reporter);</span><br><span class="line">&gt;<span class="comment">//不绑定示例  报错!!</span></span><br><span class="line">&gt;map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;<span class="variable language_">this</span>.<span class="title function_">report</span>(key, value); &#125;);</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831105438551.png" alt="image-20210831105438551"> 上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>. </p></blockquote><h3 id="Ⅴ-与其他数据结构的互相转换"><a href="#Ⅴ-与其他数据结构的互相转换" class="headerlink" title="Ⅴ - 与其他数据结构的互相转换"></a>Ⅴ - 与其他数据结构的互相转换</h3><h4 id="①-Map-转为数组"><a href="#①-Map-转为数组" class="headerlink" title="① Map 转为数组"></a>① Map 转为数组</h4><blockquote><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>).<span class="title function_">set</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;对象&#x27;</span>&#125;, [<span class="string">&#x27;这是数组&#x27;</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...myMap])</span><br><span class="line">&gt;<span class="comment">//[ [true, 1] , [&#123;name: &quot;对象&quot;&#125;,[&quot;这是数组&quot;]]  ]  ==&gt;数组内部两个二维数组</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831110044997.png" alt="image-20210831110044997">  </p></blockquote><h4 id="②-数组-转为-Map"><a href="#②-数组-转为-Map" class="headerlink" title="② 数组 转为 Map"></a>② 数组 转为 Map</h4><blockquote><p>将数组传入 Map 构造函数，就可以转为 Map. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>).<span class="title function_">set</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;对象&#x27;</span>&#125;, [<span class="string">&#x27;这是数组&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831110236279.png" alt="image-20210831110236279"> </p></blockquote><h4 id="③-Map-转为对象"><a href="#③-Map-转为对象" class="headerlink" title="③ Map 转为对象"></a>③ Map 转为对象</h4><blockquote><p>如果所有 Map 的键都是字符串，它可以无损地转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">//创建一个空对象</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;  obj[k] = v &#125; <span class="comment">//循环遍历并给空对象赋值</span></span><br><span class="line"> <span class="keyword">return</span> obj;  <span class="comment">//最后将加工好的对象返回出去</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//字符串的键转对象</span></span><br><span class="line">&gt;<span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">strMapToObj</span>(myMap))</span><br><span class="line">&gt;<span class="comment">//其他转对象</span></span><br><span class="line">&gt;<span class="keyword">const</span> testMap =<span class="title function_">strMapToObj</span>( <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">&gt;.<span class="title function_">set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>), <span class="string">&#x27;文档对象&#x27;</span>).<span class="title function_">set</span>(<span class="literal">true</span>, <span class="string">&#x27;布尔值&#x27;</span>).<span class="title function_">set</span>(<span class="number">123</span>,<span class="string">&quot;数值&quot;</span>) )<span class="comment">//转为对象时都转为了字符串形式</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(testMap)</span><br></pre></td></tr></table></figure><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名. </p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831111717060.png" alt="image-20210831111717060"></p><p>当然,如果你像是布尔值或者数值 如输入时直接 testMap[true] 也能获得结果,因为有<code>隐式转换</code>,这就涉及JS基础了</p></blockquote><h4 id="④-对象转为-Map"><a href="#④-对象转为-Map" class="headerlink" title="④ 对象转为 Map"></a>④ 对象转为 Map</h4><blockquote><p>对象转为 Map 可以通过<code>Object.entries()</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;handsome&#x27;</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">&gt;<span class="comment">//其实就是通过[Object.entries()]将对象转化为数组,再通过Map()构造函数转化为Map</span></span><br><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)); <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br></pre></td></tr></table></figure><p>此外，也可以自己实现一个转换函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 定义一个空的Map</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;  strMap.<span class="title function_">set</span>(k, obj[k]) &#125; <span class="comment">//通过循环将对象内容取出并加入Map中</span></span><br><span class="line"> <span class="keyword">return</span> strMap;   <span class="comment">//最后返回</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="title function_">objToStrMap</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;handsome&#x27;</span>:<span class="literal">true</span>&#125;)<span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Map-转为-JSON"><a href="#⑤-Map-转为-JSON" class="headerlink" title="⑤ Map 转为 JSON"></a>⑤ Map 转为 JSON</h4><h5 id="a-Map-的键名都是字符串"><a href="#a-Map-的键名都是字符串" class="headerlink" title="a) Map 的键名都是字符串"></a>a) Map 的键名都是字符串</h5><blockquote><p>Map 转为 JSON 要区分两种情况. 一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map转对象 函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">strMapToObj</span>=(<span class="params">strMap</span>)=&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;obj[k] = v;&#125;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//对象转JSON 函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">strMapToJson</span>=(<span class="params">strMap</span>)=&gt;  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&gt;<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">strMapToObj</span>(myMap))  <span class="comment">//调用map转对象,查看效果</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">strMapToJson</span>(myMap))  <span class="comment">//调用map转对象 对象转JSON 方法</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831114712158.png" alt="image-20210831114712158"> </p></blockquote><h5 id="b-Map-的键名有非字符串"><a href="#b-Map-的键名有非字符串" class="headerlink" title="b)  Map 的键名有非字符串"></a>b)  Map 的键名有非字符串</h5><blockquote><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//Map转JSON函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">mapToArrayJson</span>=(<span class="params">map</span>)=&gt; <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]) </span><br><span class="line">&gt;<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>).<span class="title function_">set</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;对象&#x27;</span>&#125;, [<span class="string">&#x27;这是数组&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...myMap]) <span class="comment">//查看点运算符解构转换后结果</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mapToArrayJson</span>(myMap)) <span class="comment">//调用转换函数</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831115125771.png" alt="image-20210831115125771"> </p></blockquote><h4 id="⑥-JSON-转为-Map"><a href="#⑥-JSON-转为-Map" class="headerlink" title="⑥ JSON 转为 Map"></a>⑥ JSON 转为 Map</h4><blockquote><p>JSON 转为 Map，正常情况下，所有键名都是字符串. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 定义一个空的Map</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;  strMap.<span class="title function_">set</span>(k, obj[k]) &#125; <span class="comment">//通过循环将对象内容取出并加入Map中</span></span><br><span class="line"> <span class="keyword">return</span> strMap;   <span class="comment">//最后返回</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">jsonToStrMap</span>=(<span class="params">jsonStr</span>) =&gt; <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;努力学习的汪&quot;,&quot;handsome&quot;:true&#125;&#x27;</span>))</span><br><span class="line">&gt;<span class="comment">//log: Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组. 这时，它可以一一对应地转为 Map. 这往往是 Map 转为数组 JSON 的逆操作. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span>  <span class="title function_">jsonToMap</span> = (<span class="params">jsonStr</span>) =&gt;  <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&gt;<span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,1],[&#123;&quot;name&quot;:&quot;对象&quot;&#125;,[&quot;这是数组&quot;]]]&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831115700778.png" alt="image-20210831115700778"> </p></blockquote><h4 id="⑦-WeakMap"><a href="#⑦-WeakMap" class="headerlink" title="⑦ WeakMap"></a>⑦ WeakMap</h4><blockquote><p>此处知识点本人较少用到,就暂不整理,留后续补充</p></blockquote><h3 id="Ⅵ-map-方法"><a href="#Ⅵ-map-方法" class="headerlink" title="Ⅵ - map()方法:"></a>Ⅵ - map()方法:</h3><blockquote><p><strong>map(): 映射，即原数组映射成一个新的数组</strong>–&gt; <code>非常常用</code></p><p>map方法接受一个新参数，这个参数就是将原数组变成新数组的映射关系. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">fun1</span>=(<span class="params">arr</span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">let</span> array = [];</span><br><span class="line"> arr.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span>  array.<span class="title function_">push</span>(item*item) );</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">fun2</span>=(<span class="params">arr</span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"> arr.<span class="title function_">map</span>( <span class="keyword">function</span>(<span class="params">item</span>)&#123; array.<span class="title function_">push</span>(item*item) &#125;);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> arr1 = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&gt;<span class="title function_">fun1</span>(arr1);    <span class="comment">//[25, 4, 1, 9, 16]</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&gt;<span class="title function_">fun1</span>(arr2);   <span class="comment">// [1, 4, 9, 16, 25]</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr3 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>];</span><br><span class="line">&gt;<span class="title function_">fun2</span>(arr3);   <span class="comment">//[9, 16, 25, 1, 4, 36] </span></span><br></pre></td></tr></table></figure><p>在实际的应用中，我们可以通过map方法得到某一个对象数组中特定属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = [</span><br><span class="line"> &#123;<span class="attr">name</span>:<span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">name</span>:<span class="string">&#x27;hongjilin&#x27;</span>,<span class="attr">age</span>:<span class="number">88</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">name</span>:<span class="string">&#x27;帅小伙&#x27;</span>,<span class="attr">age</span>:<span class="number">66</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">&gt;]</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">getter</span>=(<span class="params">obj</span>)=&gt;&#123; obj.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">name</span>) &#125;)&#125;</span><br><span class="line">&gt;<span class="title function_">getter</span>(obj);</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831181721474.png" alt="image-20210831181721474">  </p><p>map方法的作用不难理解，即“映射”，也就是原数组被“映射”成对应新数组. 下面这个例子是数值项求平方: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span> item * item);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arrayOfSquares); <span class="comment">// 1, 4, 9, 16</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//callback需要有return值，如果没有，就像下面这样: </span></span><br><span class="line">&gt;<span class="keyword">var</span> data1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">var</span> arrayOfSquares1 = data.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arrayOfSquares1)<span class="comment">//数组所有项都被映射成了undefined: </span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831181951620.png" alt="image-20210831181951620"> </p></blockquote><h3 id="Ⅶ-做个题目吧-1"><a href="#Ⅶ-做个题目吧-1" class="headerlink" title="Ⅶ - 做个题目吧"></a>Ⅶ - 做个题目吧</h3><blockquote><p>光说不练假把式,试着回答几个问题检测下是否理解 Mep 数据结构</p></blockquote><h3 id="①-代码阅读题"><a href="#①-代码阅读题" class="headerlink" title="① 代码阅读题"></a>① 代码阅读题</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>([<span class="number">1</span>],<span class="string">&quot;ES6系列&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> con = map.<span class="title function_">get</span>([<span class="number">1</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(con);</span><br></pre></td></tr></table></figure><p><strong>问: 打印出来的变量con的值是多少，为什么？</strong></p><blockquote><p>答: undefined. 因为set的时候用的数组[1]和get的时候用的数组[1]是分别两个不同的数组，只不过它们元素都是1. 它们是分别定义的两个数组，并不是同一个值. </p></blockquote><p>**如果想达到预期的效果，你要保证get的时候和set的时候用同一个数组. 比如: **</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="number">1</span>];</span><br><span class="line">&gt;map.<span class="title function_">set</span>(arr,<span class="string">&quot;ES6系列&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> con = map.<span class="title function_">get</span>(arr);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(con); <span class="comment">//ES6系列</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="13、Proxy"><a href="#13、Proxy" class="headerlink" title="13、Proxy"></a>13、Proxy</h2><blockquote><p>很重要的知识点,也许你初入前端的时候会用的比较少,但是在后面进阶开发中此知识点是绕不过的,这知识点常与下方 <strong>Reflect</strong> 搭配使用</p><p>嗯,如果你是Vue前端工程师,那这个就更要掌握了,毕竟Vue3.x双向绑定就是用这个知识点实现的</p><p>下面我也会用Proxy自己模拟实现一个数据双向绑定</p></blockquote><h3 id="Ⅰ-概括与总结-5"><a href="#Ⅰ-概括与总结-5" class="headerlink" title="Ⅰ - 概括与总结"></a>Ⅰ - 概括与总结</h3><blockquote><ol><li>定义: Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程. </li><li>声明: <code>const proxy = new Proxy(target, handler)</code></li><li>入参:<ul><li><strong>target</strong>: 拦截的目标对象</li><li><strong>handler</strong>: 定制拦截行为</li></ul></li><li>方法:<ul><li><strong>Proxy.revocable()</strong>: 返回可取消的Proxy实例(返回<code>&#123; proxy, revoke &#125;</code>，通过revoke()取消代理)</li></ul></li></ol><blockquote><p>下面是 Proxy 支持的拦截操作一览，一共 13 种. </p></blockquote><ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>. </li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值. </li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值. </li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值. </li><li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组. 该方法返回目标对象所有自身的属性的属性名，而 [Object.keys()] 的返回结果仅包括目标对象自身的可遍历属性. </li><li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象. </li><li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值. </li><li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值. </li><li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象. </li><li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值. </li><li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值. 如果目标对象是函数，那么还有两种额外操作可以拦截. </li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>. </li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>. </li></ul><blockquote><p>应用场景</p></blockquote><ul><li><code>Proxy.revocable()</code>: 不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li><li><code>get()</code>: 读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li><li><code>set()</code>: 数据绑定(Vue数据双向绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li><code>has()</code>: 隐藏内部属性不被发现、排除不符合属性条件的对象</li><li><code>deleteProperty()</code>: 保护内部属性不被删除</li><li><code>defineProperty()</code>: 阻止属性被外部定义</li><li> [ownKeys()] : 保护内部属性不被遍历</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>要使 [ Proxy ] 起作用，必须针对<code>实例</code>进行操作，而不是针对<code>目标对象</code>进行操作</li><li>没有设置任何拦截时，等同于<code>直接通向原对象</code></li><li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时，使用拦截方法会报错</li><li>代理下的目标对象，内部<code>this</code>指向<code>Proxy代理</code></li></ul></blockquote><h3 id="Ⅱ-概念结合实例解析"><a href="#Ⅱ-概念结合实例解析" class="headerlink" title="Ⅱ - 概念结合实例解析"></a>Ⅱ - 概念结合实例解析</h3><blockquote><p>通过分析简单常用的例子,来帮助我们理解Proxy</p></blockquote><h4 id="①-概述"><a href="#①-概述" class="headerlink" title="①  概述"></a>①  概述</h4><blockquote><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程. </p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写. Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="comment">//拦截的对象,传入的对象属性,整个proxy对象</span></span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="comment">// [ Reflect.get ] 方法查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`. </span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);  <span class="comment">//详见下方Reflect一章,但此处不深究</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="comment">//`Reflect.set`方法设置`target`对象的`name`属性等于`value`. </span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为. 这里暂时先不解释具体的语法(详见下一章节 &lt; Reflect &gt;)，只看运行结果. 对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;obj.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">&gt;<span class="comment">//  setting count!</span></span><br><span class="line">&gt;++obj.<span class="property">count</span></span><br><span class="line">&gt;<span class="comment">//  getting count!</span></span><br><span class="line">&gt;<span class="comment">//  setting count!</span></span><br><span class="line">&gt;<span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901150537854.png" alt="image-20210901150537854"> 上面代码说明，Proxy 实际上重载（overload)了点运算符，即用自己的定义覆盖了语言的原始定义. </p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法. 其中，<code>new Proxy()</code>表示生成一个 [ Proxy ] 实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为. </p></blockquote><h4 id="②-举个拦截读取属性行为的栗子"><a href="#②-举个拦截读取属性行为的栗子" class="headerlink" title="② 举个拦截读取属性行为的栗子"></a>② 举个拦截读取属性行为的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, propKey</span>)=&gt;</span> <span class="string">&#x27;努力学习的汪&#x27;</span> <span class="comment">//温习下:ES6箭头函数写法,如果你对这个写法陌生一定要回头去巩固</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>) <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">title</span>) <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;proxy.<span class="property">a</span> = <span class="number">1</span> <span class="comment">//写入操作,修改[a]属性</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">a</span>) <span class="comment">//由于[读] 操作已经被拦截,所有 [读] 操作都返回的是 &#x27;努力学习的汪&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901151222628.png" alt="image-20210901151222628"> 上面代码中，作为构造函数， [ Proxy ] 接受两个参数 : </p><ul><li><p>第一个参数是所要代理的目标对象（上例是一个空对象)，即如果没有 [ Proxy ] 的介入，操作原来要访问的就是这个对象；</p></li><li><p>第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作:</p></li></ul><blockquote><p>比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求. </p><p><code>get</code>方法的两个参数分别是目标对象和所要访问的属性. </p><p>可以看到，由于拦截函数总是返回[<code>努力学习的汪</code>]，所以即使我给其设置了值,访问任何属性都得到[<code>努力学习的汪</code>]. </p></blockquote></blockquote><h4 id="③-没有设置任何拦截-等同-直接通向原对象"><a href="#③-没有设置任何拦截-等同-直接通向原对象" class="headerlink" title="③ 没有设置任何拦截 等同 直接通向原对象."></a>③ 没有设置任何拦截 等同 直接通向原对象.</h4><blockquote><p>注意，要使得 [ Proxy ] 起作用，必须针对 [ Proxy ] 实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作. </p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">a</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;target.<span class="property">a</span> <span class="comment">// &quot;努力学习的汪&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>. </p><p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-Proxy-实例作为其他对象的原型对象"><a href="#④-Proxy-实例作为其他对象的原型对象" class="headerlink" title="④ Proxy 实例作为其他对象的原型对象"></a>④ Proxy 实例作为其他对象的原型对象</h4><blockquote><p>Proxy 实例也可以作为其他对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, propKey</span>)=&gt;</span><span class="string">&#x27;不努力学习的单身汪&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">&gt;obj.<span class="property">name</span>=<span class="string">&#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">xxx</span>)  <span class="comment">// 不努力学习的单身汪</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901152237811.png" alt="image-20210901152237811"> 上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型</p><blockquote><ul><li><code>obj</code>对象本身并有 [ name ] 属性,当访问 [ name ] 属性时,因为对象本身有,就不会去其原型上找,所以不会触发拦截</li><li><code>obj</code>对象本身并没有 [ xxx ] 属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</li></ul></blockquote></blockquote><h4 id="⑤-同一个拦截器函数-设置拦截多个操作"><a href="#⑤-同一个拦截器函数-设置拦截多个操作" class="headerlink" title="⑤ 同一个拦截器函数, 设置拦截多个操作"></a>⑤ 同一个拦截器函数, 设置拦截多个操作</h4><blockquote><p>同一个拦截器函数，可以设置拦截多个操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//当读取拦截对象的 [ prototype ],返回的是 Object的 [ prototype ]</span></span><br><span class="line">   <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>)  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">     <span class="comment">//如果读取非[ prototype ]属性,返回加工后的属性名</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;进行了非[prototype]属性的读取: &#x27;</span> + name;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">//温习巩固一下:箭头函数、标签语法</span></span><br><span class="line"> <span class="attr">apply</span>: <span class="function">(<span class="params">target, thisBinding, args</span>) =&gt;</span> <span class="string">`拦截进入apply:<span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>`</span>,</span><br><span class="line"><span class="comment">//构造函数 温习一下:构造函数不能使用箭头函数,如果不知道为什么的需要回头去巩固下-&gt;箭头函数没有自己的 this</span></span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;  <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="string">`拦截进入构造函数:<span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>`</span>&#125;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//new 一个 Proxy 实例</span></span><br><span class="line">&gt;<span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&gt;&#125;, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 拦截进入apply:1</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">//&#123;value: &quot;拦截进入构造函数:2&quot;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(fproxy.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//对比读取fproxy与Object的 [prototype]属性是否一致 ==true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(fproxy.<span class="property">xxx</span>)  <span class="comment">//进行了非[prototype]属性的读取: xxx</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901154515337.png" alt="image-20210901154515337"> 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p></blockquote><h3 id="Ⅲ-Proxy-实例的方法"><a href="#Ⅲ-Proxy-实例的方法" class="headerlink" title="Ⅲ - Proxy 实例的方法"></a>Ⅲ - Proxy 实例的方法</h3><blockquote><p>主要就是对于拦截方法的详细介绍</p></blockquote><h4 id="①-get"><a href="#①-get" class="headerlink" title="① get()"></a>① get()</h4><blockquote><p>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>. </p><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p></blockquote><h5 id="a-举个栗子"><a href="#a-举个栗子" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;努力学习的汪&quot;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="comment">//如果  [propKey(属性名)] 属于 target 对象,则正常返回,否则直接抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) <span class="keyword">return</span>  target[propKey];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;属性名 \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; 不存在.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>) <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">age</span>)  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901165834077.png" alt="image-20210901165834077"> </p><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p></blockquote><h5 id="b-get-方法可以继承"><a href="#b-get-方法可以继承" class="headerlink" title="b) get() 方法可以继承"></a>b) get() 方法可以继承</h5><blockquote><p><code>get</code>方法可以继承。此处用上方用过的一个例子来说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, propKey</span>)=&gt;</span><span class="string">&#x27;不努力学习的单身汪&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">&gt;obj.<span class="property">name</span>=<span class="string">&#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">xxx</span>)  <span class="comment">// 不努力学习的单身汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p><blockquote><ul><li><code>obj</code>对象本身并有 [ name ] 属性,当访问 [ name ] 属性时,因为对象本身有,就不会去其原型上找,所以不会触发拦截</li><li><code>obj</code>对象本身并没有 [ xxx ] 属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</li></ul></blockquote></blockquote><h5 id="c-实现数组读取负数的索引"><a href="#c-实现数组读取负数的索引" class="headerlink" title="c) 实现数组读取负数的索引"></a>c) 实现数组读取负数的索引</h5><blockquote><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> handler = &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">      <span class="comment">//如果小于0,则修改传入的属性名[propKey],做到负数索引能正确读取  </span></span><br><span class="line">     <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> target = [];</span><br><span class="line"> target.<span class="title function_">push</span>(...elements); <span class="comment">//将传入参数解构 push 进 target数组中</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr = <span class="title function_">createArray</span>(<span class="string">&#x27;倒数第三&#x27;</span>, <span class="string">&#x27;倒数第二&#x27;</span>, <span class="string">&#x27;倒数第一&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr[-<span class="number">2</span>],arr[-<span class="number">1</span>]) <span class="comment">//倒数第二 倒数第一</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- 正常数组读取做对比----------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">let</span> arr1 =[<span class="string">&#x27;倒数第三&#x27;</span>, <span class="string">&#x27;倒数第二&#x27;</span>, <span class="string">&#x27;倒数第一&#x27;</span>]</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr1[-<span class="number">2</span>],arr1[-<span class="number">1</span>])  <span class="comment">//undefined undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p></blockquote><h5 id="d-实现属性的链式操作"><a href="#d-实现属性的链式操作" class="headerlink" title="d)  实现属性的链式操作"></a>d)  实现属性的链式操作</h5><blockquote><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//使用var定义函数: 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">double</span> = n =&gt; n * <span class="number">2</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">pow</span>    = n =&gt; n * n;</span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">reverseInt</span> = n =&gt; n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">//定义链式调用函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> pipe = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> funcStack = [];</span><br><span class="line"> <span class="keyword">const</span> oproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">   get : <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">      <span class="comment">//如果传入的属性名是 [get] ,就会从函数栈[funcStack]中循环取出,然后逐层调用</span></span><br><span class="line">     <span class="keyword">if</span> (propKey === <span class="string">&#x27;get&#x27;</span>) </span><br><span class="line">      <span class="comment">//[window]是必须的,因为定义时用的是 [var] ,这几个函数都是挂载在[window]上 </span></span><br><span class="line">      <span class="keyword">return</span> funcStack.<span class="title function_">reduce</span>( <span class="function">(<span class="params">val, fn</span>) =&gt;</span> <span class="variable language_">window</span>[fn](val),value);</span><br><span class="line">     funcStack.<span class="title function_">push</span>(propKey);<span class="comment">//传入的不是 [get] 所以将传入的当前属性名 压入数组中存储</span></span><br><span class="line">     <span class="keyword">return</span> oproxy;<span class="comment">//当不是[get]时,返回proxy给下一层调用</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> oproxy;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//打印调用</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">get</span>) <span class="comment">//3</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">get</span>) <span class="comment">//6</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">get</span>) <span class="comment">//36</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">reverseInt</span>.<span class="property">get</span>)<span class="comment">//63</span></span><br></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。注意点:</p><blockquote><ul><li>使用var定义函数: 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法</li><li>[window]是必须的,因为定义时用的是 [var] ,这几个函数都是挂载在[window]上 </li></ul></blockquote><p>对于某些刚入坑的同学来说可能会比较绕,所以我尽量多的给出了注释,如果还不能理解也多看几遍,以后在学习数据结构与算法的时候就会觉得这里很简单了</p></blockquote><h5 id="e-实现生成各种-DOM-节点的通用函数"><a href="#e-实现生成各种-DOM-节点的通用函数" class="headerlink" title="e) 实现生成各种 DOM 节点的通用函数"></a>e) 实现生成各种 DOM 节点的通用函数</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">   <span class="comment">//声明一个函数,第一个参数为默认为空的对象  第二个参数为其余所有入参</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(propKey); <span class="comment">//根据传入的 [属性名] 创建对应初始 DOM 节点</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(attrs)) &#123;<span class="comment">//取出传入第一个参数对象的属性名</span></span><br><span class="line">       el.<span class="title function_">setAttribute</span>(prop, attrs[prop]); <span class="comment">//如果有属性名,就将其写入标签的属性中</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123; <span class="comment">//循环取出所有入参(除第一个入参外)</span></span><br><span class="line">       <span class="comment">//如果入参类型为字符串,则将其转换为文本节点 </span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;string&#x27;</span>)  child = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">       el.<span class="title function_">appendChild</span>(child); <span class="comment">//将子节点插入el中</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> el;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> els = dom.<span class="title function_">div</span>(&#123;&#125;, <span class="comment">//生成外层的div节点</span></span><br><span class="line"> <span class="string">&#x27;你好!我的名字叫做: &#x27;</span>, <span class="comment">//生成文本节点</span></span><br><span class="line"> dom.<span class="title function_">a</span>(&#123;<span class="attr">href</span>: <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>&#125;, <span class="string">&#x27;努力学习的汪&#x27;</span>),<span class="comment">//生成一个a节点</span></span><br><span class="line"> <span class="string">&#x27;. 我喜欢:&#x27;</span>,</span><br><span class="line"> dom.<span class="title function_">ul</span>(&#123;&#125;,<span class="comment">//生成一个ul节点</span></span><br><span class="line">   dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;划水&#x27;</span>), <span class="comment">//生成li节点</span></span><br><span class="line">   dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;吃瓜&#x27;</span>),</span><br><span class="line">   dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;…其他&#x27;</span>)</span><br><span class="line"> )</span><br><span class="line">&gt;);</span><br><span class="line">&gt;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(els); </span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901184714299.png" alt="image-20210901184714299"> </p></blockquote><h5 id="f-get-的第三个参数"><a href="#f-get-的第三个参数" class="headerlink" title="f) get() 的第三个参数"></a>f) get() 的第三个参数</h5><blockquote><p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">&gt;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> receiver;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;proxy.<span class="property">getReceiver</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以  [ receiver ] 指向<code>proxy</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">&gt;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> receiver;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> d = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">&gt;d.<span class="property">a</span> === d <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，  [ receiver ] 就指向<code>d</code>，代表原始的读操作所在的那个对象。</p><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line"><span class="attr">obj</span>: &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"><span class="attr">handsome</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//configurable:默认为 false 只有设为 true 该属性可能的类型可以被改变，该属性可以从中删除。</span></span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">false</span>  </span><br><span class="line">&#125;,</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line">&gt;<span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="string">&#x27;不想学习&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">obj</span></span><br><span class="line">&gt;<span class="comment">//TypeError: &#x27;get&#x27; on proxy: property &#x27;obj&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;undefined&#x27; but got &#x27;不想学习&#x27;)</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-set"><a href="#②-set" class="headerlink" title="② set()"></a>② set()</h4><blockquote><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p></blockquote><h5 id="a-举个栗子-1"><a href="#a-举个栗子-1" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用 [ Proxy ] 拦截进而保证<code>age</code>的属性值符合要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> validator = &#123;</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123; <span class="comment">//对于设置 [age] 的操作进行拦截</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value))  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;年龄不是一个整数&#x27;</span>);</span><br><span class="line">     <span class="keyword">if</span> (value &gt; <span class="number">200</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;你在修仙吗?&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">   obj[prop] = value;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="number">99</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入年龄99岁:&#x27;</span>,person)</span><br><span class="line">&gt;person.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>  </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入名字:&#x27;</span>,person)</span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="string">&#x27;寿元无限&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902152109632.png" alt="image-20210902152109632"> 上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p></blockquote><h5 id="b-做到防止内部属性被外部读写"><a href="#b-做到防止内部属性被外部读写" class="headerlink" title="b) 做到防止内部属性被外部读写"></a>b) 做到防止内部属性被外部读写</h5><blockquote><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> get (target, key) &#123;</span><br><span class="line">   <span class="title function_">invariant</span>(key, <span class="string">&#x27;get&#x27;</span>); <span class="comment">//将传入的属性名当作参数传给函数</span></span><br><span class="line">   <span class="keyword">return</span> target[key];</span><br><span class="line"> &#125;,</span><br><span class="line"> set (target, key, value) &#123;</span><br><span class="line">   <span class="title function_">invariant</span>(key, <span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">   target[key] = value;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">   <span class="comment">//当传入的 [属性名] 第一位字符是 &#x27;_&#x27; 时抛出错误</span></span><br><span class="line"> <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`对私有属性 [<span class="subst">$&#123;key&#125;</span>] 进行 [<span class="subst">$&#123;action&#125;</span>] 操作是无效的 `</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">_prop</span>  <span class="comment">//报错: 对私有属性 [_prop] 进行 [get] 操作是无效的 </span></span><br><span class="line">&gt;proxy.<span class="property">_prop</span> = <span class="string">&#x27;c&#x27;</span> <span class="comment">//报错 : 对私有属性 [_prop] 进行 [set] 操作是无效的 </span></span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span><span class="comment">//正常的</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>)  <span class="comment">//正常的</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902153407195.png" alt="image-20210902153407195"></p><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛出错误，从而达到禁止读写内部属性的目的。</p></blockquote><h5 id="c-举个关于第四个参数的栗子"><a href="#c-举个关于第四个参数的栗子" class="headerlink" title="c) 举个关于第四个参数的栗子"></a>c) 举个关于第四个参数的栗子</h5><blockquote><p>下面是<code>set</code>方法第四个参数的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;<span class="comment">//拦截写入方法 将本身实例挂载在传入的属性名</span></span><br><span class="line">   obj[prop] = receiver; <span class="comment">//效果:不论写入什么,赋值上去的都是本身实例.主要就是给你做例子用,这种写法开发中不会用到</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy)</span><br><span class="line">&gt;proxy.<span class="property">name</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902154217329.png" alt="image-20210902154217329"> </p><p>上面代码中，<code>set</code>方法的第四个参数  [ receiver ] ，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">   obj[prop] = receiver; <span class="comment">//当触发属性写入操作时,将本身proxy实例写入属性中</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&gt;<span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> testObj = &#123;&#125;</span><br><span class="line">&gt;<span class="comment">//Object.setPrototypeOf() 方法一个指定的对象的原型（即设置，内部[[Prototype]]属性）到另一个对象或  null。</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, proxy); <span class="comment">//将proxy指定为 myObj 的原型对象</span></span><br><span class="line"></span><br><span class="line">&gt;myObj.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;testObj.<span class="property">name</span> = <span class="string">&#x27;对比:努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;绑定原型的:&#x27;</span>,myObj, <span class="string">&#x27; ;没有绑定proxy原型的:&#x27;</span>,testObj)</span><br><span class="line">&gt;myObj.<span class="property">name</span> === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902155654217.png" alt="image-20210902155654217"> 分析一下上面代码:</p><blockquote><ul><li>设置<code>myObj.name</code>属性的值时，<code>myObj</code>并没有 [ name ] 属性，因此引擎会到<code>myObj</code>的原型链去找 [ name ] 属性。</li><li><code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的 [ name ] 属性会触发<code>set</code>方法。</li><li>这时，第四个参数  [ receiver ] 就指向原始赋值行为所在的对象<code>myObj</code>。</li></ul></blockquote></blockquote><h4 id="③-apply"><a href="#③-apply" class="headerlink" title="③ apply()"></a>③ apply()</h4><blockquote><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p><p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> apply (target, ctx, args) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);  <span class="comment">//对于此方法不懂的可以看下方章节 [Reflect]</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h5 id="a-举个栗子-2"><a href="#a-举个栗子-2" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;我是 target&#x27;</span>; &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">apply</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;我是 proxy&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="title function_">p</span>()</span><br><span class="line">&gt;<span class="comment">// &quot;我是 proxy&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时[<code>p()</code>]，就会被<code>apply</code>方法拦截，返回一个字符串。</p></blockquote><h5 id="b-举两个栗子"><a href="#b-举两个栗子" class="headerlink" title="b) 举两个栗子"></a>b) 举两个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> twice = &#123;</span><br><span class="line"> apply (target, ctx, args) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice);</span><br><span class="line">&gt;<span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">&gt;proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">&gt;proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p><p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">apply</span>(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-has"><a href="#④-has" class="headerlink" title="④ has()"></a>④ has()</h4><blockquote><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p><p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p></blockquote><h5 id="a-举个栗子-3"><a href="#a-举个栗子-3" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> has (target, key) &#123;</span><br><span class="line">   <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;隐藏属性&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;正常属性&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p></blockquote><h5 id="b-当原对象不可配置或者禁止扩展时-has-会报错"><a href="#b-当原对象不可配置或者禁止扩展时-has-会报错" class="headerlink" title="b) 当原对象不可配置或者禁止扩展时, has() 会报错"></a>b) 当原对象不可配置或者禁止扩展时, <code>has()</code> 会报错</h5><blockquote><p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj); <span class="comment">//设置为不可配置</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>  &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p><p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p></blockquote><h5 id="c-has-拦截对-for-in-循环不生效"><a href="#c-has-拦截对-for-in-循环不生效" class="headerlink" title="c) has() 拦截对 for...in 循环不生效"></a>c) <code>has()</code> 拦截对 <code>for...in</code> 循环不生效</h5><blockquote><p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>, <span class="attr">score</span>: <span class="number">89</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">score</span>: <span class="number">149</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (prop === <span class="string">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class="number">90</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu1, handler);</span><br><span class="line">&gt;<span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy1</span><br><span class="line">&gt;<span class="comment">//hongjilin 不及格</span></span><br><span class="line">&gt;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy2   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy1[a]); <span class="comment">//hongjilin   // 89</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy2[b]); <span class="comment">//努力学习的汪 // 149</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p></blockquote><h4 id="⑤-construct"><a href="#⑤-construct" class="headerlink" title="⑤ construct()"></a>⑤ construct()</h4><blockquote><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> construct (target, args, newTarget) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h5 id="a-construct-的三个参数"><a href="#a-construct-的三个参数" class="headerlink" title="a) construct() 的三个参数"></a>a) construct() 的三个参数</h5><blockquote><p><code>construct()</code>方法可以接受三个参数。</p><ul><li><code>target</code>：目标对象。</li><li><code>args</code>：构造函数的参数数组。</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;构造函数的参数数组: &#x27;</span>+args,<span class="string">&#x27;构造函数的参数转字符串: &#x27;</span>+args.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>)); <span class="comment">//打印其传入参数</span></span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">2</span> &#125;;  <span class="comment">//将传入参数的第一个参数乘2 返回</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">9</span>,<span class="number">66</span>)</span><br><span class="line">&gt;<span class="comment">//构造函数的参数数组: 9,66 构造函数的参数转字符串: 9, 66</span></span><br><span class="line">&gt;<span class="comment">//&#123;value: 18&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923165830708.png" alt="image-20210923165830708"> </p></blockquote><h5 id="b-construct-方法返回的必须是一个对象，否则会报错"><a href="#b-construct-方法返回的必须是一个对象，否则会报错" class="headerlink" title="b) construct() 方法返回的必须是一个对象，否则会报错"></a>b) construct() 方法返回的必须是一个对象，否则会报错</h5><blockquote><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923170059451.png" alt="image-20210923170059451"> </p></blockquote><h5 id="c-construct-的目标对象必须是函数"><a href="#c-construct-的目标对象必须是函数" class="headerlink" title="c) construct() 的目标对象必须是函数"></a>c) construct() 的目标对象必须是函数</h5><blockquote><p>由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123; <span class="comment">//此处第一个参数设置为对象</span></span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;  <span class="keyword">return</span> &#123;&#125; &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923171049824.png" alt="image-20210923171049824"> </p></blockquote><h5 id="d-方法中的this指向的是handler，而不是实例对象"><a href="#d-方法中的this指向的是handler，而不是实例对象" class="headerlink" title="d) 方法中的this指向的是handler，而不是实例对象"></a>d) 方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象</h5><blockquote><p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this指向: &#x27;</span>,<span class="variable language_">this</span> ); <span class="comment">// this指向:  &#123;construct: ƒ&#125;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this是否指向handler: &quot;</span>,<span class="variable language_">this</span> === handler ); <span class="comment">//this是否指向handler:  true</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, handler);</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>() </span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923171637969.png" alt="image-20210923171637969"> </p></blockquote><h4 id="⑥-deleteProperty"><a href="#⑥-deleteProperty" class="headerlink" title="⑥ deleteProperty()"></a>⑥ deleteProperty()</h4><blockquote><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> deleteProperty (target, key) &#123;</span><br><span class="line">   <span class="title function_">deleteHandler</span>(key, <span class="string">&#x27;delete&#x27;</span>); <span class="comment">//调用自定义抛出异常方法</span></span><br><span class="line">   <span class="keyword">delete</span> target[key]; <span class="comment">//如果上面方法中没有抛出异常才可走到此处,这里进行删除</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//拦截 [ delete ] 时调用的方法,当为私有属性时,抛出异常</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">deleteHandler</span> (key, action) &#123;</span><br><span class="line"> <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无效的动作尝试: <span class="subst">$&#123;action&#125;</span> , 私有属性 &quot;<span class="subst">$&#123;key&#125;</span>&quot; 是不可删除的 `</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> target = &#123; <span class="attr">_name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;<span class="comment">//声明一个对象,有私有属性 [ _name ]</span></span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="keyword">delete</span> proxy.<span class="property">_name</span>  <span class="comment">//进行删除私有属性操作</span></span><br><span class="line">&gt;<span class="comment">//Uncaught Error: 无效的动作尝试: delete , 私有属性 &quot;_name&quot; 是不可删除的 </span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错 </p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923172813525.png" alt="image-20210923172813525"> </p></blockquote><h4 id="⑦-defineProperty"><a href="#⑦-defineProperty" class="headerlink" title="⑦ defineProperty()"></a>⑦ defineProperty()</h4><blockquote><p><code>defineProperty()</code>方法拦截了  [ Object.defineProperty() ] 操作。</p><p><strong>Object.defineProperty() 方法</strong>: 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> defineProperty (target, key, descriptor) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span> ;</span><br><span class="line">&gt;proxy.<span class="property">age</span> = <span class="number">99</span> ;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy)</span><br></pre></td></tr></table></figure><p>实际上,你只要使用了  <strong>defineProperty</strong> 方法拦截了,就会导致添加新属性失败,(返回的 布尔值 其实只是用来提示的,与是否能添加新属性无关)</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923174252622.png" alt="image-20210923174252622"> </p><p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p></blockquote><h4 id="⑧-getOwnPropertyDescriptor"><a href="#⑧-getOwnPropertyDescriptor" class="headerlink" title="⑧ getOwnPropertyDescriptor()"></a>⑧ getOwnPropertyDescriptor()</h4><blockquote><p><code>getOwnPropertyDescriptor()</code>方法拦截  [ Object.getOwnPropertyDescriptor() ] ，返回一个属性描述对象或者<code>undefined</code>。</p><p><strong>Object.getOwnPropertyDescriptor() 方法</strong>: 返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">   <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)  <span class="keyword">return</span>; <span class="comment">//如果为私有属性,则返回undefined</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key); <span class="comment">//不是私有属性就正常返回</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">_name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;sex&#x27;</span>)) <span class="comment">//对象本身就没这个属性,所以返回 undefined</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;_name&#x27;</span>))<span class="comment">//私有属性,被拦截,所以得到    undefined</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;age&#x27;</span>))  <span class="comment">//对象本身有此属性且不是私有属性,正常返回  &#123;value: 18, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923174907011.png" alt="image-20210923174907011"> </p></blockquote><h4 id="⑨-getPrototypeOf"><a href="#⑨-getPrototypeOf" class="headerlink" title="⑨ getPrototypeOf()"></a>⑨ getPrototypeOf()</h4><blockquote><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul></blockquote><h5 id="a-举个栗子-4"><a href="#a-举个栗子-4" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> proto; &#125; <span class="comment">//拦截:不论如何都返回空对象</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p><p>注意，<code>getPrototypeOf()</code>方法的返回值必须是 <strong>对象或者null</strong>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象</p></blockquote><h4 id="⑩-isExtensible"><a href="#⑩-isExtensible" class="headerlink" title="⑩ isExtensible()"></a>⑩ isExtensible()</h4><blockquote><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p><p><strong>Object.isExtensible() 方法:</strong> 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拦截:全部变为可拓展&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line">&gt;<span class="comment">//拦截:全部变为可拓展</span></span><br><span class="line">&gt;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code> 时会打印字符串 [拦截:全部变为可拓展]。</p><p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy) === <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(target)</span><br></pre></td></tr></table></figure></blockquote><h5 id="a-举个栗子-5"><a href="#a-举个栗子-5" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923180130237.png" alt="image-20210923180130237"> </p><p>这边就是本身可拓展,却设置为false, 所以报错.具体使用场景比较特殊,就不列举了</p></blockquote><h4 id="⑩①-ownKeys"><a href="#⑩①-ownKeys" class="headerlink" title="⑩① ownKeys()"></a>⑩① ownKeys()</h4><blockquote><p>[ownKeys()] 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><ul><li> [Object.getOwnPropertyNames()] </li><li><code>Object.getOwnPropertySymbols()</code></li><li> [Object.keys()] </li><li><code>for...in</code>循环</li></ul></blockquote><h5 id="a-举个-拦截-Object-keys-的栗子"><a href="#a-举个-拦截-Object-keys-的栗子" class="headerlink" title="a) 举个 拦截 [Object.keys()]  的栗子"></a>a) 举个 拦截 [Object.keys()]  的栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> target = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">cm</span>: <span class="number">180</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>] &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) <span class="comment">//name</span></span><br></pre></td></tr></table></figure><p>上面代码拦截了对于<code>target</code>对象的 [Object.keys()] 操作，只返回 [ name ] 、[ age ]、[ cm ] 三个属性之中的 [ age ] 属性。</p></blockquote><h5 id="b-举个-拦截-Object-keys-中第一个字符为下划线的属性名-的栗子"><a href="#b-举个-拦截-Object-keys-中第一个字符为下划线的属性名-的栗子" class="headerlink" title="b) 举个 拦截 [Object.keys()] 中第一个字符为下划线的属性名 的栗子"></a>b) 举个 拦截 [Object.keys()] 中第一个字符为下划线的属性名 的栗子</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> target = &#123;</span><br><span class="line"> <span class="attr">_name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">_age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> ownKeys (target) &#123;</span><br><span class="line">    <span class="comment">//筛选不是以下划线开头的属性名(私有属性)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(target[key]);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 只输出 18</span></span><br></pre></td></tr></table></figure><p>[Object.keys()] 本来应是都能输出,但是经过拦截后,开头为下划线的属性被过滤不进行输出,就纸打印了 18</p></blockquote><h5 id="c-使用-Object-keys-方法时，有三类属性会被-ownKeys-方法自动过滤"><a href="#c-使用-Object-keys-方法时，有三类属性会被-ownKeys-方法自动过滤" class="headerlink" title="c) 使用 [Object.keys()] 方法时，有三类属性会被 [ownKeys()] 方法自动过滤"></a>c) 使用 [Object.keys()] 方法时，有三类属性会被 [ownKeys()] 方法自动过滤</h5><blockquote><p>注意，使用 [Object.keys()] 方法时，有三类属性会被 [ownKeys()] 方法自动过滤，不会返回。</p><ul><li>目标对象上不存在的属性</li><li>属性名为 Symbol 值</li><li>不可遍历（<code>enumerable</code>）的属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//1. 定义原对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> target = &#123; </span><br><span class="line"> <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//2. 定义 不可遍历（`enumerable`）的属性 对照组数据</span></span><br><span class="line">&gt;<span class="comment">//Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">//当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。</span></span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;这是测试不可遍历属性&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;test&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;出现在枚举中&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//3. 定义拦截</span></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>), <span class="string">&#x27;key&#x27;</span> , <span class="string">&#x27;test&#x27;</span>]; &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy) <span class="comment">//[&#x27;a&#x27;, &#x27;test&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中， [ownKeys()] 方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924155428555.png" alt="image-20210924155428555"> </p></blockquote><h5 id="d-ownKeys-方法还可以拦截-Object-getOwnPropertyNames"><a href="#d-ownKeys-方法还可以拦截-Object-getOwnPropertyNames" class="headerlink" title="d)  [ownKeys()] 方法还可以拦截 [Object.getOwnPropertyNames()]"></a>d)  [ownKeys()] 方法还可以拦截 [Object.getOwnPropertyNames()]</h5><blockquote><p><strong>Object.getOwnPropertyNames():</strong> 方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="e-for-in循环也受到-ownKeys-方法的拦截。"><a href="#e-for-in循环也受到-ownKeys-方法的拦截。" class="headerlink" title="e) for...in循环也受到 [ownKeys()] 方法的拦截。"></a>e) <code>for...in</code>循环也受到 [ownKeys()] 方法的拦截。</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 没有任何输出</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中， [ownKeys()] 指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p></blockquote><h5 id="f-ownKeys-方法返回的数组成员，只能是字符串或-Symbol-值"><a href="#f-ownKeys-方法返回的数组成员，只能是字符串或-Symbol-值" class="headerlink" title="f)  [ownKeys()] 方法返回的数组成员，只能是字符串或 Symbol 值"></a>f)  [ownKeys()] 方法返回的数组成员，只能是字符串或 Symbol 值</h5><blockquote><p>[ownKeys()] 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 报错</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中， [ownKeys()] 方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924160251672.png" alt="image-20210924160251672"> </p></blockquote><h5 id="g-如果目标对象自身包含不可配置的属性，则该属性必须被-ownKeys-方法返回，否则报错"><a href="#g-如果目标对象自身包含不可配置的属性，则该属性必须被-ownKeys-方法返回，否则报错" class="headerlink" title="g) 如果目标对象自身包含不可配置的属性，则该属性必须被 [ownKeys()] 方法返回，否则报错"></a>g) 如果目标对象自身包含不可配置的属性，则该属性必须被 [ownKeys()] 方法返回，否则报错</h5><blockquote><p>如果目标对象自身包含不可配置的属性，则该属性必须被 [ownKeys()] 方法返回，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">//当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</span></span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;</span><br><span class="line">&gt;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> getName = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>]  &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> getB = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> [<span class="string">&#x27;b&#x27;</span>]  &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//前面说过,也能拦截此方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(getName)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(getB))    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象的<code>name</code>属性是不可配置的，这时 [ownKeys()] 方法返回的数组之中，必须包含<code>name</code>，否则会报错</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924160738101.png" alt="image-20210924160738101"> </p></blockquote><h5 id="h-如果目标对象是不可扩展的（non-extensible），这时-ownKeys-方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错"><a href="#h-如果目标对象是不可扩展的（non-extensible），这时-ownKeys-方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错" class="headerlink" title="h) 如果目标对象是不可扩展的（non-extensible），这时 [ownKeys()] 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错"></a>h) 如果目标对象是不可扩展的（non-extensible），这时 [ownKeys()] 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错</h5><blockquote><p>另外，如果目标对象是不可扩展的（non-extensible），这时 [ownKeys()] 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">name</span>:<span class="string">&quot;努力学习的汪&quot;</span> &#125;;</span><br><span class="line">&gt;<span class="comment">//Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj); <span class="comment">//不可拓展</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>] &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line">&gt;<span class="comment">//报错 Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap returned extra keys but proxy target is non-extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象是不可扩展的，这时 [ownKeys()] 方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924161052315.png" alt="image-20210924161052315"> </p></blockquote><h4 id="⑩②-preventExtensions"><a href="#⑩②-preventExtensions" class="headerlink" title="⑩② preventExtensions()"></a>⑩② preventExtensions()</h4><blockquote><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p><strong>Object.preventExtensions()方法:</strong> 让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p></blockquote><h5 id="a-限制"><a href="#a-限制" class="headerlink" title="a) 限制"></a>a) 限制</h5><blockquote><p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line">&gt;<span class="comment">//VM2320:4 Uncaught TypeError: &#x27;preventExtensions&#x27; on proxy: trap returned truish but the proxy target is extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924161839936.png" alt="image-20210924161839936"> </p></blockquote><h5 id="b-解决"><a href="#b-解决" class="headerlink" title="b) 解决"></a>b) 解决</h5><blockquote><p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;回调&#x27;</span>);</span><br><span class="line">   <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line">&gt;<span class="comment">// &quot;called&quot;</span></span><br><span class="line">&gt;<span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924161941463.png" alt="image-20210924161941463"> </p></blockquote><h4 id="⑩③-setPrototypeOf"><a href="#⑩③-setPrototypeOf" class="headerlink" title="⑩③ setPrototypeOf()"></a>⑩③ setPrototypeOf()</h4><blockquote><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p><p><strong>Object.setPrototypeOf()</strong> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> setPrototypeOf (target, proto) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;禁止更改原型&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, proto);</span><br><span class="line">&gt;<span class="comment">// Error: 禁止更改原型</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p></blockquote><h3 id="Ⅳ-Proxy-revocable-可取消的Proxy实例"><a href="#Ⅳ-Proxy-revocable-可取消的Proxy实例" class="headerlink" title="Ⅳ  - Proxy.revocable() 可取消的Proxy实例"></a>Ⅳ  - Proxy.revocable() 可取消的Proxy实例</h3><blockquote><p>Proxy.revocable()`方法返回一个可取消的 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;proxy.<span class="property">name</span> <span class="comment">// 努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">revoke</span>();</span><br><span class="line">&gt;proxy.<span class="property">name</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是 [ Proxy ] 实例，<code>revoke</code>属性是一个函数，可以取消 [ Proxy ] 实例。上面代码中，当执行<code>revoke</code>函数之后，再访问 [ Proxy ] 实例，就会抛出一个错误。</p><p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924174228432.png" alt="image-20210924174228432"> </p></blockquote><h3 id="Ⅴ-this-问题"><a href="#Ⅴ-this-问题" class="headerlink" title="Ⅴ - this 问题"></a>Ⅴ - this 问题</h3><blockquote><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy); <span class="comment">//打印this执行是否指向 proxy</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;target.<span class="title function_">m</span>() <span class="comment">// false</span></span><br><span class="line">&gt;proxy.<span class="title function_">m</span>()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p></blockquote><h4 id="①-举个栗子-1"><a href="#①-举个栗子-1" class="headerlink" title="① 举个栗子"></a>① 举个栗子</h4><blockquote><p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123; _name.<span class="title function_">set</span>(<span class="variable language_">this</span>, name) &#125;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123; <span class="keyword">return</span> _name.<span class="title function_">get</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> hong = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(hong.<span class="property">name</span> ) <span class="comment">//努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(hong, &#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span> ) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，目标对象<code>hong</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p></blockquote><h4 id="②-无法某些原生对象的内部属性"><a href="#②-无法某些原生对象的内部属性" class="headerlink" title="② 无法某些原生对象的内部属性"></a>② 无法某些原生对象的内部属性</h4><blockquote><p>有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="title function_">getDate</span>();</span><br><span class="line">&gt;<span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-11-11&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (prop === <span class="string">&#x27;getDate&#x27;</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> target.<span class="property">getDate</span>.<span class="title function_">bind</span>(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="title function_">getDate</span>() <span class="comment">//11</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Proxy-拦截函数内部的this，指向的是handler对象。"><a href="#③-Proxy-拦截函数内部的this，指向的是handler对象。" class="headerlink" title="③ Proxy 拦截函数内部的this，指向的是handler对象。"></a>③ Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</h4><blockquote><p>Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;此时this === handler:&quot;</span>,<span class="variable language_">this</span> === handler);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">`拦截get: [<span class="subst">$&#123;key&#125;</span>] 属性`</span> ;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;此时this === handler:&quot;</span>,<span class="variable language_">this</span> === handler);</span><br><span class="line">   target[key] = value;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">`拦截set: [<span class="subst">$&#123;key&#125;</span>] 属性`</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="property">name</span></span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924180414812.png" alt="image-20210924180414812"> </p></blockquote><h3 id="Ⅵ-应用-Web-服务的客户端"><a href="#Ⅵ-应用-Web-服务的客户端" class="headerlink" title="Ⅵ - 应用: Web 服务的客户端"></a>Ⅵ - 应用: Web 服务的客户端</h3><blockquote><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> service = <span class="title function_">createWebService</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>);</span><br><span class="line">&gt;service.<span class="title function_">employees</span>().<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">......</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseUrl</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">&#x27;/&#x27;</span> + propKey);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p></blockquote><h3 id="Ⅶ-Proxy模拟实现VUE数据双向绑定"><a href="#Ⅶ-Proxy模拟实现VUE数据双向绑定" class="headerlink" title="Ⅶ - Proxy模拟实现VUE数据双向绑定"></a>Ⅶ - Proxy模拟实现VUE数据双向绑定</h3><blockquote><p> [ Proxy ] 就像一个代理器,当有人对目标对象进行处理(set、has、get 等等操作)的时候它会首先经过它，这时我们可以使用代码进行处理，此时 [ Proxy ] 相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。</p></blockquote><h4 id="①-Object-defineProperty"><a href="#①-Object-defineProperty" class="headerlink" title="①  [ Object.defineProperty ]"></a>①  [ Object.defineProperty ]</h4><blockquote><p>众所周知，<code>vue</code>使用了 [ Object.defineProperty ] 来做数据劫持，它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">&gt;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get val&#x27;</span>)</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;<span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set val:&#x27;</span> + newVal)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-与-Object-defineProperty-相比，-Proxy-的优势"><a href="#②-与-Object-defineProperty-相比，-Proxy-的优势" class="headerlink" title="② 与 [ Object.defineProperty ] 相比， [ Proxy ] 的优势"></a>② 与 [ Object.defineProperty ] 相比， [ Proxy ] 的优势</h4><blockquote><ol><li><p>数组作为特殊的对象，但Object.defineProperty无法监听数组变化。</p></li><li><p>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p></li><li><p>Proxy 有多达 13 种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。</p></li><li><p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</p></li><li><p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化</p></li></ol></blockquote><h4 id="③-手写双向绑定代码"><a href="#③-手写双向绑定代码" class="headerlink" title="③ 手写双向绑定代码"></a>③ 手写双向绑定代码</h4><blockquote><ol><li>简单实现双向绑定</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input_el&quot;</span> <span class="attr">oninput</span>=<span class="string">&quot;inputHandle(this)&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show_el&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  proxy_bind = <span class="function">(<span class="params">traget</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(traget, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">get</span>(<span class="params">obj, name</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果传入的key并没有,则赋初始值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (!obj[name]) obj[name] = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//根据传入的key进行相应属性返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//拦截的对象,拦截对象的值,传入要修改的值,(第四个参数通常不用,返回整个Proxy对象)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">set</span>(<span class="params">obj, name, val</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        obj[name] = val</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//将输入狂内容即修改的proxy对象属性渲染到页面节点上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  inputHandle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//将输入框的值赋值给proxy对象的value属性上，此处触发proxy的`set（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj_bind.<span class="property">value</span> = e.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>: <span class="string">&quot;2&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">b</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">value</span>: <span class="string">&quot;默认值&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj_bind = <span class="title function_">proxy_bind</span>(obj)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//自闭合，如果前面没有加分号 会导致压缩式合并到前面去就会报错，以防万一加分号，此处触发proxy的`get（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#input_el&quot;</span>).<span class="property">value</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>模拟vue实现完整双向绑定实现</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml">class Watcher &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(vm, key, callback) &#123;</span></span><br><span class="line"><span class="language-xml">    this.vm = vm</span></span><br><span class="line"><span class="language-xml">    this.callback = callback</span></span><br><span class="line"><span class="language-xml">    this.key = key // 被订阅的数据</span></span><br><span class="line"><span class="language-xml">    this.val = this.get() // 维护更新之前的数据</span></span><br><span class="line"><span class="language-xml">    vm.$data = this.createProxy(vm.$data)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  update(newVal) &#123;</span></span><br><span class="line"><span class="language-xml">    this.callback(newVal)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  get() &#123;</span></span><br><span class="line"><span class="language-xml">    const val = this.vm.$data[this.key]</span></span><br><span class="line"><span class="language-xml">    return val</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  createProxy(data) &#123;</span></span><br><span class="line"><span class="language-xml">    let _this = this</span></span><br><span class="line"><span class="language-xml">    let handler = &#123;</span></span><br><span class="line"><span class="language-xml">      get(target, property) &#123;</span></span><br><span class="line"><span class="language-xml">        return Reflect.get(target, property)</span></span><br><span class="line"><span class="language-xml">      &#125;,</span></span><br><span class="line"><span class="language-xml">      set(target, property, value) &#123;</span></span><br><span class="line"><span class="language-xml">        let res = null</span></span><br><span class="line"><span class="language-xml">        if (target[property] != value) &#123;</span></span><br><span class="line"><span class="language-xml">          const isOk = Reflect.set(target, property, value)</span></span><br><span class="line"><span class="language-xml">          if (_this.key === property) &#123;</span></span><br><span class="line"><span class="language-xml">            // 同一层级</span></span><br><span class="line"><span class="language-xml">            res = value</span></span><br><span class="line"><span class="language-xml">          &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">            res = _this.get()</span></span><br><span class="line"><span class="language-xml">            console.log(res)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          _this.callback(res)</span></span><br><span class="line"><span class="language-xml">          return isOk</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    return toDeepProxy(data, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    function toDeepProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">      if (!isPureObject(object)) addSubProxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      return new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function addSubProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">        for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">          if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">            if (!isPureObject(object[prop])) addSubProxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">            object[prop] = new Proxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        object = new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function isPureObject(object) &#123;</span></span><br><span class="line"><span class="language-xml">        if (typeof object !== &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">          return false</span></span><br><span class="line"><span class="language-xml">        &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">          for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">            if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">              return false</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        return true</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">class Vue &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(data) &#123;</span></span><br><span class="line"><span class="language-xml">    // 将所有data最外层属性代理到实例上</span></span><br><span class="line"><span class="language-xml">    this.$data = data</span></span><br><span class="line"><span class="language-xml">    Object.keys(data).forEach(key =&gt; this.$proxy(key))</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $watch(key, cb) &#123;</span></span><br><span class="line"><span class="language-xml">    new Watcher(this, key, cb)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $proxy(key) &#123;</span></span><br><span class="line"><span class="language-xml">    Reflect.defineProperty(this, key, &#123; //此处API不懂的可以看下方下个知识点</span></span><br><span class="line"><span class="language-xml">      configurable: true,</span></span><br><span class="line"><span class="language-xml">      enumerable: true,</span></span><br><span class="line"><span class="language-xml">      get: () =&gt; this.$data[key],</span></span><br><span class="line"><span class="language-xml">      set: val =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        this._data[key] = val</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const p = document.getElementById(&#x27;p&#x27;)</span></span><br><span class="line"><span class="language-xml">const input = document.getElementById(&#x27;input&#x27;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const data = new Vue(&#123; text: &#123; a: &#x27;&#x27; &#125; &#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">input.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span></span><br><span class="line"><span class="language-xml">  data.text.a = e.target.value</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">data.$watch(&#x27;text&#x27;, content =&gt; p.innerHTML = content.a)</span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="14、Reflect"><a href="#14、Reflect" class="headerlink" title="14、Reflect"></a>14、Reflect</h2><blockquote><p>在前方我们在描述 [ Proxy ] 知识点时,我们有用到 <strong>Reflect</strong> 这个API</p><p>实际上你可以认为 <strong>Reflect</strong> 就是将 <strong>Object</strong> 上的部分内部方法移到上面,让我们的JS编码更规范、清晰明了</p></blockquote><h3 id="Ⅰ-概述与总结-1"><a href="#Ⅰ-概述与总结-1" class="headerlink" title="Ⅰ - 概述与总结"></a>Ⅰ - 概述与总结</h3><blockquote><p> <strong>Reflect</strong>  对象与 [ Proxy ] 对象一样，也是 ES6 为了操作对象而提供的新 API。  <strong>Reflect</strong>  对象的设计目的有这样几个。</p><ol><li><p> 将<code>Object</code>对象的一些明显属于语言内部的方法（比如 [ Object.defineProperty ] ），放到  <strong>Reflect</strong>  对象上。现阶段，某些方法同时在<code>Object</code>和  <strong>Reflect</strong>  对象上部署，未来的新方法将只部署在  <strong>Reflect</strong>  对象上。也就是说，从  <strong>Reflect</strong>  对象上可以拿到语言内部的方法</p></li><li><p>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如， [Object.defineProperty(obj, name, desc)] 在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p></li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="comment">// 老写法: 因为会抛出异常错误,所以必须用 try..catch() 去承接错误</span></span><br><span class="line"> &gt;<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"> &gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// 这里承接抛出的错误</span></span><br><span class="line"> &gt;&#125;</span><br><span class="line"></span><br><span class="line"> &gt;<span class="comment">// 新写法</span></span><br><span class="line"> &gt;<span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"> &gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line"> &gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 老写法</span></span><br><span class="line">&gt;<span class="string">&#x27;assign&#x27;</span> <span class="keyword">in</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><ol start="4"><li> <strong>Reflect</strong> 对象的方法与 [Proxy] 对象的方法一一对应，只要是 [Proxy] 对象的方法，就能在 <strong>Reflect</strong> 对象上找到对应的方法。这就让 [Proxy] 对象可以方便地调用对应的 <strong>Reflect</strong> 方法，完成默认行为，作为修改行为的基础。也就是说，不管 [Proxy] 怎么修改默认行为，你总可以在 <strong>Reflect</strong> 上获取默认行为。</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">&gt;<span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, name, value, receiver);</span><br><span class="line">&gt;<span class="keyword">if</span> (success)  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在属性:&#x27;</span> + name + <span class="string">&#x27; 上 &#x27;</span> + target + <span class="string">&#x27; 写入 &#x27;</span> + value);</span><br><span class="line">&gt;<span class="keyword">return</span> success;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个 [Proxy] 对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的 <strong>Reflect</strong> 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p></blockquote><p> 有了 <strong>Reflect</strong> 对象以后，很多操作会更易读。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="①-设计目的"><a href="#①-设计目的" class="headerlink" title="① 设计目的"></a>① 设计目的</h4><blockquote><ul><li>将<code>Object</code>属于<code>语言内部的方法</code>放到  <strong>Reflect</strong>  上</li><li>将某些Object方法报错情况改成返回<code>false</code></li><li>让<code>Object操作</code>变成<code>函数行为</code></li><li> [ Proxy ] 与  <strong>Reflect</strong>  相辅相成</li></ul></blockquote><h4 id="②废弃方法"><a href="#②废弃方法" class="headerlink" title="②废弃方法"></a>②废弃方法</h4><blockquote><ul><li>  [ Object.defineProperty() ]  =&gt;   [ Reflect.defineProperty() ] </li><li>  [ Object.getOwnPropertyDescriptor() ]  =&gt;   [ Reflect.getOwnPropertyDescriptor() ] </li></ul></blockquote><h4 id="③-重点难点"><a href="#③-重点难点" class="headerlink" title="③ 重点难点"></a>③ 重点难点</h4><blockquote><ul><li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li><li> [ Proxy ] 和  <strong>Reflect</strong>  联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code></li></ul></blockquote><h4 id="④-方法"><a href="#④-方法" class="headerlink" title="④ 方法"></a>④ 方法</h4><blockquote><p>下面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p><ul><li>**get()**：返回对象属性</li><li>**set()**：设置对象属性，返回布尔</li><li>**has()**：检查对象属性，返回布尔</li><li>**deleteProperty()**：删除对象属性，返回布尔</li><li>**defineProperty()**：定义对象属性，返回布尔</li><li>**ownKeys()**：遍历对象属性，返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li><li>**getOwnPropertyDescriptor()**：返回对象属性描述，返回对象</li><li>**getPrototypeOf()**：返回对象原型，返回对象</li><li>**setPrototypeOf()**：设置对象原型，返回布尔</li><li>**isExtensible()**：返回对象是否可扩展，返回布尔</li><li>**preventExtensions()**：设置对象不可扩展，返回布尔</li><li>**apply()**：绑定this后执行指定函数</li><li>**construct()**：调用构造函数创建实例</li></ul><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926095039091.png" alt="image-20210926095039091"> </p></blockquote><h4 id="⑤-数据绑定：观察者模式"><a href="#⑤-数据绑定：观察者模式" class="headerlink" title="⑤ 数据绑定：观察者模式"></a>⑤ 数据绑定：观察者模式</h4><blockquote><p>[ Proxy ] 和  <strong>Reflect</strong>  联合使用，前者负责<code>拦截赋值操作</code>，后者负责<code>完成赋值操作</code>, 相辅相成,下面举个栗子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> observerQueue = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; observerQueue.<span class="title function_">add</span>(fn);</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">tgt, key, val, receiver</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(tgt, key, val, receiver);</span><br><span class="line">       observerQueue.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">v</span>());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123; <span class="attr">age</span>: <span class="number">66</span>, <span class="attr">name</span>: <span class="string">&quot;hongjilin&quot;</span> &#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">print</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> is <span class="subst">$&#123;person.age&#125;</span> years old`</span>); </span><br><span class="line">&gt;<span class="title function_">observe</span>(print); <span class="comment">//进行监听</span></span><br><span class="line"></span><br><span class="line">&gt;person.<span class="property">name</span> = <span class="string">&quot;努力学习的汪&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924194108853.png" alt="image-20210924194108853"> </p></blockquote><h3 id="Ⅱ-方法详解"><a href="#Ⅱ-方法详解" class="headerlink" title="Ⅱ - 方法详解"></a>Ⅱ - 方法详解</h3><h4 id="①-Reflect-get-target-name-receiver"><a href="#①-Reflect-get-target-name-receiver" class="headerlink" title="① Reflect.get(target, name, receiver)"></a>① Reflect.get(target, name, receiver)</h4><blockquote><p>[ Reflect.get ] 方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">msg</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;现在&quot;</span> +<span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;name&#x27;</span>))<span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;age&#x27;</span>) ) <span class="comment">// 99</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;msg&#x27;</span>))  <span class="comment">// 努力学习的汪现在99岁</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-如果name属性部署了读取函数（getter），则读取函数的-this-绑定-receiver"><a href="#a-如果name属性部署了读取函数（getter），则读取函数的-this-绑定-receiver" class="headerlink" title="a) 如果name属性部署了读取函数（getter），则读取函数的 this 绑定   [ receiver ]"></a>a) 如果<code>name</code>属性部署了读取函数（getter），则读取函数的 <code>this</code> 绑定   [ receiver ]</h5><blockquote><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定  [ receiver ] </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">msg</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;现在&quot;</span> +<span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> myReceiverObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;msg&#x27;</span>, myReceiverObject) <span class="comment">//&#x27;hongjilin现在18岁&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-如果第一个参数不是对象，-Reflect-get-方法会报错。"><a href="#b-如果第一个参数不是对象，-Reflect-get-方法会报错。" class="headerlink" title="b) 如果第一个参数不是对象， [ Reflect.get ] 方法会报错。"></a>b) 如果第一个参数不是对象， [ Reflect.get ] 方法会报错。</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="literal">false</span>, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Reflect-set-target-name-value-receiver"><a href="#②-Reflect-set-target-name-value-receiver" class="headerlink" title="② Reflect.set(target, name, value, receiver)"></a>② Reflect.set(target, name, value, receiver)</h4><h5 id="a-Reflect-set方法设置target对象的name属性等于value"><a href="#a-Reflect-set方法设置target对象的name属性等于value" class="headerlink" title="a) Reflect.set方法设置target对象的name属性等于value"></a>a) <code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code></h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">setName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> = value;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// hongjilin</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// 努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;setName&#x27;</span>,<span class="string">&#x27;调用setName写入名字&#x27;</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// 调用setName写入名字</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-如果name属性设置了赋值函数，则赋值函数的this绑定-receiver-。"><a href="#b-如果name属性设置了赋值函数，则赋值函数的this绑定-receiver-。" class="headerlink" title="b) 如果name属性设置了赋值函数，则赋值函数的this绑定  [ receiver ] 。"></a>b) 如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定  [ receiver ] 。</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">setName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> = value;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> myReceiverObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;这是 myReceiverObject 的 name&#x27;</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, myReceiverObject);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// hongjilin</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myReceiverObject.<span class="property">name</span>) <span class="comment">// 努力学习的汪  </span></span><br></pre></td></tr></table></figure><p>可以看到 [ <strong>myReceiverObject</strong> ] 被修改了</p></blockquote><h5 id="c-如果-Proxy对象和-Reflect对象联合使用注意事项"><a href="#c-如果-Proxy对象和-Reflect对象联合使用注意事项" class="headerlink" title="c) 如果 Proxy对象和 Reflect对象联合使用注意事项"></a>c) 如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用注意事项</h5><blockquote><p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了  [ receiver ] ，那么<code>Reflect.set</code>会触发  [ Proxy.defineProperty ] 拦截。</p><blockquote><p>知识点回顾:</p><ul><li><strong>handler.defineProperty()</strong> : 用于拦截对对象的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a> 操作</li><li><strong>Object.defineProperty()</strong> : 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拦截 set 操作&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 defineProperty&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">&gt;obj.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 拦截 set 操作</span></span><br><span class="line">&gt;<span class="comment">// 触发 defineProperty</span></span><br></pre></td></tr></table></figure><p>上面代码中， <strong>Proxy.set</strong> 拦截里面使用了<code>Reflect.set</code>，而且传入了  [ receiver ] ，导致触发  [ Proxy.defineProperty ] 拦截。</p><blockquote><ul><li>这是因为 <strong>Proxy.set</strong> 的  [ receiver ] 参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>）</li><li>而<code>Reflect.set</code>一旦传入  [ receiver ] , 就会将属性赋值到  [ receiver ] 上面(即<code>obj</code>), 导致触发<code>defineProperty</code>拦截</li><li>如果<code>Reflect.set</code>没有传入  [ receiver ] ，那么就不会触发<code>defineProperty</code>拦截。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拦截 set 操作&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value) <span class="comment">// 差异:此处没有传入receiver</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 defineProperty&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">&gt;obj.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 拦截 set 操作 --&gt;不会触发 defineProperty</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-如果第一个参数不是对象，-Reflect-get-方法会报错。"><a href="#d-如果第一个参数不是对象，-Reflect-get-方法会报错。" class="headerlink" title="d) 如果第一个参数不是对象， [ Reflect.get ] 方法会报错。"></a>d) 如果第一个参数不是对象， [ Reflect.get ] 方法会报错。</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>,&#123;&#125;) <span class="comment">// 报错 </span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="literal">false</span>, <span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;xx&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="comment">//Uncaught TypeError: Reflect.set called on non-object</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Reflect-has-obj-name"><a href="#③-Reflect-has-obj-name" class="headerlink" title="③ Reflect.has(obj, name)"></a>③ Reflect.has(obj, name)</h4><blockquote><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123; <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> myObject <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">has</span>(myObject, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p></blockquote><h4 id="④-Reflect-deleteProperty-obj-name"><a href="#④-Reflect-deleteProperty-obj-name" class="headerlink" title="④ Reflect.deleteProperty(obj, name)"></a>④ Reflect.deleteProperty(obj, name)</h4><blockquote><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObj = &#123; <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="keyword">delete</span> myObj.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(myObj, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p><p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p></blockquote><h4 id="⑤-Reflect-construct-target-args"><a href="#⑤-Reflect-construct-target-args" class="headerlink" title="⑤ Reflect.construct(target, args)"></a>⑤ Reflect.construct(target, args)</h4><blockquote><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// new 的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Greeting</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Reflect.construct 的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> instance = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Greeting</span>, [<span class="string">&#x27;努力学习的汪&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p></blockquote><h4 id="⑥-Reflect-getPrototypeOf-obj"><a href="#⑥-Reflect-getPrototypeOf-obj" class="headerlink" title="⑥ Reflect.getPrototypeOf(obj)"></a>⑥ Reflect.getPrototypeOf(obj)</h4><blockquote><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObj = <span class="keyword">new</span> <span class="title class_">FancyThing</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑦-Reflect-setPrototypeOf-obj-newProto"><a href="#⑦-Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="⑦ Reflect.setPrototypeOf(obj, newProto)"></a>⑦ Reflect.setPrototypeOf(obj, newProto)</h4><blockquote><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">&gt;myObj.<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-如果无法设置目标对象的原型时"><a href="#a-如果无法设置目标对象的原型时" class="headerlink" title="a) 如果无法设置目标对象的原型时"></a>a) 如果无法设置目标对象的原型时</h5><blockquote><p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;), <span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-第一个参数不是对象时"><a href="#b-第一个参数不是对象时" class="headerlink" title="b) 第一个参数不是对象时"></a>b) 第一个参数不是对象时</h5><blockquote><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-如果第一个参数是undefined或null时"><a href="#c-如果第一个参数是undefined或null时" class="headerlink" title="c) 如果第一个参数是undefined或null时"></a>c) 如果第一个参数是<code>undefined</code>或<code>null</code>时</h5><blockquote><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑧-Reflect-apply-func-thisArg-args"><a href="#⑧-Reflect-apply-func-thisArg-args" class="headerlink" title="⑧ Reflect.apply(func, thisArg, args)"></a>⑧ Reflect.apply(func, thisArg, args)</h4><blockquote><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> youngest = <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> oldest = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(youngest);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> youngest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">min</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> oldest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">max</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> type = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>, youngest, []);</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑨-Reflect-defineProperty-target-propertyKey-attributes"><a href="#⑨-Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="⑨ Reflect.defineProperty(target, propertyKey, attributes)"></a>⑨ Reflect.defineProperty(target, propertyKey, attributes)</h4><blockquote><p> [ Reflect.defineProperty ] 方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用  [ Reflect.defineProperty ] 代替它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">MyDate</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>如果  [ Reflect.defineProperty ] 的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(18, &#39;age&#39;)</code></p></blockquote><h5 id="a-可以与-Proxy-defineProperty-配合使用"><a href="#a-可以与-Proxy-defineProperty-配合使用" class="headerlink" title="a) 可以与  [ Proxy.defineProperty ] 配合使用"></a>a) 可以与  [ Proxy.defineProperty ] 配合使用</h5><blockquote><p>这个方法可以与  [ Proxy.defineProperty ] 配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, prop, descriptor</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor); <span class="comment">//此处拦截后 进行一次打印</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, prop, descriptor);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;<span class="comment">// &#123;value: &#x27;努力学习的汪&#x27;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line">&gt;p.<span class="property">name</span> <span class="comment">// &#x27;努力学习的汪&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，  [ Proxy.defineProperty ] 对属性赋值设置了拦截，然后使用  [ Reflect.defineProperty ] 完成了赋值,这样就能不影响原来赋值效果的同时还能进行拦截处理</p></blockquote><h4 id="⑩-Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#⑩-Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="⑩ Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>⑩ Reflect.getOwnPropertyDescriptor(target, propertyKey)</h4><blockquote><p> [ Reflect.getOwnPropertyDescriptor ] 基本等同于  [ Object.getOwnPropertyDescriptor ] ，用于得到指定属性的描述对象，将来会替代掉后者。</p><blockquote><p><strong>Object.getOwnPropertyDescriptor()方法</strong>: 返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p><p><strong>Object.defineProperty()</strong> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myObject, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="literal">true</span>, <span class="comment">//该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。</span></span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">//当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> theDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> theDescriptor1 = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p> [ Reflect.getOwnPropertyDescriptor ] 和  [ Object.getOwnPropertyDescriptor ] 的一个区别是，如果第一个参数不是对象</p><ul><li>[ Object.getOwnPropertyDescriptor(99, ‘age’) ]不报错，返回<code>undefined</code></li><li>而 [ Reflect.getOwnPropertyDescriptor(99, ‘age’) ] 会抛出错误，表示参数非法。</li></ul></blockquote><h4 id="⑩①-Reflect-isExtensible-target"><a href="#⑩①-Reflect-isExtensible-target" class="headerlink" title="⑩① Reflect.isExtensible (target)"></a>⑩① Reflect.isExtensible (target)</h4><blockquote><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑩②-Reflect-preventExtensions-target"><a href="#⑩②-Reflect-preventExtensions-target" class="headerlink" title="⑩② Reflect.preventExtensions(target)"></a>⑩② Reflect.preventExtensions(target)</h4><blockquote><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 环境</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 环境</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑩③-Reflect-ownKeys-target"><a href="#⑩③-Reflect-ownKeys-target" class="headerlink" title="⑩③ Reflect.ownKeys (target"></a>⑩③ Reflect.ownKeys (target</h4><blockquote><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> myObject = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;baz&#x27;</span>)]: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bing&#x27;</span>)]: <span class="number">4</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(myObject)</span><br><span class="line">&gt;<span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(myObject)</span><br><span class="line">&gt;<span class="comment">//[Symbol(baz), Symbol(bing)]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(myObject)</span><br><span class="line">&gt;<span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, Symbol(baz), Symbol(bing)]</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p></blockquote><h3 id="Ⅲ-应用-配合-Proxy-实现观察者模式"><a href="#Ⅲ-应用-配合-Proxy-实现观察者模式" class="headerlink" title="Ⅲ - 应用: 配合 Proxy 实现观察者模式"></a>Ⅲ - 应用: 配合 Proxy 实现观察者模式</h3><blockquote><p>实际上与上方[ Proxy ] 模拟实现Vue数据双向绑定一样,这里按照 阮一峰ES6 教程中的示例代码  实现</p><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> 今年 <span class="subst">$&#123;person.age&#125;</span> 岁了`</span>) &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">observe</span>(print); <span class="comment">//监听  这个方法定义实现放在下方</span></span><br><span class="line">&gt;person.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p><p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line"> queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926165622747.png" alt="image-20210926165622747"> </p></blockquote><h2 id="15、Iterator-和-for…of-循环"><a href="#15、Iterator-和-for…of-循环" class="headerlink" title="15、Iterator 和 for…of 循环"></a>15、Iterator 和 for…of 循环</h2><blockquote><p>这个知识点就属于,貌似你不学也不影响基本编程开发的类型,但当你编程开发了一段时间后这东西似乎又无处不在地存在于我们 JavaScript 的每个部分</p><p>起码在我初学前端时这部分是直接跳过不学的,也是到现在才回头来补充学习,</p></blockquote><h3 id="Ⅰ-概述与总结-2"><a href="#Ⅰ-概述与总结-2" class="headerlink" title="Ⅰ- 概述与总结"></a>Ⅰ- 概述与总结</h3><blockquote><ol><li>定义：为各种不同的数据结构提供统一的访问机制</li><li>原理：创建一个指针指向首个成员，按照次序使用<code>next()</code>指向下一个成员，直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</li><li>作用</li></ol><ul><li>为各种数据结构提供一个统一的简便的访问接口</li><li>使得数据结构成员能够按某种次序排列</li><li>ES6创造了新的遍历命令 [ for-of ] ，<code>Iterator接口</code>主要供 [ for-of ] 消费</li></ul><ol start="4"><li>形式： [ for-of ] (自动去寻找Iterator接口)</li><li>数据结构</li></ol><ul><li>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li><li>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li></ul><ol start="6"><li>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</li><li>遍历器对象</li></ol><ul><li>**next()**：下一步操作，返回<code>&#123; done, value &#125;</code>(必须部署)</li><li>**return()**： [ for-of ] 提前退出调用，返回<code>&#123; done: true &#125;</code></li><li>**throw()**：不使用，配合<code>Generator函数</code>使用</li></ul><blockquote><h6 id="For…Of-循环"><a href="#For…Of-循环" class="headerlink" title="For…Of 循环"></a>For…Of 循环</h6></blockquote><ol><li><p>定义：调用<code>Iterator接口</code>产生遍历器对象( [ for-of ] 内部调用数据结构的<code>Symbol.iterator()</code>)</p></li><li><p>遍历字符串： [ for-in ] 获取<code>索引</code>， [ for-of ] 获取<code>值</code>(可识别32位UTF-16字符)</p></li><li><p>遍历数组： [ for-in ] 获取<code>索引</code>， [ for-of ] 获取<code>值</code></p></li><li><p>遍历对象： [ for-in ] 获取<code>键</code>， [ for-of ] 需自行部署</p></li><li><p>遍历Set： [ for-of ] 获取<code>值</code> =&gt; <code>for (const v of set)</code></p></li><li><p>遍历Map： [ for-of ] 获取<code>键值对</code> =&gt;  <code>for (const [k, v] of map)</code></p></li><li><p>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</p></li><li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p></li></ol><blockquote><ul><li>**keys()**：返回遍历器对象，遍历所有的键</li><li>**values()**：返回遍历器对象，遍历所有的值</li><li>**entries()**：返回遍历器对象，遍历所有的键值对</li></ul></blockquote><ol start="9"><li>与 [ for-in ] 区别</li></ol><blockquote><ul><li>有着同 [ for-in ] 一样的简洁语法，但没有 [ for-in ] 那些缺点、</li><li>不同于<code>forEach()</code>，它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li><li>提供遍历所有数据结构的统一操作接口</li></ul></blockquote><blockquote><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6></blockquote><ol><li>改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li><li>解构赋值：对Set进行解构</li><li>扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li><li>yield*：<code>yield*</code>后跟一个可遍历的数据结构，会调用其遍历器接口</li><li>接受数组作为参数的函数： [ for-of ] 、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li></ol></blockquote><h3 id="Ⅱ-Iterator（遍历器）的概念"><a href="#Ⅱ-Iterator（遍历器）的概念" class="headerlink" title="Ⅱ - Iterator（遍历器）的概念"></a>Ⅱ - Iterator（遍历器）的概念</h3><blockquote><h5 id="提出原因"><a href="#提出原因" class="headerlink" title="提出原因:"></a>提出原因:</h5><ul><li>JavaScript 原有的表示“集合”的数据结构，主要是数组(<code>Array</code>)和对象(<code>Object</code>)</li><li>ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。</li><li>这样就需要一种统一的接口机制，来处理所有不同的数据结构。</li></ul><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p></blockquote><h4 id="①-Iterator-的作用有三个"><a href="#①-Iterator-的作用有三个" class="headerlink" title="① Iterator 的作用有三个"></a>① Iterator 的作用有三个</h4><blockquote><ul><li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费</li></ul></blockquote><h4 id="②-Iterator-的遍历过程"><a href="#②-Iterator-的遍历过程" class="headerlink" title="② Iterator 的遍历过程"></a>② Iterator 的遍历过程</h4><blockquote><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p></blockquote><h4 id="③-模拟next方法返回值的🌰"><a href="#③-模拟next方法返回值的🌰" class="headerlink" title="③ 模拟next方法返回值的🌰"></a>③ 模拟<code>next</code>方法返回值的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> nextIndex = <span class="number">0</span>; <span class="comment">//定义初始下标为 0</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ? </span><br><span class="line">       &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :<span class="comment">//当 当前下标小于数组总长度时,返回当前下标数据</span></span><br><span class="line">       &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;  <span class="comment">//当 当前下标大于等于数组总长度时,返回 undefined</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hongjilin&#x27;</span>]);</span><br><span class="line">&gt;it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;努力学习的汪&quot;, done: false &#125;</span></span><br><span class="line">&gt;it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;hongjilin&quot;, done: false &#125;</span></span><br><span class="line">&gt;it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;  --&gt;可以根据 done 设置是否能继续遍历</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;努力学习的汪&#39;, &#39;hongjilin&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><ul><li>指针对象的<code>next</code>方法，用来移动指针。</li><li>开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>&#39;努力学习的汪&#39;</code>；第二次调用，指向<code>hongjilin</code>。</li><li><code>next</code>方法返回一个对象，表示当前数据成员的信息。</li><li>这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</li></ul><blockquote><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p></blockquote><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">       &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">       &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。</p></blockquote><h4 id="④-无限运行的遍历器对象的🌰"><a href="#④-无限运行的遍历器对象的🌰" class="headerlink" title="④ 无限运行的遍历器对象的🌰"></a>④ 无限运行的遍历器对象的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">idMaker</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;&#125; <span class="comment">//不论如何都返回 done:false</span></span><br><span class="line">&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> it = <span class="title function_">idMaker</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> values=[]</span><br><span class="line"><span class="comment">//这边给了限制,只循环一百次,一百次都会打印出来</span></span><br><span class="line">&gt;<span class="comment">// 可以预见如果遍历器没法设置条件done为true,使用 for...of 就会无限遍历</span></span><br><span class="line">&gt;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">values.<span class="title function_">push</span>(it.<span class="title function_">next</span>().<span class="property">value</span> )</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;values  <span class="comment">//[1, 2, 3 ... 98, 99]</span></span><br></pre></td></tr></table></figure><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说是遍历器对象自己描述了一个数据结构出来(无法控制)。</p></blockquote><h4 id="⑤-遍历器接口-Iterable-、指针对象-Iterator-和next方法返回值的规格以TS写法描述"><a href="#⑤-遍历器接口-Iterable-、指针对象-Iterator-和next方法返回值的规格以TS写法描述" class="headerlink" title="⑤ 遍历器接口(Iterable)、指针对象(Iterator)和next方法返回值的规格以TS写法描述"></a>⑤ 遍历器接口(Iterable)、指针对象(Iterator)和<code>next</code>方法返回值的规格以TS写法描述</h4><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">Iterable</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() : <span class="title class_">Iterator</span>,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"> <span class="title function_">next</span>(value?: <span class="built_in">any</span>) : <span class="title class_">IterationResult</span>,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IterationResult</span> &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="built_in">any</span>,</span><br><span class="line"> <span class="attr">done</span>: <span class="built_in">boolean</span>,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-默认-Iterator-接口"><a href="#Ⅲ-默认-Iterator-接口" class="headerlink" title="Ⅲ - 默认 Iterator 接口"></a>Ⅲ - 默认 Iterator 接口</h3><blockquote><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p><blockquote><h6 id="一种数据结构只要部署了-Iterator-接口，我们就称这种数据结构是“可遍历的”（iterable）"><a href="#一种数据结构只要部署了-Iterator-接口，我们就称这种数据结构是“可遍历的”（iterable）" class="headerlink" title="一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）"></a><strong>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）</strong></h6></blockquote><ul><li>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。</li></ul></blockquote><h4 id="①-Symbol-iterator-设置时需要写在中括号中"><a href="#①-Symbol-iterator-设置时需要写在中括号中" class="headerlink" title="① Symbol.iterator 设置时需要写在中括号中"></a>① Symbol.iterator 设置时需要写在中括号中</h4><blockquote><ol><li><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，<strong>所以要放在方括号内</strong>(在前面 <strong>Symbol、Map、Set</strong> 章节中的示例也是如此使用)</li><li><strong>Symbol.iterator</strong>: 指向一个默认遍历器方法，当实例对象执行 [ for-of ] 时会调用指定的默认遍历器</li><li>我们知道,在给对象设置属性名时,如果属性名是变量,那么我们用 <strong>[ ]</strong> 进行包裹</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] : <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// Symbol.iterator 本身是一个表达式,所以需要写在中括号中</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,  <span class="attr">done</span>: <span class="literal">true</span>&#125;  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p></blockquote><h4 id="②-怎样算是部署了遍历器接口"><a href="#②-怎样算是部署了遍历器接口" class="headerlink" title="② 怎样算是部署了遍历器接口 ?"></a>② 怎样算是部署了遍历器接口 ?</h4><blockquote><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p></blockquote><h4 id="③-原生具备-Iterator-接口（对象里面的一个属性）的数据结构如下"><a href="#③-原生具备-Iterator-接口（对象里面的一个属性）的数据结构如下" class="headerlink" title="③ 原生具备 Iterator 接口（对象里面的一个属性）的数据结构如下:"></a>③ 原生具备 Iterator 接口（对象里面的一个属性）的数据结构如下:</h4><blockquote><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历</p></blockquote><h4 id="④-举个数组的Symbol-iterator属性的🌰"><a href="#④-举个数组的Symbol-iterator属性的🌰" class="headerlink" title="④ 举个数组的Symbol.iterator属性的🌰"></a>④ 举个数组的<code>Symbol.iterator</code>属性的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;不想学习了我头秃了&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;努力学习的汪&#x27;, done: false &#125;</span></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;hongjilin&#x27;, done: false &#125;</span></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;不想学习了我头秃了&#x27;, done: false &#125;</span></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p></blockquote><h4 id="⑥-对象为何没有默认部署-Iterator-接口"><a href="#⑥-对象为何没有默认部署-Iterator-接口" class="headerlink" title="⑥ 对象为何没有默认部署 Iterator 接口 ?"></a>⑥ 对象为何没有默认部署 Iterator 接口 ?</h4><blockquote><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = start; <span class="comment">//定义一个初始开始值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">stop</span> = stop;  <span class="comment">//定义结束点</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//Symbol.iterator 绑定自身实例对象,这样 [next()] 也相当于是函数体内声明的,看不懂的回顾JS进阶基础部分</span></span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125; </span><br><span class="line">  <span class="comment">//定义遍历器方法</span></span><br><span class="line"><span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">value</span>; <span class="comment">//声明一个临时变量储存当前实例的 value</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">value</span>++; <span class="comment">//注意 这里的 [this.value] 是 RangeIterator 实例的 value, 此处给实例的value进行+1</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;; <span class="comment">//当 当前 value 小于 stop 时,返回当前 value(未加1时的)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;<span class="comment">//当 当前 value 大等于 stop 时,返回 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//声明一个生成 RangeIterator 实例的方法</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">range</span> = (<span class="params">start, stop</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123; <span class="comment">//如果遍历器没法设置条件 done为true,就会无限循环</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象</p></blockquote><h4 id="⑦-通过遍历器实现指针结构的🌰"><a href="#⑦-通过遍历器实现指针结构的🌰" class="headerlink" title="⑦ 通过遍历器实现指针结构的🌰"></a>⑦ 通过遍历器实现指针结构的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//在 Obj 的原型上加 [Symbol.iterator] 属性</span></span><br><span class="line">&gt;<span class="title class_">Obj</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> iterator = &#123; <span class="attr">next</span>: next &#125;; <span class="comment">//设置迭代器</span></span><br><span class="line"><span class="keyword">let</span> current = <span class="variable language_">this</span>;  <span class="comment">//用 current 储存当前 this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = current.<span class="property">value</span>; <span class="comment">//将当前实例的 value 储存到 新的value变量 中</span></span><br><span class="line">current = current.<span class="property">next</span>;      <span class="comment">//将 current 储存的this 替换为下次迭代next出来的 this</span></span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;; <span class="comment">//返回储存的 value  同时设置为可以继续遍历</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; <span class="comment">//如果 current 储存的 当前this 找不到(undefined),停止遍历</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> iterator;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> one = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;hongjilin&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> two = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> three = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;新生代农民&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;one.<span class="property">next</span> = two; <span class="comment">// 将 two 赋值给 one的next属性</span></span><br><span class="line">&gt;two.<span class="property">next</span> = three; <span class="comment">// 将 three 赋值给 two的next属性</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><blockquote><ul><li>**for…of **代码运行的第一步时运行 one ,这时候它在本身实例上找不到,就回到自身的Prototype中找,找到了 <strong>next()</strong>,并执行,得到结果 <strong>{ done: false, value: ‘hongjilin’ }</strong></li><li>当调用 <strong>one.next</strong> 时 (<strong>for…of会自动往深处一直调用,直到done为true</strong>) ,相当于调用运行了 two ,然后参照第一步,它找到了 two 的prototype中的 <strong>next</strong>,得到 <strong>{ done: false, value: ‘努力学习的汪’ }</strong></li><li>当调用 <strong>one.next.next</strong> 时(每次循环加一层) ,相当于调用  运行了 <strong>three</strong> ,得到了  <strong>{ done: false, value: ‘新生代农名工’ }</strong></li></ul></blockquote><h6 id="截图示例"><a href="#截图示例" class="headerlink" title="截图示例"></a>截图示例</h6><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210929120021560.png" alt="image-20210929120021560"> </p></blockquote><h4 id="⑧-为对象添加-Iterator-接口的🌰"><a href="#⑧-为对象添加-Iterator-接口的🌰" class="headerlink" title="⑧ 为对象添加 Iterator 接口的🌰"></a>⑧ 为对象添加 Iterator 接口的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="attr">data</span>: [ <span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span> ],</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">   <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;<span class="comment">//当index 小于 data 的长度时,返回当前下标数据</span></span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">           <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">         &#125;;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑨-类似数组的对象部署-Iterator-接口"><a href="#⑨-类似数组的对象部署-Iterator-接口" class="headerlink" title="⑨ 类似数组的对象部署 Iterator 接口"></a>⑨ 类似数组的对象部署 Iterator 接口</h4><blockquote><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 <strong>Iterator</strong> 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line">&gt;<span class="comment">// 或者</span></span><br><span class="line">&gt;<span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"></span><br><span class="line">&gt;[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure><p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p></blockquote><h5 id="a-类似数组的对象调用数组的Symbol-iterator方法的🌰"><a href="#a-类似数组的对象调用数组的Symbol-iterator方法的🌰" class="headerlink" title="a) 类似数组的对象调用数组的Symbol.iterator方法的🌰"></a>a) 类似数组的对象调用数组的<code>Symbol.iterator</code>方法的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> iterable = &#123;</span><br><span class="line"> <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"> <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> iterable)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)<span class="comment">//0,1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-普通对象部署数组的Symbol-iterator方法，并无效果"><a href="#b-普通对象部署数组的Symbol-iterator方法，并无效果" class="headerlink" title="b) 普通对象部署数组的Symbol.iterator方法，并无效果"></a>b) 普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> iterable = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"> <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-如果Symbol-iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数），解释引擎将会报错"><a href="#c-如果Symbol-iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数），解释引擎将会报错" class="headerlink" title="c) 如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数），解释引擎将会报错"></a>c) 如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数），解释引擎将会报错</h5><blockquote><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="function">() =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;[...obj] <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p></blockquote><h5 id="d-有了遍历器接口-也可以使用while循环遍历"><a href="#d-有了遍历器接口-也可以使用while循环遍历" class="headerlink" title="d) 有了遍历器接口,也可以使用while循环遍历"></a>d) 有了遍历器接口,也可以使用<code>while</code>循环遍历</h5><blockquote><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> $iterator = <span class="variable constant_">ITERABLE</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">&gt;<span class="keyword">let</span> $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line">&gt;<span class="keyword">while</span> (!$result.<span class="property">done</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = $result.<span class="property">value</span>;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> $result = $iterator.<span class="title function_">next</span>(); <span class="comment">//指向下一个</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p></blockquote><h3 id="Ⅳ-调用-Iterator-接口的场合"><a href="#Ⅳ-调用-Iterator-接口的场合" class="headerlink" title="Ⅳ - 调用 Iterator 接口的场合"></a>Ⅳ - 调用 Iterator 接口的场合</h3><blockquote><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p></blockquote><h4 id="①-解构赋值"><a href="#①-解构赋值" class="headerlink" title="①  解构赋值"></a>①  解构赋值</h4><blockquote><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;hongjilin&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;新生代农民工&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [x,y] = set;</span><br><span class="line">&gt;<span class="comment">// x=&#x27;hongjilin&#x27;; y=&#x27;努力学习的汪&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line">&gt;<span class="comment">// first=&#x27;hongjilin&#x27;; rest=[&#x27;努力学习的汪&#x27;,&#x27;新生代农民工&#x27;];</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-扩展运算符"><a href="#②-扩展运算符" class="headerlink" title="② 扩展运算符"></a>② 扩展运算符</h4><blockquote><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">const</span> str = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;[...str] <span class="comment">//  [&#x27;努&#x27;, &#x27;力&#x27;, &#x27;学&#x27;, &#x27;习&#x27;, &#x27;的&#x27;, &#x27;汪&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hongjilin&#x27;</span>];</span><br><span class="line">&gt;[<span class="string">&#x27;我是谁?&#x27;</span>, ...arr, <span class="string">&#x27;新生代农民工&#x27;</span>]</span><br><span class="line">&gt;<span class="comment">// [&#x27;我是谁?&#x27;, &#x27;努力学习的汪&#x27;, &#x27;hongjilin&#x27;, &#x27;新生代农民工&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-yield"><a href="#③-yield" class="headerlink" title="③ yield*"></a>③ yield*</h4><blockquote><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> generator = <span class="keyword">function</span>* () &#123; <span class="comment">//注意 此处有个 * 号</span></span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">yield</span>* [<span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">true</span>]; <span class="comment">//注意 此处有个 * 号</span></span><br><span class="line"> <span class="keyword">yield</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">yield</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;hongjilin&#x27;</span>&#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: &#x27;努力学习的汪&#x27;, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: true, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: null, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: &#123;name:&#x27;hongjilin&#x27;&#125;, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: true&#125;  --&gt; 到此处done为true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-其他场合"><a href="#④-其他场合" class="headerlink" title="④ 其他场合"></a>④ 其他场合</h4><blockquote><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些🌰</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;hong&#39;,1],[&#39;汪&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul></blockquote><h3 id="Ⅴ-字符串的-Iterator-接口"><a href="#Ⅴ-字符串的-Iterator-接口" class="headerlink" title="Ⅴ - 字符串的 Iterator 接口"></a>Ⅴ - 字符串的 Iterator 接口</h3><blockquote><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someString = <span class="string">&quot;农民工&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">typeof</span> someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]  <span class="comment">// &quot;function&quot;</span></span><br><span class="line">&gt;<span class="keyword">const</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); <span class="comment">//将 someString 字符串的遍历器方法赋值给 iterator</span></span><br><span class="line"></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;农&quot;, done: false &#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;民&quot;, done: false &#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;工&quot;, done: false &#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍`历器上可以调用 next 方法，实现对于字符串的遍历。</p><blockquote><h6 id="可以覆盖原生的Symbol-iterator方法，达到修改遍历器行为的目的。"><a href="#可以覆盖原生的Symbol-iterator方法，达到修改遍历器行为的目的。" class="headerlink" title="可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。"></a>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</h6></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br><span class="line">&gt;[...str] <span class="comment">//  [&#x27;努&#x27;, &#x27;力&#x27;, &#x27;学&#x27;, &#x27;习&#x27;, &#x27;的&#x27;, &#x27;汪&#x27;]</span></span><br><span class="line">&gt;<span class="comment">//修改遍历器行为</span></span><br><span class="line">&gt;str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_first</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">_first</span> = <span class="literal">false</span>; <span class="comment">//进来后直接将 _first 赋值为false ,这样这个代码块只会进来一次</span></span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&quot;新生代农民工&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; <span class="comment">//当 [_first] 为false 时,直接停止遍历</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">_first</span>: <span class="literal">true</span> <span class="comment">//初次声明,未进入next时,默认值给true,这样确保</span></span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;[...str] <span class="comment">// [&quot;新生代农民工&quot;]  --&gt;可以看到,调用到其遍历器时,行为已经被修改了</span></span><br><span class="line">&gt;str <span class="comment">// String &#123;&#x27;努力学习的汪&#x27;, Symbol(Symbol.iterator): ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>新生代农民工</code>，而字符串本身还是<code>努力学习的汪</code>。</p></blockquote><h3 id="Ⅵ-Iterator-接口与-Generator-函数"><a href="#Ⅵ-Iterator-接口与-Generator-函数" class="headerlink" title="Ⅵ - Iterator 接口与 Generator 函数"></a>Ⅵ - Iterator 接口与 Generator 函数</h3><blockquote><p><code>Symbol.iterator()</code>方法的最简单实现，还是使用下一节要介绍的 Generator 函数,此处先列出来,具体详情可以看下方详解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> myIterable = &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>* () &#123; <span class="comment">//此处有个 * 号</span></span><br><span class="line">   <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">&#x27;新生代农民工&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// &quot;努力学习的汪&quot;</span></span><br><span class="line">&gt;<span class="comment">// &quot;新生代农民工&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p></blockquote><h3 id="Ⅶ-遍历器对象的-return-，throw"><a href="#Ⅶ-遍历器对象的-return-，throw" class="headerlink" title="Ⅶ - 遍历器对象的 return()，throw()"></a>Ⅶ - 遍历器对象的 return()，throw()</h3><blockquote><p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p></blockquote><h4 id="①-return-方法的使用场合"><a href="#①-return-方法的使用场合" class="headerlink" title="① return()方法的使用场合"></a>① <code>return()</code>方法的使用场合</h4><blockquote><p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">readLinesSync</span>(<span class="params">file</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="keyword">return</span>() &#123; <span class="comment">//清理或释放资源</span></span><br><span class="line">         file.<span class="title function_">close</span>();</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。</p></blockquote><h4 id="②-会触发执行return-方法的两种情况"><a href="#②-会触发执行return-方法的两种情况" class="headerlink" title="② 会触发执行return()方法的两种情况"></a>② 会触发执行<code>return()</code>方法的两种情况</h4><blockquote><p>下面的两种情况，都会触发执行<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 情况一</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况二</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中:</p><ul><li>情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；</li><li>情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</li><li>注意，<code>return()</code>方法必须返回一个对象，这是 Generator 语法决定的。</li></ul><p><code>throw()</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</p></blockquote><h3 id="Ⅷ-for…of-循环"><a href="#Ⅷ-for…of-循环" class="headerlink" title="Ⅷ - for…of 循环"></a>Ⅷ - for…of 循环</h3><blockquote><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p></blockquote><h4 id="①-数组"><a href="#①-数组" class="headerlink" title="① 数组"></a>① 数组</h4><blockquote><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// hongjilin 努力学习的汪 新生代农民工</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//实际上相当于将arr的迭代器行为复制到obj中,迭代的还是之前那个数组</span></span><br><span class="line">&gt;obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>].<span class="title function_">bind</span>(arr); </span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// hongjilin 努力学习的汪 新生代农民工</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p></blockquote><h5 id="a-for-of循环可以代替数组实例的forEach方法"><a href="#a-for-of循环可以代替数组实例的forEach方法" class="headerlink" title="a) for...of循环可以代替数组实例的forEach方法"></a>a) <code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法</h5><blockquote><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// hongjilin 努力学习的汪 新生代农民工</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(index);   <span class="comment">// 0 1 2</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-与-for-in循环的区别1"><a href="#b-与-for-in循环的区别1" class="headerlink" title="b) 与 for...in循环的区别1:"></a>b) 与 <code>for...in</code>循环的区别1:</h5><blockquote><p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法 (详见前面数组拓展部分)</p></blockquote><h5 id="c-与-for-in循环的区别2"><a href="#c-与-for-in循环的区别2" class="headerlink" title="c) 与 for...in循环的区别2:"></a>c) 与 <code>for...in</code>循环的区别2:</h5><blockquote><p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;item1&#x27;</span>, <span class="string">&#x27;item2&#x27;</span>, <span class="string">&#x27;item3&#x27;</span>];</span><br><span class="line">&gt;arr.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;name&quot;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>name</code>属性。</p></blockquote><h4 id="②-Set-和-Map-结构"><a href="#②-Set-和-Map-结构" class="headerlink" title="② Set 和 Map 结构"></a>② Set 和 Map 结构</h4><blockquote><p>Set 和 Map 结构也原生具有 <strong>Iterator</strong> 接口，可以直接使用<code>for...of</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>,<span class="string">&#x27;新生代农民工&#x27;</span>]);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// hongjilin</span></span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="comment">// 新生代农民工</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> es6 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;es6.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;es6.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">99</span>);</span><br><span class="line">&gt;es6.<span class="title function_">set</span>(<span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;新生代农民工&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// name: 努力学习的汪</span></span><br><span class="line">&gt;<span class="comment">// age: 99</span></span><br><span class="line">&gt;<span class="comment">// occupation: 新生代农民工</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;新生代农民工&quot;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [&#x27;name&#x27;, &#x27;努力学习的汪&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// [&#x27;occupation&#x27;, &#x27;新生代农民工&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// name: 努力学习的汪</span></span><br><span class="line">&gt;<span class="comment">// occupation: 新生代农民工</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-计算生成的数据结构"><a href="#③-计算生成的数据结构" class="headerlink" title="③ 计算生成的数据结构"></a>③ 计算生成的数据结构</h4><blockquote><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-类似数组的对象"><a href="#④-类似数组的对象" class="headerlink" title="④ 类似数组的对象"></a>④ 类似数组的对象</h4><blockquote><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 字符串</span></span><br><span class="line">&gt;<span class="keyword">let</span> str = <span class="string">&quot;努力学习的汪&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">//  &#x27;努&#x27;, &#x27;力&#x27;, &#x27;学&#x27;, &#x27;习&#x27;, &#x27;的&#x27;, &#x27;汪&#x27;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// DOM NodeList对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> paras = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// arguments对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">printArgs</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// &#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="comment">// &#x27;新生代农民工&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-会正确识别-32-位-UTF-16-字符"><a href="#a-会正确识别-32-位-UTF-16-字符" class="headerlink" title="a) 会正确识别 32 位 UTF-16 字符"></a>a) 会正确识别 32 位 UTF-16 字符</h5><blockquote><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;a\uD83D\uDC0A&#x27;</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&gt;<span class="comment">// &#x27;\uD83D\uDC0A&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-使用Array-from方法将其转为数组"><a href="#b-使用Array-from方法将其转为数组" class="headerlink" title="b) 使用Array.from方法将其转为数组"></a>b) 使用<code>Array.from</code>方法将其转为数组</h5><blockquote><p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;新生代农民工&#x27;</span> ,<span class="number">2</span>:<span class="string">&#x27;hongjilin&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 正确</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// undefined --&gt;找不到下标为0 的,所以打印undefined </span></span><br><span class="line">&gt;<span class="comment">// 新生代农民工</span></span><br><span class="line">&gt;<span class="comment">// hongjilin</span></span><br><span class="line">&gt;<span class="comment">// undefined  --&gt;实际上是根据length确定类似数组的长度,所以找不到下标为3的</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-对象"><a href="#⑤-对象" class="headerlink" title="⑤ 对象"></a>⑤ 对象</h4><blockquote><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> es6 = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;努力学习的汪&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">occupation</span>: <span class="string">&quot;新生代农民工&quot;</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// name</span></span><br><span class="line">&gt;<span class="comment">// age</span></span><br><span class="line">&gt;<span class="comment">// occupation</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: es6 is not iterable</span></span><br></pre></td></tr></table></figure><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错</p></blockquote><h5 id="a-解决方案1"><a href="#a-解决方案1" class="headerlink" title="a) 解决方案1"></a>a) 解决方案1</h5><blockquote><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(someObject)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-使用-Generator-函数将对象重新包装-进行解决"><a href="#b-使用-Generator-函数将对象重新包装-进行解决" class="headerlink" title="b) 使用 Generator 函数将对象重新包装 进行解决"></a>b) 使用 Generator 函数将对象重新包装 进行解决</h5><blockquote><p>另一个方法是使用 Generator 函数将对象重新包装一下,不懂的可以带着疑惑往下看,可以先知道有这个用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> es6 = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;努力学习的汪&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">occupation</span>: <span class="string">&quot;新生代农民工&quot;</span></span><br><span class="line">&gt;&#125;; </span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;  <span class="comment">//注意 此处有 * 号</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">   <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(es6)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;:&#x27;</span>, value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//name: &quot;努力学习的汪&quot;,</span></span><br><span class="line">&gt;<span class="comment">//age: 99,</span></span><br><span class="line">&gt;<span class="comment">//occupation: &quot;新生代农民工&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-与其他遍历语法的比较"><a href="#⑥-与其他遍历语法的比较" class="headerlink" title="⑥ 与其他遍历语法的比较"></a>⑥ 与其他遍历语法的比较</h4><h5 id="a-for-与-forEach-概述"><a href="#a-for-与-forEach-概述" class="headerlink" title="a) for 与 forEach 概述"></a>a) for 与 forEach 概述</h5><blockquote><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p></blockquote><h5 id="b-for-in循环-概述"><a href="#b-for-in循环-概述" class="headerlink" title="b) for...in循环 概述"></a>b) <code>for...in</code>循环 概述</h5><blockquote><p><code>for...in</code>循环可以遍历数组的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有几个缺点。</p><ul><li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组</p></blockquote><h5 id="c-for-of循环相比上面几种做法的优点"><a href="#c-for-of循环相比上面几种做法的优点" class="headerlink" title="c) for...of循环相比上面几种做法的优点"></a>c) <code>for...of</code>循环相比上面几种做法的优点</h5><blockquote><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。具体区别看下方</li><li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p></blockquote><h3 id="Ⅸ-for…of-与-for…in区别"><a href="#Ⅸ-for…of-与-for…in区别" class="headerlink" title="Ⅸ - for…of 与 for…in区别"></a>Ⅸ - for…of 与 for…in区别</h3><blockquote><p>首先最明显的区别:</p><ul><li>for in遍历的是数组的索引（即键名）</li><li>而for of遍历的是数组元素值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> myArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">&gt;myArray.<span class="property">name</span>=<span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);    <span class="comment">//0,1,2,&#x27;数组&#x27;, f()&#123;&#125; ,</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray)  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);    <span class="comment">//1,2,4</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-for-in的一些缺陷"><a href="#a-for-in的一些缺陷" class="headerlink" title="a)  for in的一些缺陷:"></a>a)  for in的一些<strong>缺陷</strong>:</h5><blockquote><ol><li>索引是字符串型的数字，因而不能直接进行几何运算</li><li>遍历顺序可能不是实际的内部顺序</li><li>for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性</li></ol><p>故而一般用<strong>for in遍历对象而不用来遍历数组</strong></p><p>这也就是for of存在的意义了,<strong>for of 不遍历method和name,适合用来遍历数组</strong></p></blockquote><h5 id="b-for-of有缺点"><a href="#b-for-of有缺点" class="headerlink" title="b) for of有缺点:"></a>b) for of有缺点:</h5><blockquote><p><strong>for of不支持普通对象</strong>，想遍历对象的属性，可以用for in循环, 或内建的Object.keys()方法：</p><p><strong>Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Object</span>))</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;: &quot;</span> + <span class="title class_">Object</span>[key]);</span><br></pre></td></tr></table></figure><p>但是这样似乎代码优点冗余</p></blockquote><h2 id="16、Promise总"><a href="#16、Promise总" class="headerlink" title="16、Promise总"></a>16、Promise总</h2><blockquote><p>此知识点因为 <strong>很重要</strong> ,此处将只列出 ES6 中关于Promise的用法详解,像是 <strong>自定义Promise手撕代码</strong> 、<strong>Promise+ async +await</strong>、<strong>Promise的宏任务与微任务</strong> ….等等都不会在此处记载</p><p>更多完整关于Promise的知识点可以看这里 –&gt; <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Promise学习笔记</a></strong> </p></blockquote><h3 id="一、Promise的理解与使用"><a href="#一、Promise的理解与使用" class="headerlink" title="一、Promise的理解与使用"></a>一、Promise的理解与使用</h3><blockquote><p>1、概念:</p><p>​    Promise是<code>异步编程的一种解决方案</code>，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>通俗讲，<code>Promise是一个许诺、承诺</code>,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。</p><ul><li>Pending  正在做。。。</li><li>Resolved 完成这个承诺</li><li>Rejected 这个承诺没有完成，失败了</li></ul><p>​    Promise 用来预定一个不一定能完成的任务，要么成功，要么失败</p><p>​    在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果</p><p>Promise 是异步编程的一种解决方案，<code>主要用来解决回调地狱的问题，可以有效的减少回调嵌套</code>。真正解决需要<code>配合async/await</code></p><p>2、特点:</p><p>​    (1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p><p>​    (2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p><p>3、缺点:</p><p>​    (1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。</p><p>​    (2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p><p>​    (3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p></blockquote><hr><h3 id="1、Promise是什么"><a href="#1、Promise是什么" class="headerlink" title="1、Promise是什么?"></a>1、Promise是什么?</h3><h5 id="Ⅰ-理解"><a href="#Ⅰ-理解" class="headerlink" title="Ⅰ-理解"></a>Ⅰ-理解</h5><blockquote><ol><li>抽象表达:  </li></ol><p>​    1) Promise 是一门新的技术(ES6 规范) </p><p>​    2)Promise 是 JS 中<code>进行异步编程</code>的新解决方案 备注：旧方案是单纯使用回调函数</p><ol start="2"><li><p>具体表达: </p><ol><li><p>从语法上来说: Promise 是一个<code>构造函数</code></p></li><li><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p></li></ol></li></ol></blockquote><h5 id="Ⅱ-promise-的状态"><a href="#Ⅱ-promise-的状态" class="headerlink" title="Ⅱ-promise 的状态"></a>Ⅱ-promise 的状态</h5><h6 id="a-promise-的状态"><a href="#a-promise-的状态" class="headerlink" title="a) promise 的状态"></a>a) promise 的状态</h6><blockquote><p>实例对象中的一个属性 『PromiseState』</p><ul><li>pending  未决定的</li><li>resolved / fullfilled  成功</li><li>rejected  失败</li></ul></blockquote><h6 id="b-promise-的状态改变"><a href="#b-promise-的状态改变" class="headerlink" title="b) promise 的状态改变"></a>b) promise 的状态改变</h6><blockquote><ol><li><p>pending 变为 resolved </p></li><li><p>pending 变为 rejected</p></li></ol><p> 说明: <code>只有这 2 种</code>, 且一个 promise 对象<code>只能改变一次</code> 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p></blockquote><h5 id="Ⅲ-promise的基本流程"><a href="#Ⅲ-promise的基本流程" class="headerlink" title="Ⅲ-promise的基本流程"></a>Ⅲ-promise的基本流程</h5><blockquote><p><img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_promise%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Promise系统学习_promise工作流程"></p></blockquote><h5 id="Ⅳ-promise的基本使用"><a href="#Ⅳ-promise的基本使用" class="headerlink" title="Ⅳ-promise的基本使用"></a>Ⅳ-promise的基本使用</h5><h6 id="1-使用-promise-封装基于定时器的异步"><a href="#1-使用-promise-封装基于定时器的异步" class="headerlink" title="1.使用 promise 封装基于定时器的异步"></a>1.使用 promise 封装基于定时器的异步</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doDelay</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 在执行器函数中启动异步任务</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动异步任务&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延迟任务开始执行...&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 假设: 时间为奇数代表成功, 为偶数代表失败</span></span><br><span class="line">        <span class="keyword">if</span> (time % <span class="number">2</span> === <span class="number">1</span>) &#123; <span class="comment">// 成功了</span></span><br><span class="line">          <span class="comment">// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value</span></span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&#x27;成功的数据 &#x27;</span> + time)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了</span></span><br><span class="line">          <span class="comment">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&#x27;失败的数据 &#x27;</span> + time)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">doDelay</span>(<span class="number">2000</span>)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="comment">// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason</span></span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;,</span><br><span class="line">  ) &lt;</span><br><span class="line">  /script&gt;</span><br></pre></td></tr></table></figure><h6 id="2-使用-promise-封装-ajax-异步请求"><a href="#2-使用-promise-封装-ajax-异步请求" class="headerlink" title="2.使用 promise 封装 ajax 异步请求"></a>2.使用 promise 封装 ajax 异步请求</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  可复用的发 ajax 请求的函数: xhr + promise</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">promiseAjax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          status,</span><br><span class="line">          response</span><br><span class="line">        &#125; = xhr</span><br><span class="line">        <span class="comment">// 请求成功, 调用 resolve(value)</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(response))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求失败, 调用 reject(reason)</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败: status: &#x27;</span> + status))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">      xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="title function_">promiseAjax</span>(<span class="string">&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid</span></span><br><span class="line"><span class="string">    eo &#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;显示成功数据&#x27;</span>, data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ) &lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="3-fs模块使用Promise"><a href="#3-fs模块使用Promise" class="headerlink" title="3.fs模块使用Promise"></a>3.fs模块使用Promise</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数 形式----------------------------------------------------</span></span><br><span class="line"> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 如果出错 则抛出错误</span></span><br><span class="line">     <span class="keyword">if</span>(err)  <span class="keyword">throw</span> err;</span><br><span class="line">     <span class="comment">//输出文件内容</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise 形式-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装一个函数 mineReadFile 读取文件内容</span></span><br><span class="line"><span class="comment"> * 参数:  path  文件路径</span></span><br><span class="line"><span class="comment"> * 返回:  promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mineReadFile</span>(<span class="params">path</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span>(err) <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//输出文件内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-异常穿透"><a href="#4-异常穿透" class="headerlink" title="4.异常穿透"></a>4.异常穿透</h6><blockquote><p>可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p><p>在每个.then()中我可以将数据再次传出给下一个then()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./11.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&quot;2222222&quot;</span>))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是catch的&quot;</span>))</span><br></pre></td></tr></table></figure><h6 id="5-util-promisify方法"><a href="#5-util-promisify方法" class="headerlink" title="5.util.promisify方法"></a>5.<code>util.promisify方法</code></h6><blockquote><p>可以将函数直接变成promise的封装方式,不用再去手动封装</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入 util 模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="2、为什么要用Promise"><a href="#2、为什么要用Promise" class="headerlink" title="2、为什么要用Promise?"></a>2、为什么要用Promise?</h3><h4 id="Ⅰ-指定回调函数的方式更加灵活"><a href="#Ⅰ-指定回调函数的方式更加灵活" class="headerlink" title="Ⅰ-指定回调函数的方式更加灵活"></a>Ⅰ-指定回调函数的方式更加灵活</h4><blockquote><ol><li>旧的: 必须在启动异步任务前指定 </li><li>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个)</li></ol></blockquote><h4 id="Ⅱ-支持链式调用-可以解决回调地狱问题"><a href="#Ⅱ-支持链式调用-可以解决回调地狱问题" class="headerlink" title="Ⅱ-支持链式调用, 可以解决回调地狱问题"></a>Ⅱ-支持链式调用, 可以解决回调地狱问题</h4><h5 id="1、什么是回调地狱"><a href="#1、什么是回调地狱" class="headerlink" title="1、什么是回调地狱"></a>1、什么是回调地狱</h5><blockquote><p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="Promise系统学习_回调地狱"></p></blockquote><h5 id="2、回调地狱的缺点"><a href="#2、回调地狱的缺点" class="headerlink" title="2、回调地狱的缺点?"></a>2、回调地狱的缺点?</h5><blockquote><p>不便于阅读 不便于异常处理</p></blockquote><h5 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案?"></a>3、解决方案?</h5><blockquote><p>promise <code>链式调用</code>,</p><p>用来解决回调地狱问题，但是<code>只是简单的改变格式</code>，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步</p></blockquote><h5 id="4、终极解决方案"><a href="#4、终极解决方案" class="headerlink" title="4、终极解决方案?"></a>4、终极解决方案?</h5><blockquote><p>promise +async/await</p></blockquote><hr><h3 id="3、Promise中的常用-API-概述"><a href="#3、Promise中的常用-API-概述" class="headerlink" title="3、Promise中的常用 API 概述"></a>3、Promise中的常用 API 概述</h3><blockquote><p>此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的  <strong>Promise方法的具体使用</strong> 描述</p></blockquote><h4 id="Ⅰ-Promise-构造函数-Promise-excutor"><a href="#Ⅰ-Promise-构造函数-Promise-excutor" class="headerlink" title="Ⅰ- Promise 构造函数: Promise (excutor) {}"></a>Ⅰ- Promise 构造函数: Promise (excutor) {}</h4><blockquote><p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p><p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} </p><p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} </p><p>说明: executor 会在 Promise 内部立即<code>同步调用</code>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p></blockquote><h4 id="Ⅱ-Promise-prototype-then-方法-onResolved-onRejected-gt"><a href="#Ⅱ-Promise-prototype-then-方法-onResolved-onRejected-gt" class="headerlink" title="Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}"></a>Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</h4><blockquote><p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {} </p><p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} </p><p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p></blockquote><h4 id="Ⅲ-Promise-prototype-catch-方法-onRejected-gt"><a href="#Ⅲ-Promise-prototype-catch-方法-onRejected-gt" class="headerlink" title="Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt; {}"></a>Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt; {}</h4><blockquote><p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p><p>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中    </p></blockquote><h4 id="Ⅳ-Promise-resolve-方法-value-gt"><a href="#Ⅳ-Promise-resolve-方法-value-gt" class="headerlink" title="Ⅳ-Promise.resolve 方法: (value) =&gt; {}"></a>Ⅳ-Promise.resolve 方法: (value) =&gt; {}</h4><blockquote><p>(1) value: 成功的数据或 promise 对象 </p><p>说明: 返回一个成功/失败的 promise 对象,直接改变promise状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;));      </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅴ-Promise-reject-方法-reason-gt"><a href="#Ⅴ-Promise-reject-方法-reason-gt" class="headerlink" title="Ⅴ-Promise.reject 方法: (reason) =&gt; {}"></a>Ⅴ-Promise.reject 方法: (reason) =&gt; {}</h4><blockquote><p>(1) reason: 失败的原因 </p><p>说明: 返回一个失败的 promise 对象,直接改变promise状态,<code>代码示例同上</code></p></blockquote><h4 id="Ⅵ-Promise-all-方法-promises-gt"><a href="#Ⅵ-Promise-all-方法-promises-gt" class="headerlink" title="Ⅵ-Promise.all 方法: (promises) =&gt; {}"></a>Ⅵ-Promise.all 方法: (promises) =&gt; {}</h4><blockquote><p>promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, 只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);  &#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;错误错误错误&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;也是成功&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅶ-Promise-race-方法-promises-gt"><a href="#Ⅶ-Promise-race-方法-promises-gt" class="headerlink" title="Ⅶ-Promise.race 方法: (promises) =&gt; {}"></a>Ⅶ-Promise.race 方法: (promises) =&gt; {}</h4><blockquote><p>(1) promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, <code>第一个完成</code>的 promise 的结果状态就是最终的结果状态,</p><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="4、Promise的几个关键问题"><a href="#4、Promise的几个关键问题" class="headerlink" title="4、Promise的几个关键问题"></a>4、Promise的几个关键问题</h3><h4 id="Ⅰ-如何改变-promise-的状态"><a href="#Ⅰ-如何改变-promise-的状态" class="headerlink" title="Ⅰ-如何改变 promise 的状态?"></a>Ⅰ-如何改变 promise 的状态?</h4><blockquote><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved </p><p>(2) reject(reason): 如果当前是 pending 就会变为 rejected </p><p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p></blockquote><h4 id="Ⅱ-一个-promise-指定多个成功-失败回调函数-都会调用吗"><a href="#Ⅱ-一个-promise-指定多个成功-失败回调函数-都会调用吗" class="headerlink" title="Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗?"></a>Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗?</h4><blockquote><p>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">&gt;<span class="comment">///指定回调 - 1</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;);</span><br><span class="line">&gt;<span class="comment">//指定回调 - 2</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅲ-改变-promise-状态和指定回调函数谁先谁后"><a href="#Ⅲ-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?"></a>Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?</h4><blockquote><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 </p><p>​    先指定回调再改变状态(<code>异步</code>):先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数</p><p>​    先改状态再指定回调(<code>同步</code>):改变状态 –&gt;指定回调 <code>并马上执行</code>回调</p><p>(2) 如何先改状态再<code>指定</code>回调?   –&gt;注意:指定并不是执行</p><p>​    ① 在执行器中直接调用 resolve()/reject() –&gt;即,不使用定时器等方法,执行器内直接同步操作 </p><p>​    ② 延迟更长时间才调用 then()     –&gt;即,在<code>.then()</code>这个方法外再包一层例如延时器这种方法</p><p>(3) 什么时候才能得到数据? </p><p>​    ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 </p><p>​    ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;<span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>(4) 个人理解–结合源码</p><p>​    源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断,所以当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>,所以只是这样导致只有同步操作才能成功.</p><p>​    所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p><p>​    具体代码实现看下方自定义promise</p></blockquote><h4 id="Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定"><a href="#Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定" class="headerlink" title="Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?"></a>Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?</h4><blockquote><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定 </p><p>(2) 详细表达: </p><p>​    ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 </p><p>​    ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 </p><p>​    ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//执行 then 方法</span></span><br><span class="line">&gt;<span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;<span class="comment">// 1. 抛出错误 ,变为 rejected</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line">&gt;<span class="comment">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅴ-promise-如何串连多个操作任务"><a href="#Ⅴ-promise-如何串连多个操作任务" class="headerlink" title="Ⅴ- promise 如何串连多个操作任务?"></a>Ⅴ- promise 如何串连多个操作任务?</h4><blockquote><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 </p><p>(2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用<code>then()</code>将多个同步或异步操作串联成一个同步队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>); &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>); &#125;);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅵ-promise-异常传透"><a href="#Ⅵ-promise-异常传透" class="headerlink" title="Ⅵ-promise 异常传透?"></a>Ⅵ-promise 异常传透?</h4><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h4 id="Ⅶ-中断-promise-链"><a href="#Ⅶ-中断-promise-链" class="headerlink" title="Ⅶ- 中断 promise 链?"></a>Ⅶ- 中断 promise 链?</h4><blockquote><p>在<code>关键问题2</code>中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?</p><p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 </p><p>(2) 办法: 在回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="5、-Promise的实际应用"><a href="#5、-Promise的实际应用" class="headerlink" title="5、 Promise的实际应用"></a>5、 Promise的实际应用</h3><blockquote><p>举两个栗子</p></blockquote><h4 id="Ⅰ-加载图片"><a href="#Ⅰ-加载图片" class="headerlink" title="Ⅰ - 加载图片"></a>Ⅰ - 加载图片</h4><blockquote><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">&gt;image.<span class="property">onload</span>  = resolve;</span><br><span class="line">&gt;image.<span class="property">onerror</span> = reject;</span><br><span class="line">&gt;image.<span class="property">src</span> = path;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅱ-Generator-函数与-Promise-的结合"><a href="#Ⅱ-Generator-函数与-Promise-的结合" class="headerlink" title="Ⅱ - Generator 函数与 Promise 的结合"></a>Ⅱ - Generator 函数与 Promise 的结合</h4><blockquote><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getFoo</span> () &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> foo = <span class="keyword">yield</span> <span class="title function_">getFoo</span>();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">run</span> (generator) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> it = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));</span><br><span class="line">&gt;&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">go</span>(it.<span class="title function_">next</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p></blockquote><hr><h3 id="二、Promise-API-用法详解"><a href="#二、Promise-API-用法详解" class="headerlink" title="二、Promise API 用法详解"></a>二、Promise API 用法详解</h3><blockquote><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>此部分是对于 <strong>Promise API 用法的详解</strong> ,尽量详细地列举其常见用法,所以篇幅较长</p></blockquote><h3 id="Ⅰ-基本用法"><a href="#Ⅰ-基本用法" class="headerlink" title="Ⅰ -  基本用法"></a>Ⅰ -  基本用法</h3><h4 id="①-举个创造-Promise-实例的栗子"><a href="#①-举个创造-Promise-实例的栗子" class="headerlink" title="①  举个创造 Promise 实例的栗子"></a>①  举个创造 Promise 实例的栗子</h4><blockquote><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)  <span class="title function_">resolve</span>(value); <span class="comment">//将该 Promise 修改为成功且返回</span></span><br><span class="line"><span class="keyword">else</span>  <span class="title function_">reject</span>(error); <span class="comment">//将该 Promise 修改为失败且返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p></blockquote><h4 id="②-使用-then-方法分别指定-成功-失败-的回调"><a href="#②-使用-then-方法分别指定-成功-失败-的回调" class="headerlink" title="② 使用 [ then ] 方法分别指定 成功/失败 的回调"></a>② 使用 [ then ] 方法分别指定 成功/失败 的回调</h4><blockquote><p><code>Promise</code>实例生成以后，可以用 [ then() ] 方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为resolve 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为rejected 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>[ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，<strong>第二个函数是可选的，不一定要提供</strong>。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p></blockquote><h4 id="③-举个-Promise-对象的简单栗子"><a href="#③-举个-Promise-对象的简单栗子" class="headerlink" title="③ 举个 Promise 对象的简单栗子"></a>③ 举个 Promise 对象的简单栗子</h4><blockquote><p>下面是一个<code>Promise</code>对象的简单例子。</p><blockquote><p>setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123; <span class="comment">//声明一个方法, 传入的 参数ms 为延时器时间</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;)</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;努力学习的汪&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">timeout</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line">&gt;<span class="comment">//打印结果 : 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p></blockquote><h4 id="④-Promise-新建后就会立即执行"><a href="#④-Promise-新建后就会立即执行" class="headerlink" title="④ Promise 新建后就会立即执行"></a>④ Promise 新建后就会立即执行</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">&gt;<span class="title function_">resolve</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise</span></span><br><span class="line">&gt;<span class="comment">// Hi!</span></span><br><span class="line">&gt;<span class="comment">// resolved //可以发现,明明then是在 Hi 前面,却最后打印</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>实际上,这个运行结果相关知识点是 [ <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E5%9B%9B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务与微任务</a> ] ,单独梳理在下方.这里可以先初步理解为: </p><ol><li><p>JS是单线程的,至上往下运行,在声明 <strong>Promise</strong> 时实际上已经执行到了内部方法</p></li><li><p>为何 resolve() 运行后没有立即打印?</p></li></ol><ul><li><p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p><blockquote><p><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</p><p><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</p></blockquote></li><li><p>JS执行时会区别这2个队列:</p><blockquote><p>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</p><p>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</p></blockquote></li></ul></blockquote><h4 id="⑤-举个异步加载图片的栗子"><a href="#⑤-举个异步加载图片的栗子" class="headerlink" title="⑤ 举个异步加载图片的栗子"></a>⑤ 举个异步加载图片的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">&gt;image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载成功&#x27;</span>)</span><br><span class="line">&gt;<span class="title function_">resolve</span>(image);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法从 <span class="subst">$&#123;url&#125;</span> 中加载图片`</span> ));</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;image.<span class="property">src</span> = url;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">loadImageAsync</span>(<span class="string">&#x27;正确的url&#x27;</span>) <span class="comment">//打印图片加载成功</span></span><br><span class="line">&gt;<span class="title function_">loadImageAsync</span>(<span class="string">&#x27;错误的url&#x27;</span>) <span class="comment">//抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p><img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926180306961.png" alt="image-20210926180306961"> </p></blockquote><h4 id="⑥-举个用Promise对象实现的-Ajax-操作的栗子"><a href="#⑥-举个用Promise对象实现的-Ajax-操作的栗子" class="headerlink" title="⑥ 举个用Promise对象实现的 Ajax 操作的栗子"></a>⑥ 举个用<code>Promise</code>对象实现的 Ajax 操作的栗子</h4><blockquote><p>Ajax知识点不懂的同学要去补一下: 这里可以看本人梳理的ajax笔记 –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">点我跳转</a> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>)  <span class="keyword">return</span>; <span class="comment">//当readyState 为4 时直接返回,不修改 promise 状态</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>); <span class="comment">//返回状态为 200 时将状态修改为成功,且将响应内容返回</span></span><br><span class="line">&gt;<span class="keyword">else</span>  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>)); <span class="comment">//失败时抛出异常</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">//实例化xml实例</span></span><br><span class="line">&gt;client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url); <span class="comment">//下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点</span></span><br><span class="line">&gt;client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">&gt;client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">&gt;client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">&gt;client.<span class="title function_">send</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">return</span> promise;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> , json);</span><br><span class="line">&gt;&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p><img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926182129672.png" alt="image-20210926182129672"></p><blockquote><p>小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们</p></blockquote><blockquote><p><img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926182506259.png" alt="image-20210926182506259"> </p></blockquote></blockquote><h4 id="⑦-resolve-的参数可以是另一个-Promise-实例"><a href="#⑦-resolve-的参数可以是另一个-Promise-实例" class="headerlink" title="⑦  resolve()  的参数可以是另一个 Promise 实例"></a>⑦  resolve()  的参数可以是另一个 Promise 实例</h4><blockquote><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123; <span class="title function_">resolve</span>(p1) &#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;p1的状态改为错误&#x27;</span>)), <span class="number">0</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">3000</span>) <span class="comment">//将p1 传给p2</span></span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch异常捕获:&#x27;</span>+error))</span><br><span class="line">&gt;<span class="comment">//首先报错</span></span><br><span class="line">&gt;<span class="comment">//运行三秒后打印: 失败</span></span><br></pre></td></tr></table></figure><h5 id="上面代码运行后执行效果"><a href="#上面代码运行后执行效果" class="headerlink" title="上面代码运行后执行效果:"></a>上面代码运行后执行效果:</h5><ul><li>首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错)</li><li>然后等3秒后再打印:  ‘失败’</li><li>注意: 如果 <strong>p2.then()</strong> 中没有写 <strong>reject</strong> 回调函数(第二个参数),则会被 <strong>catch</strong> 捕获,变为<code>catch异常捕获:Error: p1的状态改为错误</code></li></ul><h5 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h5><blockquote><ul><li>首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 <strong>p1 的reject()</strong>,所以直接控制台报错了</li><li><code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态</li><li>总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态</li></ul></blockquote></blockquote><h4 id="⑧-调用resolve或reject并不会终结-Promise-的参数函数的执行"><a href="#⑧-调用resolve或reject并不会终结-Promise-的参数函数的执行" class="headerlink" title="⑧ 调用resolve或reject并不会终结 Promise 的参数函数的执行"></a>⑧ 调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行</h4><blockquote><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 2</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p></blockquote><h4 id="⑨-建议在修改状态函数前加return"><a href="#⑨-建议在修改状态函数前加return" class="headerlink" title="⑨ 建议在修改状态函数前加return"></a>⑨ 建议在修改状态函数前加return</h4><blockquote><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="comment">// 后面的语句不会执行</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure><p>有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 <code>resolve/reject</code>前后好像都不影响啊! 这里我给举个实际场景</p></blockquote><h5 id="a-不加-return-导致的错误场景举🌰"><a href="#a-不加-return-导致的错误场景举🌰" class="headerlink" title="a) 不加 return 导致的错误场景举🌰"></a>a) 不加 return 导致的错误场景举🌰</h5><blockquote><p>一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 [②Promise.prototype.catch()](#② Promise.prototype.catch())</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//如果你加了 return , 函数执行到此步就停止了</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误错误!!!!!&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line">&gt;<span class="comment">// ok</span></span><br><span class="line">&gt;<span class="comment">// Uncaught Error: 错误错误!!!!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p></blockquote><h3 id="Ⅱ-API-用法详解"><a href="#Ⅱ-API-用法详解" class="headerlink" title="Ⅱ -  API 用法详解"></a>Ⅱ -  API 用法详解</h3><blockquote><p>此处将对于所有API进行详细剖析,参照资料为 <a href="">阮一峰的ES6日志</a></p></blockquote><h4 id="①-Promise-prototype-then"><a href="#①-Promise-prototype-then" class="headerlink" title="① Promise.prototype.then()"></a>① Promise.prototype.then()</h4><blockquote><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p></blockquote><h5 id="a-then方法返回的是一个新的Promise实例"><a href="#a-then方法返回的是一个新的Promise实例" class="headerlink" title="a) then方法返回的是一个新的Promise实例"></a>a) <code>then</code>方法返回的是一个新的<code>Promise</code>实例</h5><blockquote><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> json.<span class="property">name</span>;</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span> )</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p></blockquote><h5 id="b-采用链式的then-会等待前一个Promise状态发生改变才会被调用"><a href="#b-采用链式的then-会等待前一个Promise状态发生改变才会被调用" class="headerlink" title="b) 采用链式的then, 会等待前一个Promise状态发生改变才会被调用"></a>b) 采用链式的<code>then</code>, 会等待前一个Promise状态发生改变才会被调用</h5><blockquote><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;  <span class="keyword">return</span> <span class="title function_">getJSON</span>(json.<span class="property">name</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="keyword">function</span> (<span class="params">name</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: My name is &quot;</span>, name)&#125;, </span><br><span class="line">&gt;<span class="keyword">function</span> (<span class="params">err</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p></blockquote><h5 id="c-使用箭头函数简写"><a href="#c-使用箭头函数简写" class="headerlink" title="c) 使用箭头函数简写"></a>c) 使用箭头函数简写</h5><blockquote><p>如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="title function_">getJSON</span>(json.<span class="property">name</span>) )</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">name</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: My name is &quot;</span>, name), </span><br><span class="line">&gt;<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Promise-prototype-catch"><a href="#②-Promise-prototype-catch" class="headerlink" title="② Promise.prototype.catch()"></a>② Promise.prototype.catch()</h4><blockquote><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p></blockquote><h5 id="a-基本用法-2"><a href="#a-基本用法-2" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象</p><blockquote><ul><li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；</li><li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误</li><li>另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</li><li>被 catch 方法捕获的前提是前方的 then() 方法中没有对 <code>rejected</code> 进行捕获处理(即没有写reject回调函数)</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在catch中进行 rejected 的处理&#x27;</span>, err));</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;等同于另起一个then,只指定 rejected 的处理&quot;</span>, err));</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-reject-方法的作用，等同于抛出错误"><a href="#b-reject-方法的作用，等同于抛出错误" class="headerlink" title="b)  reject()方法的作用，等同于抛出错误"></a>b)  <code>reject()</code>方法的作用，等同于抛出错误</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常捕获: &#x27;</span>,error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//异常捕获:  Error: 直接抛出错误</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/******************  写法一 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入catch,然后再用 reject(e)抛出 &#x27;</span>)</span><br><span class="line">&gt;<span class="title function_">reject</span>(e) </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//进入catch,然后再用 reject(e)抛出 </span></span><br><span class="line">&gt;<span class="comment">//Error: 直接抛出错误</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************  写法二 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;使用 reject() 抛出错误&#x27;</span>));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise1.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//Error: 使用 reject() 抛出错误</span></span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了</p></blockquote><h5 id="c-如果-Promise-状态已经被修改，再抛出错误是无效的"><a href="#c-如果-Promise-状态已经被修改，再抛出错误是无效的" class="headerlink" title="c) 如果 Promise 状态已经被修改，再抛出错误是无效的"></a>c) 如果 Promise 状态已经被修改，再抛出错误是无效的</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//换成 reject(&#x27;成功了&#x27;) 结果也是一样的</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;成功后扔抛出异常&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line">&gt;<span class="comment">// 成功了</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve/reject</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过)</p></blockquote><h5 id="d-Promise-对象的错误具有-“冒泡”-性质"><a href="#d-Promise-对象的错误具有-“冒泡”-性质" class="headerlink" title="d) Promise 对象的错误具有 “冒泡” 性质"></a>d) Promise 对象的错误具有 “冒泡” 性质</h5><blockquote><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>) <span class="comment">//第一个promise</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123; <span class="comment">//第二个promise</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123; <span class="comment">//第三个promise</span></span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象(<strong>then返回的仍可能是一个Promise对象</strong>)：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>也是因为这个特性,有了 <strong>异常穿透问题</strong> </p></blockquote><h5 id="e-异常穿透问题"><a href="#e-异常穿透问题" class="headerlink" title="e) 异常穿透问题"></a>e) 异常穿透问题</h5><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h5 id="f-建议使用-catch-进行异常处理"><a href="#f-建议使用-catch-进行异常处理" class="headerlink" title="f) 建议使用 catch() 进行异常处理"></a>f) 建议使用 catch() 进行异常处理</h5><blockquote><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// bad</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">data</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>,data),</span><br><span class="line">&gt;<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,err)</span><br><span class="line">);</span><br><span class="line">&gt;<span class="comment">/********* 好的写法 ********************/</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>( <span class="function"><span class="params">data</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>,data)) <span class="comment">//只指定成功回调</span></span><br><span class="line">&gt;.<span class="title function_">catch</span>( <span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,err));</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法:</p><ul><li>理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误</li><li>也更接近同步的写法（<code>try/catch</code>）</li><li>因此, 建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</li></ul></blockquote><h5 id="g-与传统-try-catch-代码块的差异"><a href="#g-与传统-try-catch-代码块的差异" class="headerlink" title="g) 与传统 try/catch 代码块的差异"></a>g) 与传统 <code>try/catch</code> 代码块的差异</h5><blockquote><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//Promise 的 then() 处理,但不处理异常</span></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;只指定成功回调,不处理异常错误&#x27;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。</p><blockquote><ul><li>浏览器运行到这一行，会打印出错误提示<code>Uncaught (in promise) ReferenceError: hong is not defined</code></li><li>但是不会退出进程、终止脚本执行, 2 秒之后还是会输出<code>努力学习的汪</code>。</li><li>这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li></ul></blockquote></blockquote><h5 id="h-catch-方法后还能跟-then-方法"><a href="#h-catch-方法后还能跟-then-方法" class="headerlink" title="h) catch()方法后还能跟 then() 方法"></a>h) catch()方法后还能跟 then() 方法</h5><blockquote><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>()</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捉到错误咯:&#x27;</span>, error)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获后我还要浪&#x27;</span>) &#125;);</span><br><span class="line">&gt;<span class="comment">//捉到错误咯: ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//错误捕获后我还要浪</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。</p><p>如果没有报错，则会跳过<code>catch()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;硬是成功了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捉错误&#x27;</span>, error) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch后面的then: &#x27;</span>,v) );</span><br><span class="line">&gt;<span class="comment">//catch后面的then:  硬是成功了</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p></blockquote><h5 id="i-catch-方法之中，还能再抛出错误"><a href="#i-catch-方法之中，还能再抛出错误" class="headerlink" title="i) catch()方法之中，还能再抛出错误"></a>i) <code>catch()</code>方法之中，还能再抛出错误</h5><blockquote><p><code>catch()</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>()</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function">() =&gt;</span>  <span class="title function_">someOtherAsyncThing</span>()) </span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ctach:&#x27;</span>, error);</span><br><span class="line"> <span class="comment">// 下面一行会报错，因为 sum 没有声明</span></span><br><span class="line">  sum ++;</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获后的then()&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ctach: [ReferenceError: hong is not defined]</span></span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, error);</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 sum 没有声明</span></span><br><span class="line">&gt;sum ++;</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch()后的catch: &#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//catch:  ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//catch()后的catch:  ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p></blockquote><h4 id="③-Promise-prototype-finally"><a href="#③-Promise-prototype-finally" class="headerlink" title="③ Promise.prototype.finally()"></a>③ Promise.prototype.finally()</h4><blockquote><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 <code>ES2018</code> 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><blockquote><ul><li><code>finally</code>方法的回调函数不接受任何参数，</li><li>这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。</li><li>这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li></ul></blockquote></blockquote><h5 id="a-finally本质上是then方法的特例"><a href="#a-finally本质上是then方法的特例" class="headerlink" title="a) finally本质上是then方法的特例"></a>a) <code>finally</code>本质上是<code>then</code>方法的特例</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">result</span> =&gt;</span>  result ,</span><br><span class="line">&gt;<span class="function"><span class="params">error</span> =&gt;</span>  <span class="keyword">throw</span> error</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p></blockquote><h5 id="b-它的实现"><a href="#b-它的实现" class="headerlink" title="b) 它的实现"></a>b) 它的实现</h5><blockquote><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">&gt;<span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值(传入什么即传出什么)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// resolve 的值是 undefined</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// resolve 的值是 2</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 undefined</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 3</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p><img src="ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927135255264.png" alt="image-20210927135255264"> </p></blockquote><h4 id="④-Promise-all"><a href="#④-Promise-all" class="headerlink" title="④ Promise.all()"></a>④ Promise.all()</h4><blockquote><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.all()</code>方法接受一个数组作为参数，</li><li><code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</li><li>另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</li></ul></blockquote></blockquote><h5 id="a-返回的状态由什么决定"><a href="#a-返回的状态由什么决定" class="headerlink" title="a) 返回的状态由什么决定?"></a>a) 返回的状态由什么决定?</h5><blockquote><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><blockquote><ol><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li></ol></blockquote><h6 id="下面是一个具体的例子。"><a href="#下面是一个具体的例子。" class="headerlink" title="下面是一个具体的例子。"></a>下面是一个具体的例子。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line">&gt;<span class="keyword">const</span> promises = [<span class="string">&#x27;hong&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">map</span>(item &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">getJSON</span>( item+<span class="string">&#x27;.json&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 <strong>都</strong> 变成<code>fulfilled</code>，或者**其中有一个变为<code>rejected</code>**，才会调用<code>Promise.all</code>方法后面的回调函数。</p><h6 id="下面是另一个例子"><a href="#下面是另一个例子" class="headerlink" title="下面是另一个例子"></a>下面是另一个例子</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>(); <span class="comment">//假设定义了一个异步方法,此方法能拿到你需要的所有数据</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> booksPromise = databasePromise     <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部书本信息</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> userPromise = databasePromise    <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">&gt;booksPromise,</span><br><span class="line">&gt;userPromise</span><br><span class="line">&gt;])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p></blockquote><h5 id="b-如果参数中的Promise实例定义了自己的catch方法"><a href="#b-如果参数中的Promise实例定义了自己的catch方法" class="headerlink" title="b) 如果参数中的Promise实例定义了自己的catch方法 ?"></a>b) 如果参数中的Promise实例定义了自己的catch方法 ?</h5><blockquote><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2自己的catch捕获: &#x27;</span>, e)</span><br><span class="line">&gt;<span class="keyword">return</span> e; <span class="comment">//异常获取后原样返回,不做修改</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//p2自己的catch捕获:  Error: 报错了</span></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的成功回调:  (2) [&#x27;hello&#x27;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，</p><blockquote><ul><li><code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code></li><li>但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。</li><li>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code></li><li>因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数</li></ul></blockquote></blockquote><h5 id="c-如果参数中的Promise实例-没有-定义自己的catch方法"><a href="#c-如果参数中的Promise实例-没有-定义自己的catch方法" class="headerlink" title="c)  如果参数中的Promise实例 没有 定义自己的catch方法 ?"></a>c)  如果参数中的Promise实例 <code>没有</code> 定义自己的catch方法 ?</h5><blockquote><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的catch Error: 报错了</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Promise-race"><a href="#⑤-Promise-race" class="headerlink" title="⑤ Promise.race()"></a>⑤ Promise.race()</h4><blockquote><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p></blockquote><h5 id="a-举个简单的🌰"><a href="#a-举个简单的🌰" class="headerlink" title="a) 举个简单的🌰"></a>a) 举个简单的🌰</h5><blockquote><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&gt;&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-举个应用实🌰"><a href="#b-举个应用实🌰" class="headerlink" title="b) 举个应用实🌰"></a>b) 举个应用实🌰</h5><blockquote><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求超时!!!!&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;p</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><p>是不是很好用又简单</p></blockquote><h4 id="⑥-Promise-allSettled"><a href="#⑥-Promise-allSettled" class="headerlink" title="⑥ Promise.allSettled()"></a>⑥ Promise.allSettled()</h4><blockquote><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。</p><p><strong>只有等到所有这些参数实例都返回结果</strong>，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><p>该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p></blockquote><h5 id="a-举个简单的🌰-1"><a href="#a-举个简单的🌰-1" class="headerlink" title="a) 举个简单的🌰"></a>a) 举个简单的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;loading = <span class="literal">true</span>; <span class="comment">//请求前将 loading 改为true ; 页面出现滚动加载图标蒙层</span></span><br><span class="line">&gt;<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line">&gt;loading = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p></blockquote><h5 id="b-该方法返回的新的-Promise-实例，一旦结束，状态总是fulfilled，不会变成rejected"><a href="#b-该方法返回的新的-Promise-实例，一旦结束，状态总是fulfilled，不会变成rejected" class="headerlink" title="b)  该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected"></a>b)  该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code></h5><blockquote><p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;返回成功状态的promise&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;返回失败状态的promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line">&gt;<span class="comment">// Promise.allSettled 得到的新实例状态只会是 `fulfilled`</span></span><br><span class="line">&gt;allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">//注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;[</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;</span></span><br><span class="line"><span class="comment">&gt;]</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>(注意,是 <strong>allSettledPromise</strong> 的状态,而不是内部的promise实例)</li><li>它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应的是传入<code>Promise.allSettled()</code>的 Promise 实例。</li><li>每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。</li><li><code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</li></ul></blockquote></blockquote><h5 id="c-举个返回值用法的🌰"><a href="#c-举个返回值用法的🌰" class="headerlink" title="c) 举个返回值用法的🌰"></a>c) 举个返回值用法的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [ <span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>) ];</span><br><span class="line">&gt;<span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出成功的请求</span></span><br><span class="line">&gt;<span class="keyword">const</span> successfulPromises = results.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出失败的请求，并取得它们的失败原因</span></span><br><span class="line">&gt;<span class="keyword">const</span> errors = results</span><br><span class="line">&gt;.<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> urls = [ <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span> ,<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">fetch</span>(x));</span><br><span class="line">&gt;<span class="comment">//举例用 Promise.all 尝试实现,很明显,难以实现</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requests);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了</p></blockquote><h4 id="⑦-Promise-any"><a href="#⑦-Promise-any" class="headerlink" title="⑦ Promise.any()"></a>⑦ Promise.any()</h4><blockquote><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p></blockquote><h5 id="a-与-Promise-race-方法的区别"><a href="#a-与-Promise-race-方法的区别" class="headerlink" title="a) 与 Promise.race() 方法的区别"></a>a) 与 <code>Promise.race()</code> 方法的区别</h5><blockquote><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p></blockquote><h5 id="b-Promise-any-抛出的错误"><a href="#b-Promise-any-抛出的错误" class="headerlink" title="b) Promise.any() 抛出的错误"></a>b) Promise.any() 抛出的错误</h5><blockquote><p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">AggregateError</span>() <span class="keyword">extends</span> <span class="title class_">Array</span> -&gt; <span class="title class_">AggregateError</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">AggregateError</span>();</span><br><span class="line">&gt;err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">&gt;err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line">&gt;<span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>(promises).<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// All of the promises were rejected.</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-再举个🌰"><a href="#c-再举个🌰" class="headerlink" title="c) 再举个🌰"></a>c) 再举个🌰</h5><blockquote><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;失败了&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> alsoRejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;太失败了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>([resolved, rejected, alsoRejected]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 成功</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>([rejected, alsoRejected]).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(results);  <span class="comment">//AggregateError: All promises were rejected</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败</p></blockquote><h4 id="⑧-Promise-resolve"><a href="#⑧-Promise-resolve" class="headerlink" title="⑧ Promise.resolve()"></a>⑧ Promise.resolve()</h4><blockquote><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况</p></blockquote><h5 id="a-参数是一个-Promise-实例"><a href="#a-参数是一个-Promise-实例" class="headerlink" title="a) 参数是一个 Promise 实例"></a>a) 参数是一个 Promise 实例</h5><blockquote><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></blockquote><h5 id="b-参数是一个thenable对象"><a href="#b-参数是一个thenable对象" class="headerlink" title="b) 参数是一个thenable对象"></a><strong>b) 参数是一个<code>thenable</code>对象</strong></h5><blockquote><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>) &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">&gt;p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// &#x27;成功&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出 **’成功’**。 </p></blockquote><h5 id="c-参数不是具有then-方法的对象，或根本就不是对象"><a href="#c-参数不是具有then-方法的对象，或根本就不是对象" class="headerlink" title="c) 参数不是具有then()方法的对象，或根本就不是对象"></a>c) 参数不是具有<code>then()</code>方法的对象，或根本就不是对象</h5><blockquote><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。</p><blockquote><ul><li>由于字符串 <code>努力学习的汪</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法）</li><li>返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行</li><li><code>Promise.resolve()</code>方法的参数会同时传给回调函数作为其参数</li></ul></blockquote></blockquote><h5 id="d-不带有任何参数"><a href="#d-不带有任何参数" class="headerlink" title="d) 不带有任何参数"></a>d) 不带有任何参数</h5><blockquote><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 –&gt; 不懂的同学请看 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#4%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8Bevent-loop%E6%9C%BA%E5%88%B6">JavaScript笔记中的#4事件循环模型event-loop机制</a> ,本人在此有进行详细的解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>); <span class="comment">//这里是新的一轮事件循环</span></span><br><span class="line">&gt;&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>); <span class="comment">//本轮同步代码结束后,新一轮事件循环前,就执行</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// one</span></span><br><span class="line">&gt;<span class="comment">// two</span></span><br><span class="line">&gt;<span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p></blockquote><h4 id="⑨-Promise-reject"><a href="#⑨-Promise-reject" class="headerlink" title="⑨ Promise.reject()"></a>⑨ Promise.reject()</h4><blockquote><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p></blockquote><h4 id="⑩-Promise-try"><a href="#⑩-Promise-try" class="headerlink" title="⑩ Promise.try()"></a>⑩ Promise.try()</h4><blockquote><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// next</span></span><br><span class="line">&gt;<span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><h6 id="那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的-API-呢？"><a href="#那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的-API-呢？" class="headerlink" title="那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？"></a>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？</h6></blockquote><h5 id="a-写法一-用async函数来写"><a href="#a-写法一-用async函数来写" class="headerlink" title="a) 写法一 : 用async函数来写"></a>a) 写法一 : 用<code>async</code>函数来写</h5><blockquote><p>该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-写法二-使用new-Promise"><a href="#b-写法二-使用new-Promise" class="headerlink" title="b)  写法二 : 使用new Promise()"></a>b)  写法二 : 使用<code>new Promise()</code></h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(</span><br><span class="line">&gt;<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">f</span>())</span><br><span class="line">&gt;)</span><br><span class="line">&gt;)();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p></blockquote><h5 id="c-Promise-try的引出"><a href="#c-Promise-try的引出" class="headerlink" title="c) Promise.try的引出"></a>c) Promise.try的引出</h5><blockquote><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">try</span>(<span class="function">() =&gt;</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p></blockquote><hr><h3 id="Ⅲ-更多-Promise-知识点"><a href="#Ⅲ-更多-Promise-知识点" class="headerlink" title="Ⅲ - 更多 Promise 知识点"></a>Ⅲ - 更多 Promise 知识点</h3><blockquote><p>此知识点因为 <strong>很重要</strong> ,此处将只列出ES6中关于Promise的用法详解,像是 <strong>自定义Promise手撕代码</strong> 、<strong>Promise+async+await</strong>、<strong>Promise的宏任务与微任务</strong> ….等等都不会在此处记载</p><p>更多完整关于Promise的知识点可以看这里 –&gt; <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Promise学习笔记</a></strong> </p></blockquote><blockquote></blockquote><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>const banji = {<br>    name: ‘终极一班’,<br>    stus: [<br>        ‘xianming’,<br>        ‘xianzhang’,<br>        ‘xiantian’<br>    ],<br>    //迭代器工作原理<br>    //1创建一个指针对象，指向当前数据结构的起始位置<br>    //2第一次调用对象的next 方法，指针自动指向数据结构的第一个成员<br>    //不断的调用next方法，指针一直往后移动，直到指向最后一个成员<br>    //每次调用next方法，返回一个包含value和done 属性的对象<br>    <a href="">Symbol.iterator</a> {<br>        let index = 0;</p><pre><code>    return &#123;        next: () =&gt; &#123;            if (index &lt; this.stus.length) &#123;                const result = &#123; value: this.stus[index], done: false &#125;;                index++;                return result;            &#125; else &#123;                return &#123; value: undefined, done: true &#125;;            &#125;        &#125;    &#125;;&#125;</code></pre><p>}<br>for (let v of banji) {<br>    console.log(v);<br>}<br>// for (let v of banji.stus) {<br>//     console.log(v);<br>// }<br>//遍历<br>// banji.stus.forEach(element =&gt; {<br>//     console.log(element)<br>// });</p><blockquote><h4 id="异步编程传参"><a href="#异步编程传参" class="headerlink" title="异步编程传参"></a>异步编程传参</h4><p>// 生成器函数<br>// 实例1 ：1s 后输出111 ，再过2s后输出222，再过3s后输出333<br>function cc(a, x) {<br>    setTimeout(() =&gt; {<br>        console.log(a)<br>        iterator.next();<br>    }, x)<br>}<br>function* gen() {<br>    yield cc(‘你好’, 1000);<br>    yield cc(‘我好’, 1000);<br>    yield cc(‘大家好’, 1000);<br>}<br>let iterator = gen();<br>iterator.next();//next 方法可以传入实参,实参为yield语句的整个返回结果</p><p>//实例2模拟获取 用户数据，订单数据，商品数据<br>function getUsers() {<br>    setTimeout(() =&gt; {<br>        let data = ‘用户数据’;<br>        iterator.next(data);<br>    }, 1000)<br>}</p></blockquote><p>function getOrders() {<br>    setTimeout(() =&gt; {<br>        let data = ‘订单数据’;<br>        iterator.next(data);<br>    }, 1000)<br>}</p><p>function getGoods() {<br>    setTimeout(() =&gt; {<br>        let data = ‘商品数据’;<br>        iterator.next(data);<br>    }, 1000)<br>}</p><p>function* gen() {<br>    let users = yield getUsers();<br>    console.log(users);<br>    let orders = yield getOrders();<br>    console.log(orders);<br>    let goods = yield getGoods();<br>    console.log(goods);<br>}<br>let iterator = gen();<br>iterator.next();</p><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Postman的基本使用</title>
      <link href="/2022/10/15/Postman%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/10/15/Postman%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Postman使用"><a href="#Postman使用" class="headerlink" title="Postman使用"></a>Postman使用</h1><h2 id="一、Postman背景介绍"><a href="#一、Postman背景介绍" class="headerlink" title="一、Postman背景介绍"></a>一、Postman背景介绍</h2><blockquote><p>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p></blockquote><h2 id="二、Postman的操作环境"><a href="#二、Postman的操作环境" class="headerlink" title="二、Postman的操作环境"></a>二、Postman的操作环境</h2><p>postman适用于不同的操作系统，Postman Mac、Windows X32、Windows X64、Linux系统，还支持postman 浏览器扩展程序、postman chrome应用程序等。</p><p>Postman使用参考文档：</p><p>1.官方英文文档<a href="https://www.getpostman.com/docs/v6/">https://www.getpostman.com/docs/v6/</a></p><p>2.chrome插件整理的 postman中文使用教程 <a href="http://chromecj.com/web-development/2017-12/870.html">http://chromecj.com/web-development/2017-12/870.html</a></p><h2 id="三、Postman下载安装"><a href="#三、Postman下载安装" class="headerlink" title="三、Postman下载安装"></a>三、Postman下载安装</h2><h3 id="1-gt-、postman下载地址："><a href="#1-gt-、postman下载地址：" class="headerlink" title="1&gt; 、postman下载地址："></a>1&gt; 、postman下载地址：</h3><p>1.Postman for MAC</p><p>2.Postman for windows X64</p><p>3.Postman for windows X86</p><p>4.Postman for linux X64</p><p>5.Postman for Linux X86</p><h3 id="2-gt-Postman官网下载地址："><a href="#2-gt-Postman官网下载地址：" class="headerlink" title="2&gt;. Postman官网下载地址："></a>2&gt;. Postman官网下载地址：</h3><p><a href="https://www.getpostman.com/apps">https://www.getpostman.com/apps</a></p><h3 id="3-Postman安装"><a href="#3-Postman安装" class="headerlink" title="3.Postman安装"></a>3.Postman安装</h3><blockquote><p>postman的安装方法分好几种，按照我们上文介绍的那样，我们分为三种安装模式介绍：</p></blockquote><h4 id="1、chrome浏览器postman-插件安装"><a href="#1、chrome浏览器postman-插件安装" class="headerlink" title="1、chrome浏览器postman 插件安装"></a>1、chrome浏览器postman 插件安装</h4><blockquote><p>postman谷歌浏览器的安装插件，所以说它的使用前提是你的电脑上得安装谷歌浏览器才行，在安装了谷歌浏览器后还需要在谷歌网上应用店中下载所需要的Postman插件，该插件的下载方式如下：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181030002023904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz,size_16,color_FFFFFF,t_70" alt="avatar"></p><blockquote><p>不能访问google 应用上商店的朋友 可以 参考这里， 或者下载客户端版本</p></blockquote><h4 id="2-Postman电脑客户端安装"><a href="#2-Postman电脑客户端安装" class="headerlink" title="2.Postman电脑客户端安装"></a>2.Postman电脑客户端安装</h4><p>1).macOS安装<br>一旦你下载的应用程序，你可以拖动文件到“应用程序”文件夹。 双击Postman打开应用程序。</p><p>2).Windows安装<br>下载安装文件<br>运行安装程序<br>3). Linux安装<br>我没有试过，但是找了一些参考资料( 有兴趣的朋友可以自行实验)<br>ubuntu安装postman: <a href="https://blog.csdn.net/qianmosolo/article/details/79353632">https://blog.csdn.net/qianmosolo/article/details/79353632</a><br>Ubuntu16.04上安装Postman应用程序: <a href="https://blog.bluematador.com/posts/postman-how-to-install-on-ubuntu-1604/?utm_source=hootsuite&amp;utm_medium=twitter&amp;utm_campaign=">https://blog.bluematador.com/posts/postman-how-to-install-on-ubuntu-1604/?utm_source=hootsuite&amp;utm_medium=twitter&amp;utm_campaign=</a></p><h2 id="四、Postman的基础功能"><a href="#四、Postman的基础功能" class="headerlink" title="四、Postman的基础功能"></a>四、Postman的基础功能</h2><p><img src="https://img-blog.csdn.net/20180523232921542?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><h2 id="五、接口请求流程"><a href="#五、接口请求流程" class="headerlink" title="五、接口请求流程"></a>五、接口请求流程</h2><blockquote><ol><li>GET 请求<br>GET请求：点击Params，输入参数及value，可输入多个，即时显示在URL链接上，<br>所以，GET请求的请求头与请求参数如在接口文档中无特别声明时，可以不填。<br><img src="https://img-blog.csdn.net/20180523233825152?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></li></ol></blockquote><p>响应示例： 这里会有请求的响应状态码，响应时间，以及响应大小</p><p><img src="https://img-blog.csdn.net/20180523234132434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><p>响应体示例： 响应的格式可以有多种，我这里由于请求的是 百度，so, 响应的是 html ,一般情况下，我们自定义接口的话是 json格式的响应体</p><p><img src="https://img-blog.csdn.net/20180523234247147?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><blockquote><ol start="2"><li>POST请求<br>POST请求一：表单提交</li></ol></blockquote><p>下图示例中设置了请求方法，请求URL，请求参数，但是没有设置请求头<br>在我的使用过程中，请求头是根据请求参数的形式自动生成的<br>请求头中的Content-Type与请求参数的格式之间是有关联关系，比如：</p><p><img src="https://img-blog.csdn.net/20180524000345232?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><p><img src="https://img-blog.csdn.net/20180523234739215?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><p><img src="https://img-blog.csdn.net/20180523234748383?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><blockquote><p>POST请求二：json提交<br>下图中，当我们选择JSON(application/json) 是会自动帮我们设置 headers 为 application/json<br>在这里就不截图 举例了，朋友们可以自行去查看</p></blockquote><p><img src="https://img-blog.csdn.net/2018052400054291?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><blockquote><p>POST请求三：xml提交</p></blockquote><p><img src="https://img-blog.csdn.net/20180524000901598?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><blockquote><p>POST请求四：二进制文件提交</p></blockquote><p><img src="https://img-blog.csdn.net/20180524001010654?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p><p>其它请求方式如PUT,DELETE 大致流程和GET,POST 差不多，这里就不一一举例说明了</p><h2 id="六、身份验证Authentication"><a href="#六、身份验证Authentication" class="headerlink" title="六、身份验证Authentication"></a>六、身份验证Authentication</h2><blockquote><p>1、Basic Auth</p></blockquote><p>是基础的验证，所以会比较简单<br>会直接把用户名、密码的信息放在请求的 Header 中</p><blockquote><p>2、Digest Auth</p></blockquote><p>要比Basic Auth复杂的多。使用当前填写的值生成authorization header。所以在生成header之前要确保设置的正确性。如果当前的header已经存在，postman会移除之前的header。</p><blockquote><p>3、OAuth 1.0</p></blockquote><p>postman的OAuth helper让你签署支持OAuth</p><p>1.0基于身份验证的请求。OAuth不用获取access token,你需要去API提供者获取的。OAuth 1.0可以在header或者查询参数中设置value。</p><blockquote><p>4、OAuth 2.0</p></blockquote><p>postman支持获得OAuth 2.0 token并添加到requests中。</p><blockquote><p>————————————————<br>本文仅供本人学习使用，摘自CSDN博主「大痴小乙」的原创文章<br>原文链接：<a href="https://blog.csdn.net/fxbin123/article/details/80428216">https://blog.csdn.net/fxbin123/article/details/80428216</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2学习笔记</title>
      <link href="/2022/10/14/Vue2%E7%AC%94%E8%AE%B0(%E9%83%A8%E5%88%86)/"/>
      <url>/2022/10/14/Vue2%E7%AC%94%E8%AE%B0(%E9%83%A8%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>-node_modules-public     |_favicon.ico:页签图标     |_index.html:主页面-src    |_assets:存放静态资源    |        |_logo.png    |_compoent: 存放组件    |        |_helloWorld.vue    |_App.vue:汇总所有组件    |_main.js：入口文件-.gitignore:git版本管制忽略的配置-bable.config.js:bable的配置文件-package.json:应用包配置文件-READE.md:应用描述文件-package-lock.json:包版本控制文件</code></pre><h2 id="关于不同版本Vue的说明"><a href="#关于不同版本Vue的说明" class="headerlink" title="关于不同版本Vue的说明"></a>关于不同版本Vue的说明</h2><p>1.vue.js 是完整版的Vue，包含核心功能和模板解析器<br>2.vue.runting.xxx.js是运行版本的Vue,只有核心功能<br> 因为vue.runtime.xxx.js没有模板解析器,所以不能使用template配置项,需要使用render函数收到createElement函数去指定具体内容</p><h2 id="Vue-config-js配置文件"><a href="#Vue-config-js配置文件" class="headerlink" title="Vue.config.js配置文件"></a>Vue.config.js配置文件</h2><blockquote><p>使用 vue inspect &gt;output.js 可以查看到Vue脚手架的默认配置。<br>使用vue.config.js可以对脚手架进行个性化定制，详情：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></p></blockquote><h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h2><p>  1.被用来给元素或子组件注册引用信息（id的替代）<br>  2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象<br>  3.使用方式：<br>        打标识：<h1 ref="xxx"></h1> 或<School ref="xxx"></School><br>        获取：this.$refs.xxx</p><h2 id="配置项props"><a href="#配置项props" class="headerlink" title="配置项props"></a>配置项props</h2><p>  功能：让组件接收外部传过来的数据<br>  （1）传递数据：<Demo name="xxx" /><br>   (2)接收数据：1.只接收： props:[‘name’]<br>                2.限制类型： props:{ name:Number}<br>                3.限制类型，限制必要性，指定默认值<br>                        props:{<br>                            type:String,<br>                            required:true,<br>                            default<br>                        }<br>   备注：props是只读的，Vue底层会监测你对props的修改，如果修改就会发出警告</p><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><p>  功能： 把多个组件共用的配置提取成一个混入对象<br>  使用： 1：定义：{ data(){},methods:{}…}<br>        2:使用： 全局：Vue.mixin(xx)    局部：mixins:[‘xxx’,’xxx’]</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>   功能： 增加Vue<br>   本质： 包含install方法的一个对象，install的第一个参数是Vue（构造函数），第二个以后的参数是插件使用者传递的数据<br>   定义插件：<br>       对象.install=function(Vue,options){<br>        Vue.filter(…)</p><pre><code>    添加全局指令    Vue.directive(...)    配置全局混入    Vue.mixin(...)     添加实例方法     Vue.prototype.$myMethod=function()&#123;&#125;     Vue.prototype.$myProperty=xxx   &#125;使用插件：Vue.use()</code></pre><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><p>   作用：让样式在局部生效，防止命名冲突<br>   写法：<style scoped></p><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><pre><code>1.组件化编码流程：    （1）拆分静态组件：组件要按照功能点拆分，不要与html元素命名冲突     (2)实现动态组件：考虑好数据的存放位置，数据是一个组件用还是多个组件用          1).一个组件使用，放在组件自身即可          2）。多个组件使用，放在共同的父组件上（状态提升）     （3）实现交互：从绑定事件开始2.props适用于：     (1)父组件==》子组件通信     (2)子组件==》父组件通信，需要父组件给子组件传递函数3.v-model注意点：v-model绑定值不能是props传递过来的值，因为props不能修改4.props传过来的值如果是对象类型，修改对象的属性时Vue不会报错，但是不推荐此做法</code></pre><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><p>  1.存储内容大小一般在5MB左右<br>  2.浏览器通过Window.sessionStorage和Window.localStorage属性实现本地存储机制<br>  3.相关API：<br>        1.setItem(‘key’,’value’):接收键和值，添加到存储中，存在键则更新<br>        2.getItem(‘key’):返回键值<br>        3.removeItem(‘key’):从存储中删除<br>        4.clear():清楚所有存储数据<br>  4.备注：<br>    SessionStorage内容随浏览器关闭而消失<br>    LocalStorage内容需要手动清除<br>    getItem()如果对应的value获取不利，则返回null<br>    Json.parse(null)结果为null</p><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><p>   1.一种组件间通信的方式，适用于：子=&gt;&gt;父<br>   2.使用场景：A是父，B是子，B想给A数据，就要在A中给B绑定自定义事件，事件回调在A中<br>   3.绑定自定义事件：<br>            1.在父组件中：&lt;Deomo @MyEvent=”test”/&gt; 或者<Demo v-on:MyEvent="test"/><br>            2.在父组件中：<br>                <Demo ref="demo"/><br>                    …<br>                mounted(){<br>                    this.$refs.xxx.$on(‘MyEvent’,this.test)<br>                    }<br>            3.如果只想事件触发一次，可以使用once修饰符或者$once方法<br>  4.触发自定事件：this.$emit(‘MyEvent’,数据)<br>  5.解绑自定义事件：this.$off(‘MyEvent’)<br>  6.组件上也可以绑定原生DOM事件，需要使用native修饰符<br>  7.通过this.$refs.xxx.$on(‘MyEvent’,回调函数)绑定自定义事件时，要么回调配置在methods中，要么用箭头函数，否则会出现this指向问题</p><h2 id="全局事件总线-GlobalEventBus"><a href="#全局事件总线-GlobalEventBus" class="headerlink" title="全局事件总线(GlobalEventBus)"></a>全局事件总线(GlobalEventBus)</h2><p>   1.一种组件间的通信方式，适用于任意组件间的通信<br>   2.安装：new Vue({<br>        beforeCreate(){<br>            Vue.protype.$bus=this//安装全局事件总线，this为当前vm<br>     }<br>  })<br>   3.使用：<br>         1.接收数据：A组件想收数据，则在A组件中给$bus绑定自定事件，事件的回调留在A组件自身<br>          methods(){<br>            demo(date){….}<br>       }<br>          mounted(){<br>            this.$bus.$on(‘hello’,this.demo)<br>      }<br>         2.提供数据：this.$bus.$emit(‘hello’,数据)<br> 4.最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件</p><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><p>  1.一种组件间的通信方式，适用于任意组件间通信<br>  2.使用步骤：<br>        1.安装pubsub: npm i pubsub-js<br>        2.引入：import pubsub from ‘pubsub-js’<br>        3.接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调在A组件<br>          methods(){<br>            demo(_,data){…}<br>        }<br>        …<br>        mounted(){<br>            this.pid=pubsub.subscribe(‘hello’,this.demo)//订阅消息<br>        }<br>        4.提供数据：pubsub.publish(‘hello’,数据)<br>        5.最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅</p><h2 id="Vue封装的过渡与动画"><a href="#Vue封装的过渡与动画" class="headerlink" title="Vue封装的过渡与动画"></a>Vue封装的过渡与动画</h2><pre><code>    1.作用：在插入，更新或者移除DOM元素时，在合适的时候给元素添加样式类名    2.写法：            1.准备好样式：                    进入的样式：                        v-enter:进入的起点                        v-enter-active；进入的过程中                        v-enter-to:进入的终点                    离开的样式：                        v-leave:离开的起点                        v-leave-active；离开的过程中                        v-leave-to:离开的终点            2.使用&lt;transition&gt;包裹要过渡的元素，设置name属性                    &lt;transition name=&quot;hello&quot;&gt;                        &lt;h1 v-show=&quot;isShow&quot;&gt;Hello&lt;/h1&gt;                    &lt;/transition&gt;            3.备注：有多个元素需要过渡，则需要使用：&lt;transition-group&gt;并给每个元素指定key值</code></pre><h2 id="Vue脚手架配置代理"><a href="#Vue脚手架配置代理" class="headerlink" title="Vue脚手架配置代理"></a>Vue脚手架配置代理</h2><pre><code>方法一：在vue.config.js中配置        devServer:&#123;            proxy:&quot;http://localhost:5000&quot;            &#125;    说明：优点：配置简单，请求资源时直接发给前端（8080）即可         缺点：不能配置多个代理，不能灵活控制请求是否走代理         工作方式：当请求前端不存在的资源时，那么该请求会转发给服务器，匹配优先前端资源</code></pre><p>  方法二：编写vue.config.js具体代理规则<br>            modul.exports={<br>                devSever:{<br>                    proxy:{<br>                    ‘/api’:{ //匹配所有以‘/api’开头的请求路径<br>                    target:”<a href="http://localhost:5000&quot;,//代目标的基础路径">http://localhost:5000&quot;,//代目标的基础路径</a><br>                    changeOrigin:true,<br>                    pathRewrite:true,<br>                    },<br>                     ‘/api’:{<br>                    target:”<a href="http://localhost:5001&quot;">http://localhost:5001&quot;</a>,<br>                    changeOrigin:true,<br>                    pathRewrite:true,<br>                    }<br>                }<br>            }<br>            }<br>            changeOrigin 为ture时，服务器收到的请求头的host为：localhost:5000<br>            changeOrigin 为false时，服务器收到的请求头的host为：localhost:8080<br>      说明： 优点：可以配置多个代理，且可以灵活的控制请求是否走代理<br>            缺点：配置略微繁琐，请求资源时必须加载前缀</p><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><pre><code>    1.作用；让父组件可以向子组件指定的位置插入html结构，也是一种组件间通信方式，适用于父组件=》子组件    2。分类：默认插槽，具名插槽，作用域插槽    3.用法：           (1).默认插槽：父：                        &lt;Category&gt;                            &lt;div&gt;html结构&lt;/div&gt;                        &lt;/Category&gt;                    子：                        &lt;template&gt;                    `       &lt;div&gt;                                定义插槽                             &lt;slot&gt;默认内容&lt;/slot&gt;                             &lt;/div&gt;                        &lt;/template&gt;            (2).具名插槽：父：                        &lt;Category&gt;                             &lt;template slot=&quot;center&quot;&gt;                            &lt;div&gt;html结构1&lt;/div&gt;                            &lt;/template&gt;                            &lt;template slot=&quot;footer&quot;&gt;                            &lt;div&gt;html结构2&lt;/div&gt;                            &lt;/template&gt;                            &lt;/Category&gt;                    子：                        &lt;template&gt;                    `       &lt;div&gt;                                定义插槽                             &lt;slot name=&quot;center&quot;&gt;默认内容&lt;/slot&gt;                             &lt;slot name=&quot;footer&quot;&gt;默认内容&lt;/slot&gt;                                &lt;/div&gt;                        &lt;/template&gt;             (3).作用域插槽：                    1.理解：数据在组件的自身，到根据数据生成的结构需要组件的使用者来决定                    （games数据在Category组件中,使用数据所遍历出来的结构由App组件决定）                    父：                        &lt;Category&gt;                              &lt;template scope=&quot;scopeData&quot;&gt;                                    生成的是ul列表                                    &lt;ul&gt;                                        &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                                    &lt;/ul&gt;                               &lt;/template&gt;                        &lt;/Category&gt;                         &lt;Category&gt;                              &lt;template scope=&quot;scopeData&quot;&gt;                                    生成的是ol列表                                    &lt;ol&gt;                                        &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;                                    &lt;/ol&gt;                               &lt;/template&gt;                        &lt;/Category&gt;                     子：                        &lt;template&gt;                            &lt;div&gt;                                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;                            &lt;/div&gt;                        &lt;/template&gt;                         &lt;sctipt&gt;                            export default &#123;                                name:&#39;Category&#39;,                                 data()&#123;                                    return&#123;  games:[.....] &#125;                                                                    &#125;                               &#125;                         &lt;/script&gt;   </code></pre><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><pre><code>1.概率：专门在Vue中实现集中式状态（数据）管理的一个Vue组件，对vue应用中多个组件的共享状态进行集中式管理（读、写）      也是一种组件间的通信方式，适合任意组件间通信2.什么时候用：        1.多个组件依赖同一个状态        2. 来自不同组件的行为需要变更同一状态3.搭建环境：    (1)创建文件       创建src/store/index.js      引入Vue:import Vue from &#39;vue&#39;      引入Vuex：import Vuex from &#39;vuex      应用Vuex插件：Vue.use(Vuex)      准备actions,mutations,state :const ...=&#123;&#125;      创建并暴露store        export default new Vuex.Store(&#123;                actions,mutations,state        &#125;)    (2)在main.js中创建vm时传入store配置项3.基本使用：    1).初始化数据，配置actions，mutation，操作文件store。js        引入Vue核心库和Vuex        Vue.use（Vuex）        const actions=&#123;              jia(context,value)&#123;                context.commit(&#39;JIA&#39;,value)                                       &#125;                      &#125;        const mutations=&#123;              //执行加                JIA(state,value)&#123;                state.sum+=value                                       &#125;                      &#125;        const state=&#123;                sum:0                        &#125;        export default new Vuex.store(&#123;            actions,mutations,state           &#125;)    2).组件读取Vuex中的数据：$store.state.sum    3).组件中修改Vuex中的数据：$store.dispatch(&#39;actions中的方法名&#39;,数据)                           $store.commit(&#39;mutations中的方法名&#39;,数据)  备注：没有网络请求和其他业务逻辑时，组件可以越过actions，不写dispath，直接写commit</code></pre><p>4.getters的使用：<br>        1.概念：当state中的数据需要经过加工后在使用时，可使用getters加工<br>        2.在store中追加getters配置项<br>        const getters={<br>            bigSum(state){<br>                return state.sum*10<br>            }<br>        }<br>        3.创建时传入getters<br>5.四个map方法的使用<br>        导入：import {mapState,mapGetters,mapActions,mapMutations} from ‘vuex’<br>        1.mapState方法：帮助映射state中的数据为计算属性<br>        computed:{<br>        …mapState({sum:’Sum’,school:’school’,course:’course’}) 对象写法<br>        …mapState([‘Sum’,’school’,’course’])                   数组写法<br>        }<br>        2.mapGetters方法：帮助映射getters中的数据为计算属性<br>        computed:{<br>        …mapGetters({bigSum:’bigSum’})                        对象写法<br>            …mapGetters([‘bigSum’])                           数组写法<br>        }<br>        3.mapActions方法：帮助生成与actions对话的方法,即包含$store.dispatch(xxx)的函数<br>        methods:{<br>        …mapActions({incrementOdd:’jiaOdd’,incrementWait:’jiaWait’}) 对象写法<br>        …mapActions([‘jiaOdd’,’jiaWait’])                   数组写法<br>        }<br>        4.mapMutations方法：帮助生成mutations对话的方法，即包含$store.commit(xxx)的函数<br>        methods:{<br>        …mapState({increment:’JIA’,decrement:’JIAN’}) 对象写法<br>        …mapState([‘JIA’,’JIAN’])                   数组写法<br>        }<br>        注：数组方法需要属性名与store中的名字相同<br>6.模块化+命名空间<br>        1.目的：代码好维护，多种数据分类明确<br>        2.修改store.js<br>            const countAbout={<br>                namespaced:true,//开启命名空间<br>                …<br>            }<br>            const personAbout={<br>                 namespaced:true,//开启命名空间<br>                   …<br>            }<br>        3.开启命名空间后，读取sate数据：<br>            方法一： this.$store.state.personAbout.personList<br>            方法二： …mapState(‘countAbout’,[‘sum’,’school’….])<br>        4.开启命名空间后，读取getters数据：<br>            方法一： this.$store.getters[‘personAbout/firstPersonName’]<br>            方法二： …mapGetters(‘countAbout’,[‘bigSum’])<br>        5.开启命名空间后，组件中调用dispatch：<br>            方法一： this.$store.dispatch(‘personAbout/addPersonWang’,person)<br>            方法二： …mapActions(‘countAbout’,{‘incrementOdd:’jiaOdd’,incrementWati:’jiaWait’})<br>        6.开启命名空间后，组件中调用commit：<br>            方法一： this.$store.commit(‘personAbout/showMsg’)<br>            方法二： …mapMutations(‘personAbout’,{‘showMsg’})</p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>基本使用：<br>    1.vue-router：Vue的一个插件库，专门用来实现SPA应用<br>    2.SPA应用：单页web应用，整个应用只有一个完整的页面，点击页面中的导航链接不会刷新页面，只会做页面局部更新<br>              数据需要通过ajax请求获取<br>    3.路由：1.一个路由就是一组映射关系：key value<br>           2.key 为路径，value可能是function或component<br>           3.分类：后端路由：value为function，用于处理客户端提交的请求<br>                          服务器收到请求时，根据请求路径找到匹配函数处理请求，返回响应数据<br>                  前端路由：value为component,用于展示页面内容<br>                           当浏览器路径改变时，对应的组件显示<br>    4.基本路由：1安装：npm i vue-router<br>              2应用：导入并引用Vue.use(VueRouter)<br>              3创建router文件夹并配置<br>                import VueRouter from ‘vue-router’<br>                import About from ‘../compoents/About’<br>                import Home from ‘../compoents/Home’<br>                // 创建并暴露一个路由实例对象，管理一组一组的路由规则<br>                export default new VueRouter({<br>                       routes:[<br>                      {<br>                         path:’/about’,<br>                        component:About<br>                        },<br>                      {<br>                          path:’/home’,<br>                         component:Home<br>                       },<br>                          ]<br>                })<br>                4.实现切换 （active-class可配置高亮样式）<br>                <router-link active-calss="active" to="/about">About</router-link><br>                5.指定展示位置<br>                <router-view></view><br>                几个注意点：  1.路由组件通常放在pages文件夹，一般组件通常放在Component文件夹<br>                            2.通过切换，“隐藏”了路由组件，默认是被销毁的，需要的时候再挂载<br>                            3.每个组件都有自己的$route属性，里面存储自己的路由信息<br>                            4.整个应用只有一个router,可以通过组件的$router属性获取到<br>    5.多级路由（嵌套路由）<br>            1.配置路由规则,使用children配置项：<br>                routes:[<br>                  {path:’/about’,componment:About},<br>                    //子路由路径不要带斜杠<br>                  {path:’/home’,componment:Home,children:[{path:’news’,component:News},{path:’message’,component:Message}]}<br>                 ]<br>            2.跳转：要写完整路径<br>                <router-link to="/home/news">News组件内容</router-link><br>    6.路由的query参数<br>            1.传递参数：<br>                &lt;router-link :to”{path:’/home/message/detail’,<br>                                 query:{id:?,title:?}}”&gt;<br>                </router-link><br>            2.接收参数：<br>                $route.query.id<br>    7.命名路由<br>            1.作用：简化路由跳转<br>            2.命名：router文件夹中的index.js,添加name配置<br>                    {name:’xxx’,path:’xxx’,children:[{xxx}]}<br>               简化跳转：<br>                &lt;router-link :to=”{name:”xxx”}”&gt;跳转</router-link><br>                &lt;router-link :to=”{<br>                            name:”xxx”,<br>                            query:{<br>                                id:xxx,<br>                                title:xxx,<br>                            }<br>                            }”&gt;<br>                跳转</router-link><br>    8.路由的params参数<br>            1.配置路由：<br>                 使用占位符声明接收params参数<br>                {name:’xiang’,path:’xxx/:id/:title’,component:xx}<br>            2.传递参数：<br>                <router-link :to="/home/message/title/666/hello"></router-link><br>                &lt;router-link :to=”{name:”xiang”,params:{id:xxx,title:xxx}}”&gt;</router-link><br>            注意：路由携带params参数时，若使用to的对象写法，不能用path配置项，只能用name配置项<br>            3.接收参数：<br>                $route.params.id<br>                $route.params.title<br>    9.路由的props配置<br>            作用：让路由组件更方便的接收参数<br>                (1) props对象写法,值为对象，对象中的所有key-value都会以props形式传给Detail组件(只能传固定值)<br>                 props:{a:1,b:’hello’},<br>                (2)值为布尔值，为真，会把该路由的所有params参数,以props形式传给Detail组件<br>                 props:true,<br>                (3)值为函数，所有key-value都会以props形式传给Detail组件（重要）<br>                props($route){<br>                return {id:$route.params.id, title:$route.params.title}<br>                }<br>    10.<router-link>的replace属性<br>            1.作用：控制路由跳转时操作浏览器历史记录的模式<br>            2.浏览器历史记录有两种写入方式：push,replace,push为追加,replace是替换当前记录，<br>                路由跳转默认为push<br>            3.开启replace:<router-link replace...></router-link><br>    11.编程式路由导航<br>            1.作用：不借助<router-link>实现路由跳转,让路由跳转更加灵活<br>            2.编码：$router的api<br>             pushShow(m){<br>                 this.$router.push({<br>                     name:’xiangqing’,<br>                     query: {<br>                         id: m.id,<br>                         title: m.title,<br>                      }<br>                      })<br>                     },<br>             replaceShow(m){<br>                this.$router.replace({<br>                     name:’xiangqing’,<br>                     query: {<br>                        id: m.id,<br>                        title: m.title,<br>                        }<br>                      })<br>                    }<br>             this.$router.forward()//前进<br>             this.$router.back()//后退<br>             this.$router.go(number)//前进或者后退<br>    12.缓存路由组件<br>            1.作用：让不展示的路由组建保持挂载，不会进入销毁流程<br>            2.编码：<br>                多个里面选几个缓存：  :include=”[‘News’,’Message’]”<br>                <keep-alive include="News"><br>                    <router-view></router-view><br>                </keep-alive><br>            注意：需要缓存的组件展示在什么地方<br>    13.两个路由组件生命周期钩子<br>            1.作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态<br>            2.activated：路由组件被激活时触发<br>              deactivated:路由组件失活时触发<br>    14.路由守卫<br>            1.作用：对路由进行权限控制<br>            2.分类：全局守卫，独享守卫，组件内守卫<br>            3.全局守卫<br>                // 全局前置路由守卫–初始化时调用，每次路由切换之前调用<br>                router.beforeEach((to,from,next)=&gt;{<br>                if(to.meta.isAuth===true)//判断是否需要权限控制<br>                     {<br>                          if (localStorage.getItem(‘school’)===’atguigu’)//权限控制的具体规则<br>                         {<br>                         next()//放行<br>                            }else {<br>                                    alert(‘无权限查看’)<br>                          }<br>                    }else{<br>                     next()//放行<br>                    }<br>                })<br>                // 全局后置路由守卫–初始化时调用，每次路由切换之后调用<br>                router.afterEach((to,from)=&gt;{<br>                        document.title=to.meta.title || ‘TT’//修改网页的title<br>                })<br>            4.独享路由守卫<br>                某一个路由所独享的独享路由守卫<br>                beforeEnter:(to, from, next)=&gt;{<br>                     if(to.name===’xinwen’){<br>                             if(localStorage.getItem(‘school’)==’atguigu’){<br>                                 next()<br>                              }else {<br>                                  alert(‘无权限’)<br>                                 }<br>                     }else {<br>                         next()<br>                         }<br>                }<br>            5.组件内守卫<br>                进入守卫，通过路由规则，进入该组件时被调用<br>                beforeRouterEnter(to,from,next){ }<br>                离开守卫，通过路由规则，离开该组件时被调用<br>                beforeRouterLeave(to,from,next){ }<br>    15路由器的两种工作模式<br>            1.对于URL来说，hash值： #及后面的内容就是hash值<br>            2.hash值不会包含在http请求中，hash值不会带给服务器<br>            3.hash模式：<br>                    1.地址带#<br>                    2.若以后将地址通过第三方手机app分享，若app校验严格，则地址会标记为不合法<br>                    3.兼容性好<br>              history模式：<br>                    1.地址不带#<br>                    2.兼容性和hash模式想比略差<br>                    3.应用部署需要后端人员支持，解决刷新页面服务端404的问题</p><pre><code>          改变模式：再路由配置中                 export default new Router(&#123;mode:&#39;history&#39;,....&#125;)           </code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Axios入门</title>
      <link href="/2022/10/13/Axios%E5%85%A5%E9%97%A8/"/>
      <url>/2022/10/13/Axios%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="预备工具"><a href="#预备工具" class="headerlink" title="预备工具"></a>预备工具</h2><blockquote><ol><li>作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。</li><li>安装json-server<br><code>npm install -g json-server</code></li><li>创建db.json<br>在一个文件夹下新建一个db.json文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-server&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动json-server<br>在当前文件夹下输入如下命令：<code>json-server db.json</code></li><li><a href="https://github.com/typicode/json-server">文档</a></li></ol></blockquote><h1 id="一、Axios的理解与使用"><a href="#一、Axios的理解与使用" class="headerlink" title="一、Axios的理解与使用"></a>一、Axios的理解与使用</h1><h2 id="Ⅰ-axios-是什么"><a href="#Ⅰ-axios-是什么" class="headerlink" title="Ⅰ-axios 是什么?"></a>Ⅰ-axios 是什么?</h2><blockquote><ol><li>前端最流行的 ajax 请求库 </li><li>react/vue 官方都推荐使用 axios 发 ajax 请求 </li><li>文档: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ol></blockquote><h2 id="Ⅱ-axios-特点"><a href="#Ⅱ-axios-特点" class="headerlink" title="Ⅱ-axios 特点"></a>Ⅱ-axios 特点</h2><blockquote><ol><li>基于 xhr + promise 的异步 ajax 请求库 </li><li>浏览器端/node 端都可以使用 </li><li>支持请求／响应拦截器 </li><li>支持请求取消 </li><li>请求/响应数据转换 </li><li>批量发送多个请求</li></ol></blockquote><h2 id="Ⅲ-axios-常用语法"><a href="#Ⅲ-axios-常用语法" class="headerlink" title="Ⅲ-axios 常用语法"></a>Ⅲ-axios 常用语法</h2><blockquote><ol><li>axios(config): <code>通用/最本质</code>的发任意类型请求的方式 </li><li>axios(url[, config]): 可以只指定 url 发 get 请求 </li><li>axios.request(config): 等同于 axios(config) </li><li>axios.get(url[, config]): 发 get 请求 </li><li>axios.delete(url[, config]): 发 delete 请求 </li><li>axios.post(url[, data, config]): 发 post 请求</li><li>axios.put(url[, data, config]): 发 put 请求 </li><li>axios.defaults.xxx: 请求的默认全局配置 </li><li>axios.interceptors.request.use(): 添加请求拦截器 </li><li>axios.interceptors.response.use(): 添加响应拦截器 </li><li>axios.create([config]): 创建一个新的 axios(它没有下面的功能) </li><li>axios.Cancel(): 用于创建取消请求的错误对象 </li><li>axios.CancelToken(): 用于创建取消请求的 token 对象 </li><li>axios.isCancel(): 是否是一个取消请求的错误 </li><li>axios.all(promises): 用于批量执行多个异步请求 </li><li>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</li></ol></blockquote><h2 id="Ⅳ-原理图"><a href="#Ⅳ-原理图" class="headerlink" title="Ⅳ-原理图"></a>Ⅳ-原理图</h2><p><img src="Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Axios%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Axios系统学习笔记原理图"></p><h2 id="Ⅴ-难点语法的理解和使用"><a href="#Ⅴ-难点语法的理解和使用" class="headerlink" title="Ⅴ-难点语法的理解和使用"></a>Ⅴ-难点语法的理解和使用</h2><h3 id="1、axios-create-config"><a href="#1、axios-create-config" class="headerlink" title="1、axios.create(config)"></a>1、axios.create(config)</h3><blockquote><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 </p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 </p></li><li><p>为什么要设计这个语法?</p></li></ol><p>  (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 </p><p>  (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line">  <span class="keyword">const</span> duanzi = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> onather = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line">  <span class="comment">// duanzi(&#123;</span></span><br><span class="line">  <span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line">  <span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(response);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  duanzi.<span class="title function_">get</span>(<span class="string">&#x27;/getJoke&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、拦截器函数-ajax-请求-请求的回调函数的调用顺序"><a href="#2、拦截器函数-ajax-请求-请求的回调函数的调用顺序" class="headerlink" title="2、拦截器函数/ajax 请求/请求的回调函数的调用顺序"></a>2、拦截器函数/ajax 请求/请求的回调函数的调用顺序</h3><blockquote><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 </li><li>流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 </li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// Promise</span></span><br><span class="line">  <span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.<span class="property">params</span> = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应拦截器</span></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// return response;</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、取消请求"><a href="#3、取消请求" class="headerlink" title="3、取消请求"></a>3、取消请求</h3><blockquote><ol><li>基本流程 配置 cancelToken 对象 </li><li>缓存用于取消请求的 cancel 函数 </li><li>在后面特定时机调用 cancel 函数取消请求 </li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li><li>实现功能 点击按钮, 取消某个正在请求中的请求,</li><li>实现功能 点击按钮, 取消某个正在请求中的请求</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//获取按钮</span></span><br><span class="line">  <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">  <span class="comment">//2.声明全局变量</span></span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//取消上一次的请求</span></span><br><span class="line">      <span class="title function_">cancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">      <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">        <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">        cancel = c;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">      <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">      cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">  btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">cancel</span>(); &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅵ-默认配置"><a href="#Ⅵ-默认配置" class="headerlink" title="Ⅵ-默认配置"></a>Ⅵ-默认配置</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认配置</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">       btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">axios</span>(&#123;</span><br><span class="line">               <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">           &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="二、Axios的难点问题"><a href="#二、Axios的难点问题" class="headerlink" title="二、Axios的难点问题"></a>二、Axios的难点问题</h1><h2 id="Ⅰ-目录结构"><a href="#Ⅰ-目录结构" class="headerlink" title="Ⅰ-目录结构"></a>Ⅰ-目录结构</h2><blockquote><p>├── /dist/ # 项目输出目录<br>├── /lib/ # 项目源码目录<br>│ ├── /adapters/ # 定义请求的适配器 xhr、http<br>│ │ ├── http.js # 实现 http 适配器(包装 http 包)<br>│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)<br>│ ├── /cancel/ # 定义取消功能<br>│ ├── /core/ # 一些核心功能<br>│ │ ├── Axios.js # axios 的核心主类<br>│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数<br>│ │ ├── InterceptorManager.js # 拦截器的管理器<br>│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态<br>│ ├── /helpers/ # 一些辅助方法<br>│ ├── axios.js # 对外暴露接口<br>│ ├── defaults.js # axios 的默认配置<br>│ └── utils.js # 公用工具<br>├── package.json # 项目信息<br>├── index.d.ts # 配置 TypeScript 的声明文件<br>└── index.js # 入口文件</p></blockquote><h2 id="Ⅱ-axios-与-Axios-的关系"><a href="#Ⅱ-axios-与-Axios-的关系" class="headerlink" title="Ⅱ-axios 与 Axios 的关系"></a>Ⅱ-axios 与 Axios 的关系</h2><blockquote><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li><li>axios 是 <code>Axios.prototype.request</code> 函数 bind()返回的函数</li><li>axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ol></blockquote><h2 id="Ⅲ-instance-与-axios-的区别"><a href="#Ⅲ-instance-与-axios-的区别" class="headerlink" title="Ⅲ- instance 与 axios 的区别?"></a>Ⅲ- instance 与 axios 的区别?</h2><blockquote><ol><li>相同:<br>(1) 都是一个能发任意请求的函数: request(config)<br>(2) 都有发特定请求的各种方法: get()/post()/put()/delete()<br>(3) 都有默认配置和拦截器的属性: defaults/interceptors</li><li>不同:<br>(1) 默认配置很可能不一样<br>(2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all()</li></ol></blockquote><h2 id="Ⅳ-axios运行的整体流程"><a href="#Ⅳ-axios运行的整体流程" class="headerlink" title="Ⅳ-axios运行的整体流程"></a>Ⅳ-axios运行的整体流程</h2><blockquote><ol><li><p>整体流程:<br>request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</p></li><li><p>request(config):<br>将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br> 返回 promise</p></li><li><p>dispatchRequest(config):<br>转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数<br> 据. 返回 promise</p></li><li><p>xhrAdapter(config):<br>创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br> 返回 promise </p></li><li><p>流程图:</p></li></ol><p><img src="Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Axios%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Axios系统学习流程图"></p></blockquote><h2 id="Ⅴ-axios-的请求-响应拦截器是什么"><a href="#Ⅴ-axios-的请求-响应拦截器是什么" class="headerlink" title="Ⅴ-axios 的请求/响应拦截器是什么?"></a>Ⅴ-axios 的请求/响应拦截器是什么?</h2><blockquote><ol><li>请求拦截器:<br>Ⅰ- 在真正发送请求前执行的回调函数<br>Ⅱ- 可以对请求进行检查或配置进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li><li>响应拦截器<br>Ⅰ- 在请求得到响应后执行的回调函数<br>Ⅱ- 可以对响应数据进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 response<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li></ol></blockquote><h2 id="Ⅵ-axios-的请求-响应数据转换器是什么"><a href="#Ⅵ-axios-的请求-响应数据转换器是什么" class="headerlink" title="Ⅵ-axios 的请求/响应数据转换器是什么?"></a>Ⅵ-axios 的请求/响应数据转换器是什么?</h2><blockquote><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (utils.<span class="title function_">isObject</span>(data)) &#123;</span><br><span class="line"> <span class="title function_">setContentTypeIfUnset</span>(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.<span class="property">data</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="property">data</span>)</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅶ-response与error-的整体结构"><a href="#Ⅶ-response与error-的整体结构" class="headerlink" title="Ⅶ- response与error  的整体结构"></a>Ⅶ- response与error  的整体结构</h2><blockquote><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">data, status,statusText,headers,config,request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>error  的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">message,response,request,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅷ-如何取消未完成的请求"><a href="#Ⅷ-如何取消未完成的请求" class="headerlink" title="Ⅷ-如何取消未完成的请求?"></a>Ⅷ-如何取消未完成的请求?</h2><blockquote><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数<br>(1) 创建一个用于将来中断请求的 cancelPromise<br>(2) 并定义了一个用于取消请求的 cancel 函数<br>(3) 将 cancel 函数传递出来</li><li>调用 cancel()取消请求<br>(1) 执行 cacel 函数, 传入错误信息 message<br>(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象<br>(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,<br>失败的 reason 为 Cancel 对象</li></ol></blockquote><h1 id="三、Axios源码模拟实现"><a href="#三、Axios源码模拟实现" class="headerlink" title="三、Axios源码模拟实现"></a>三、Axios源码模拟实现</h1><h2 id="Ⅰ-axios-的创建过程模拟实现"><a href="#Ⅰ-axios-的创建过程模拟实现" class="headerlink" title="Ⅰ- axios 的创建过程模拟实现"></a>Ⅰ- axios 的创建过程模拟实现</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">defaults</span> = config; <span class="comment">//为了创建 default 默认属性</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">intercepters</span> = &#123;</span><br><span class="line">       <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">       <span class="attr">response</span>: &#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//原型添加相关的方法</span></span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送 AJAX 请求 请求的类型为 &#x27;</span> + config.<span class="property">method</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">post</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//声明函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="comment">//实例化一个对象</span></span><br><span class="line">     <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(config); <span class="comment">// context.get()  context.post()  但是不能当做函数使用 context() X</span></span><br><span class="line">     <span class="comment">//创建请求函数</span></span><br><span class="line">     <span class="keyword">let</span> instance = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(</span><br><span class="line">     context); <span class="comment">// instance 是一个函数 并且可以 instance(&#123;&#125;)  此时 instance 不能 instance.get X</span></span><br><span class="line">     <span class="comment">//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       instance[key] = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[key].<span class="title function_">bind</span>(context); <span class="comment">// this.default  this.interceptors</span></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//为 instance 函数对象添加属性 default 与 interceptors</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       instance[key] = context[key];</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> axios = <span class="title function_">createInstance</span>();</span><br><span class="line">   <span class="comment">//发送请求</span></span><br><span class="line">   <span class="comment">// axios(&#123;method:&#x27;POST&#x27;&#125;);</span></span><br><span class="line">   axios.<span class="title function_">get</span>(&#123;&#125;);</span><br><span class="line">   axios.<span class="title function_">post</span>(&#123;&#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅱ-axios发送请求过程详解"><a href="#Ⅱ-axios发送请求过程详解" class="headerlink" title="Ⅱ-axios发送请求过程详解"></a>Ⅱ-axios发送请求过程详解</h2><blockquote><ol><li>整体流程:<br> request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</li><li>request(config):<br> 将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br> 返回 promise</li><li>dispatchRequest(config):<br> 转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数<br> 据. 返回 promise</li><li>xhrAdapter(config):<br> 创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br> 返回 promise </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">// axios 发送请求   axios  Axios.prototype.request  bind</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//1. 声明构造函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//创建一个 promise 对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//声明一个数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>]; <span class="comment">// undefined 占位</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//调用 then 方法指定回调</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> result = promise.<span class="title function_">then</span>(chains[<span class="number">0</span>], chains[<span class="number">1</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//返回 promise 的结果</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//2. dispatchRequest 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//调用适配器发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//响应的结果进行转换处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//....</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">throw</span> error;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//3. adapter 适配器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;xhrAdapter 函数执行&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//发送 AJAX 请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//发送</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="title function_">send</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//绑定事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="comment">//判断成功的条件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="comment">//成功的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="title function_">resolve</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//配置对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">config</span>: config,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应体</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">data</span>: xhr.<span class="property">response</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应头</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">headers</span>: xhr.<span class="title function_">getAllResponseHeaders</span>(), <span class="comment">//字符串  parseHeaders</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">// xhr 请求对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">request</span>: xhr,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应状态码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应状态字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="comment">//失败的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败 失败的状态码为&#x27;</span> + xhr.<span class="property">status</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//4. 创建 axios 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅲ-拦截器的模拟实现"><a href="#Ⅲ-拦截器的模拟实现" class="headerlink" title="Ⅲ-拦截器的模拟实现"></a>Ⅲ-拦截器的模拟实现</h2><blockquote><ol><li>array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</li><li>思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行</li><li><code>promise = promise.then(chains.shift(), chains.shift());</code> 通过循环使用promise的then链条得到最终的结果–&gt;等式前面的<code>promise</code>将被最终的结果覆盖</li></ol></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>拦截器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求  难点与重点</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//创建一个 promise 对象</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//创建一个数组</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>];</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//处理拦截器</span></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []</span></span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               chains.<span class="title function_">unshift</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               chains.<span class="title function_">push</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">// console.log(chains);</span></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//遍历</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">while</span>(chains.<span class="property">length</span> &gt; <span class="number">0</span>)&#123; </span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//array.shift()</span></span></span><br><span class="line"><span class="language-javascript">               promise = promise.<span class="title function_">then</span>(chains.<span class="title function_">shift</span>(), chains.<span class="title function_">shift</span>());</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> promise;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//返回一个promise 队形</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">resolve</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">status</span>: <span class="number">200</span>,</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span></span></span><br><span class="line"><span class="language-javascript">               &#125;);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">      </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//创建实例</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//创建axios函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 context 属性 config interceptors 添加至 axios 函数对象身上</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           axios[key] = context[key];</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//拦截器管理器构造函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">InterceptorManager</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">fulfilled, rejected</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               fulfilled,</span></span><br><span class="line"><span class="language-javascript">               rejected</span></span><br><span class="line"><span class="language-javascript">           &#125;)</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//以下为功能测试代码</span></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 设置请求拦截器  config 配置对象</span></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 设置响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span><br><span class="line"><span class="language-javascript">       &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅳ-请求取消功能模拟实现"><a href="#Ⅳ-请求取消功能模拟实现" class="headerlink" title="Ⅳ-请求取消功能模拟实现"></a>Ⅳ-请求取消功能模拟实现</h2><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>取消请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&#x27;anonymous&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>axios取消请求<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span> 发送请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span>&gt;</span> 取消请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//原型 request 方法</span></span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="title function_">dispatchRequest</span>(config);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//dispatchRequest 函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//xhrAdapter</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//发送 AJAX 请求</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//实例化对象</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//初始化</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//处理结果</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//判断结果</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="comment">//设置为成功的状态</span></span></span><br><span class="line"><span class="language-javascript">             <span class="title function_">resolve</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span><br><span class="line"><span class="language-javascript">             &#125;);</span></span><br><span class="line"><span class="language-javascript">           &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//关于取消请求的处理</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//对 cancelToken 对象身上的 promise 对象指定成功的回调</span></span></span><br><span class="line"><span class="language-javascript">         config.<span class="property">cancelToken</span>.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">abort</span>();</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//将整体结果设置为失败</span></span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求已经被取消&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">         &#125;);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//创建 axios 函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//CancelToken 构造函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">CancelToken</span>(<span class="params">executor</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//声明一个变量</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> resolvePromise;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//为实例对象添加属性</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 resolve 赋值给 resolvePromise</span></span></span><br><span class="line"><span class="language-javascript">       resolvePromise = resolve</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//调用 executor 函数</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">executor</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//执行 resolvePromise 函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">resolvePromise</span>();</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//获取按钮 以上为模拟实现的代码</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//2.声明全局变量</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">   btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//检测上一次的请求是否已经完成</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//取消上一次的请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">cancel</span>();</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//创建 cancelToken 的值</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> cancelToken = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       cancel = c;</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//1. 添加配置对象的属性</span></span></span><br><span class="line"><span class="language-javascript">       <span class="attr">cancelToken</span>: cancelToken</span></span><br><span class="line"><span class="language-javascript">     &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 cancel 的值初始化</span></span></span><br><span class="line"><span class="language-javascript">       cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//绑定第二个事件取消请求</span></span></span><br><span class="line"><span class="language-javascript">   btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">cancel</span>();</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="四、自己对于某些问题解答与理解"><a href="#四、自己对于某些问题解答与理解" class="headerlink" title="四、自己对于某些问题解答与理解"></a>四、自己对于某些问题解答与理解</h1><h2 id="Ⅰ-axios同步与异步转换-在外部取值"><a href="#Ⅰ-axios同步与异步转换-在外部取值" class="headerlink" title="Ⅰ-axios同步与异步转换,在外部取值"></a>Ⅰ-axios同步与异步转换,在外部取值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  axios  =  <span class="built_in">require</span> (<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"> <span class="comment">//创建实例对象 </span></span><br><span class="line"> <span class="keyword">const</span> $http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:53000&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">11000</span>  <span class="comment">//请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">resolveCommon</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=$http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//打印结果: Promise &#123; &lt;pending&gt; &#125; </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">resolveAsync</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=<span class="keyword">await</span> $http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)  <span class="comment">//获得正确的值</span></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125;</span></span><br><span class="line"><span class="comment">    *  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//模拟新增数据,将上一步的结果简单加工一下</span></span><br><span class="line">   data.<span class="property">course_name</span>=data.<span class="property">course_name</span>+<span class="number">1</span></span><br><span class="line"> $http(&#123;</span><br><span class="line">   <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>:<span class="string">&quot;put&quot;</span>,</span><br><span class="line">   data</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(v)  <span class="comment">//直接打印了 需要再取出参照上一步</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">resolveCommon</span>()  <span class="comment">//调用普通promise函数</span></span><br><span class="line"><span class="title function_">resolveAsync</span>()    <span class="comment">//调用await+async</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML规范</title>
      <link href="/2022/10/13/HTML%E8%A7%84%E8%8C%83/"/>
      <url>/2022/10/13/HTML%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-代码规范"><a href="#HTML-代码规范" class="headerlink" title="HTML 代码规范"></a>HTML 代码规范</h2><blockquote><p>很多 Web 开发人员对 HTML 的代码规范知之甚少。</p><p>在2000年至2010年，许多Web开发人员从 HTML 转换到 XHTML,使用 XHTML 开发人员逐渐养成了比较好的 HTML 编写规范。</p><p>而针对于 HTML5 ，我们应该形成比较好的代码规范，以下提供了几种规范的建议</p></blockquote><h2 id="Ⅰ-HTML整体结构"><a href="#Ⅰ-HTML整体结构" class="headerlink" title="Ⅰ - HTML整体结构"></a><strong>Ⅰ - HTML整体结构</strong></h2><h3 id="1、-DOCTYPE-声明"><a href="#1、-DOCTYPE-声明" class="headerlink" title="1、 DOCTYPE 声明"></a>1、 DOCTYPE 声明</h3><blockquote><p>一个 DOCTYPE 必须包含以下部分，并严格按照顺序出现：</p><ol><li>一个 ASCII 字符串 “<code>&lt;!DOCTYPE&gt;</code>” ，大小写不敏感</li><li>一个或多个空白字符</li><li>一个 ASCII 字符串” <code>html</code> ”，大小写不敏感</li><li>一个可选的历史遗留的 DOCTYPE 字符串 （<a href="http://www.w3.org/TR/2014/REC-html5-20141028/syntax.html#doctype-legacy-string">DOCTYPE legacy string</a>），或者一个可选的已过时但被允许的 DOCTYPE 字符串 （<a href="http://www.w3.org/TR/2014/REC-html5-20141028/syntax.html#obsolete-permitted-doctype-string">obsolete permitted DOCTYPE string</a>） 字符串</li><li>一个或多个空白字符</li><li>一个编码为 U+003E 的字符 “<code>&gt;</code>”</li></ol></blockquote><h3 id="2、HTML基础代码块"><a href="#2、HTML基础代码块" class="headerlink" title="2、HTML基础代码块"></a>2、HTML基础代码块</h3><blockquote><ol><li>文件应以<code>&lt;!DOCTYPE.....&gt;</code>首行顶格开始，这句话告诉浏览器这是一个什么文件，通常会使用<code>&lt;!DOCTYPE html&gt;</code>。</li><li>必须在head元素内部的meta标签内声明文档的字符编码charset, 如：<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>，这句代码告诉浏览器应该此HTML文件使用的字符集是什么，如果不加此行代码，那么在浏览器中可能显示为乱码</li><li> 页面的title是极为重要的不可缺少的一项。通常用我们编辑器快捷键就能得到(VSCode中敲 <code>!</code>号后按tab 就能补全得到)</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3、HTML代码结构和视觉顺序基本保持一致"><a href="#3、HTML代码结构和视觉顺序基本保持一致" class="headerlink" title="3、HTML代码结构和视觉顺序基本保持一致"></a>3、HTML代码结构和视觉顺序基本保持一致</h3><blockquote><ol><li>按照从上之下，从左到右的视觉顺序书写HTML结构。</li><li>有时候<strong>为了便于搜索引擎抓取</strong>,我们也会将重要内容在HTML结构顺序上提前，因为搜索引擎抓取网页内容是自上而下的，所以将重要内容在HTML结构顺序上提前可便于抓取重要的内容</li><li>不要使用table布局，现在基本上被淘汰了，而应该代之以div来布局，方便控制。</li></ol></blockquote><h3 id="4、结构、表现、行为三者分类，避免内联"><a href="#4、结构、表现、行为三者分类，避免内联" class="headerlink" title="4、结构、表现、行为三者分类，避免内联"></a>4、结构、表现、行为三者分类，避免内联</h3><blockquote><ul><li>使用link引入外部css文件到head中。<strong>注意：一般我们不使用@import来引入外部css文件</strong></li><li>使用script将js文件引入，并置于body底部，这时js文件会最后加载，html会最先加载，用户体验会更好。（注意：并不是所有的js文件都要放置于body的底部，如当我们需要使用js文件动态修改meta元素内容时，需要将js文件引入到head标签中)</li></ul></blockquote><h3 id="5、保持良好的树形结构"><a href="#5、保持良好的树形结构" class="headerlink" title="5、保持良好的树形结构"></a>5、保持良好的树形结构</h3><blockquote><ul><li>每一个块级元素都另起一行，每一行都是用tab缩进对齐。<strong>如果不是块级元素，比如几个行内元素，我们把他写在一行即可。</strong>注意：html、 head、 body ，其他的大都正常缩进</li><li>当然，我们也可以在大的模块之间用空行空开，在模块内不要使用多余的空行,下面为实例</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>努力学习的汪<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML整体结构规范<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>写在一行<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="6、关于使用className的小细节"><a href="#6、关于使用className的小细节" class="headerlink" title="6、关于使用className的小细节"></a>6、关于使用className的小细节</h3><blockquote><p>　　1. 一个标签上引用的className不要过多，越少越好。<br>　　2. 对于一个语义化的内部标签，应该尽量避免使用className</p></blockquote><hr><h2 id="Ⅱ-HTML代码格式"><a href="#Ⅱ-HTML代码格式" class="headerlink" title="Ⅱ - HTML代码格式"></a><strong>Ⅱ - HTML代码格式</strong></h2><h3 id="1、使用小写元素名"><a href="#1、使用小写元素名" class="headerlink" title="1、使用小写元素名"></a>1、使用小写元素名</h3><blockquote><p>HTML5 元素名可以使用大写和小写字母。推荐使用小写字母：</p><blockquote><ul><li>混合了大小写的风格是非常糟糕的。</li><li>开发人员通常使用小写 (类似 XHTML)。</li><li>小写风格看起来更加清爽。</li><li>小写字母容易编写。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 不推荐  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">SECTION</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">SECTION</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">&lt;!-- 非常糟  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">Section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">SECTION</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">&lt;!-- 推荐的  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2、建议关闭所有-HTML-元素"><a href="#2、建议关闭所有-HTML-元素" class="headerlink" title="2、建议关闭所有 HTML 元素"></a>2、建议关闭所有 HTML 元素</h3><blockquote><p>在 HTML5 中, 你不一定要关闭所有元素 (例如 <code>&lt;p&gt;</code>元素)，但我们建议每个元素都要添加关闭标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 不推荐  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。</span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">&lt;!-- 推荐的  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是空的标签,也建议要自闭合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">&gt;//自闭合,建议这么写</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3、使用小写属性名"><a href="#3、使用小写属性名" class="headerlink" title="3、使用小写属性名"></a>3、使用小写属性名</h3><blockquote><p>HTML5 属性名允许使用大写和小写字母。我们推荐使用小写字母属性名:</p><blockquote><ul><li>同时使用大写写是非常不好的习惯。</li><li>开发人员通常使用小写 (类似 XHTML)。</li><li>小写风格看起来更加清爽。</li><li>小写字母容易编写。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 不推荐  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">CLASS</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">&gt;<span class="comment">&lt;!-- 推荐的  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4、属性值"><a href="#4、属性值" class="headerlink" title="4、属性值"></a>4、属性值</h3><blockquote><p>HTML5 属性值可以不用引号。但我们推荐使用引号:</p><blockquote><ul><li>如果属性值含有空格需要使用引号。</li><li>混合风格不推荐的，建议统一风格。</li><li>属性值使用引号易于阅读。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 以下实例属性值包含空格，没有使用引号，所以不能起作用  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">table</span> <span class="attr">striped</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">&gt;<span class="comment">&lt;!-- 以下使用了双引号，是正确的  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table striped&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5、图片属性"><a href="#5、图片属性" class="headerlink" title="5、图片属性"></a>5、图片属性</h3><blockquote><ul><li>图片通常使用 <a href="https://www.w3cschool.cn/htmltags/att-img-alt.html">alt 属性</a>。 在图片不能显示时，它能替代图片显示。</li><li>定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;html5.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;HTML5&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100px;height:100px&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="6、-号前后少用空格和等号"><a href="#6、-号前后少用空格和等号" class="headerlink" title="6、= 号前后少用空格和等号"></a>6、= 号前后少用空格和等号</h3><blockquote><p>等号前后可以使用空格。但我们推荐少用空格 (<strong>与JS不同</strong>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 不推荐  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span> = <span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span> = <span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">&lt;!-- 推荐的  --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="7、避免一行代码过长"><a href="#7、避免一行代码过长" class="headerlink" title="7、避免一行代码过长"></a>7、避免一行代码过长</h3><blockquote><p>使用 HTML 编辑器，左右滚动代码是不方便的。</p><p>每行代码尽量少于 80 个字符。</p></blockquote><h3 id="8、空行和缩进"><a href="#8、空行和缩进" class="headerlink" title="8、空行和缩进"></a>8、空行和缩进</h3><blockquote><ul><li>不要无缘无故添加空行</li><li>为每个逻辑功能块添加空行，这样更易于阅读。</li><li>缩进使用两个空格，不建议使用 <strong>TAB</strong>。</li><li>比较短的代码间不要使用不必要的空行和缩进。</li></ul><blockquote><h6 id="不推荐的-可以看到多余的空行会导致我们阅读困难"><a href="#不推荐的-可以看到多余的空行会导致我们阅读困难" class="headerlink" title="不推荐的:可以看到多余的空行会导致我们阅读困难"></a>不推荐的:可以看到多余的空行会导致我们阅读困难</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML整体结构规范<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>行内<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>好好学习<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>努力学习的汪<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>hongjilin<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>新生代农民工<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="推荐的"><a href="#推荐的" class="headerlink" title="推荐的"></a>推荐的</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML整体结构规范<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span>&gt;</span>行内<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>好好学习<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下方因为是列表,不同功能块,所以也可以加空行,不加也可,建议不加(除非大的功能块)  --&gt;</span>   </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span>   </span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>努力学习的汪<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>hongjilin<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>新生代农民工<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="9、省略-lt-html-gt-和-lt-body-gt"><a href="#9、省略-lt-html-gt-和-lt-body-gt" class="headerlink" title="9、省略 &lt;html&gt; 和 &lt;body&gt; ?"></a>9、省略 <code>&lt;html&gt; </code>和 <code>&lt;body&gt;</code> ?</h3><blockquote><p>在标准 HTML5 中， <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签是可以省略的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 以下 HTML5 文档是正确的--&gt;</span>   </span><br><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="但是不推荐省略-lt-html-gt-和-lt-body-gt-标签。"><a href="#但是不推荐省略-lt-html-gt-和-lt-body-gt-标签。" class="headerlink" title="但是不推荐省略 &lt;html&gt; 和 &lt;body&gt; 标签。"></a>但是<strong>不推荐省略 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 标签。</strong></h6></blockquote><ul><li><html> 元素是文档的根元素，用于描述页面的语言</li><li>声明语言是为了方便屏幕阅读器及搜索引擎。</li><li>省略 <code>&lt;html&gt;</code> 或 <code>&lt;body&gt;</code> 在 DOM 和 XML 软件中会崩溃。</li><li>省略 <code>&lt;body&gt;</code> 在旧版浏览器 (IE9)会发生错误。</li></ul><blockquote><h6 id="在标准-HTML5-中，-lt-head-gt-标签是可以省略的-但是同样建议不省略"><a href="#在标准-HTML5-中，-lt-head-gt-标签是可以省略的-但是同样建议不省略" class="headerlink" title="在标准 HTML5 中， &lt;head&gt;标签是可以省略的,但是同样建议不省略"></a>在标准 HTML5 中， <code>&lt;head&gt;</code>标签是可以省略的,但是同样建议不省略</h6></blockquote><p>默认情况下，浏览器会将 <code>&lt;body&gt;</code> 之前的内容添加到一个默认的 <code>&lt;head&gt;</code> 元素上。</p></blockquote><h3 id="10、元数据"><a href="#10、元数据" class="headerlink" title="10、元数据"></a>10、元数据</h3><blockquote><p>HTML5 中 <code>&lt;title&gt;</code> 元素是必须的，标题名描述了页面的主题:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">title</span>&gt;</span>努力学习的汪的HTML规范代码示范<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标题和语言可以让搜索引擎很快了解你页面的主题:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>努力学习的汪的HTML规范代码示范<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="11、样式表-–-gt-css"><a href="#11、样式表-–-gt-css" class="headerlink" title="11、样式表 –&gt; css"></a>11、样式表 –&gt; css</h3><blockquote><ul><li>将左花括号与选择器放在同一行。</li><li>左花括号与选择器间添加一个空格。</li><li>使用两个空格来缩进。</li><li>冒号与属性值之间添加一个空格。</li><li><strong>逗号和符号之后使用一个空格</strong>。这个基本是约定俗成的了</li><li>每个属性与值结尾都要使用符号。</li><li>只有属性值包含空格时才使用引号。</li><li>右花括号放在新的一行。</li><li>每行最多 80 个字符。</li></ul><blockquote><h6 id="短的规则可以写成一行"><a href="#短的规则可以写成一行" class="headerlink" title="短的规则可以写成一行:"></a>短的规则可以写成一行:</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">p</span><span class="selector-class">.into</span> &#123;<span class="attribute">font-family</span>: Verdana; <span class="attribute">font-size</span>: <span class="number">16em</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="长的规则可以写成多行"><a href="#长的规则可以写成多行" class="headerlink" title="长的规则可以写成多行:"></a>长的规则可以写成多行:</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">body</span> &#123;</span><br><span class="line"> <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line"> <span class="attribute">font-family</span>: <span class="string">&quot;Arial Black&quot;</span>, Helvetica, sans-serif;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">16em</span>;</span><br><span class="line"> <span class="attribute">color</span>: black;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="12、使用小写文件名"><a href="#12、使用小写文件名" class="headerlink" title="12、使用小写文件名"></a>12、使用小写文件名</h3><blockquote><ul><li>大多 Web 服务器 (Apache, Unix) 对大小写敏感：london.jpg 不能通过 London.jpg 访问。</li><li>其他 Web 服务器 (Microsoft, IIS) 对大小写不敏感：london.jpg 可以通过 London.jpg 或 london.jpg 访问。</li><li>你必须保持统一的风格，我们建议统一使用小写的文件名。</li></ul></blockquote><h3 id="13、文件扩展名"><a href="#13、文件扩展名" class="headerlink" title="13、文件扩展名"></a>13、文件扩展名</h3><blockquote><ul><li>HTML 文件后缀可以是 <strong>.html</strong> (或 <strong>.htm</strong>)。</li><li>CSS 文件后缀是 <strong>.css</strong> 。</li><li>JavaScript 文件后缀是 <strong>.js</strong> 。</li></ul></blockquote><h3 id="14、-htm-和-html-的区别"><a href="#14、-htm-和-html-的区别" class="headerlink" title="14、.htm 和 .html 的区别"></a>14、.htm 和 .html 的区别</h3><blockquote><p>.htm 和 .html 的扩展名文件本质上是没有区别的。浏览器和 Web 服务器都会把它们当作 HTML 文件来处理。</p><blockquote><h6 id="大体上区别在于："><a href="#大体上区别在于：" class="headerlink" title="大体上区别在于："></a>大体上区别在于：</h6></blockquote><ul><li>.htm 应用在早期 DOS 系统，系统现在后缀只能有三个字符。</li><li>在 Unix 系统中后缀没有特别限制，一般用 .html。</li></ul><blockquote><h6 id="技术上的区别"><a href="#技术上的区别" class="headerlink" title="技术上的区别"></a>技术上的区别</h6></blockquote><ul><li>如果一个 URL 没有指定文件名 (如 //<a href="http://www.w3cschool.cn/css/">www.w3cschool.cn/css/</a>), 服务器会返回默认的文件名。</li><li>通常默认文件名为 index.html, index.htm, default.html, 和 default.htm。</li><li>如果服务器只配置了 “index.html” 作为默认文件，你必须将文件命名为 “index.html”, 而不是 “index.htm”。</li><li>但是，通常服务器可以设置多个默认文件，你可以根据需要设置默认文件吗。</li><li>不管怎样，HTML 完整的后缀是 “.html”。</li></ul></blockquote><h3 id="语法总结与补充"><a href="#语法总结与补充" class="headerlink" title="语法总结与补充"></a>语法总结与补充</h3><blockquote><ul><li>用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。</li><li>嵌套元素应当缩进一次（即两个空格）。</li><li>对于属性的定义，<strong>尽量使用双引号，不要使用单引号</strong>。</li><li>不要在自闭合（self-closing）元素的尾部添加斜线 – <a href="http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag">HTML5 规范</a>中明确说明这是可选的。</li><li>不要省略可选的结束标签（closing tag）（例如，<code>&lt;/li&gt;</code> 或 <code>&lt;/body&gt;</code>）。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./hong.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;努力学习的汪的头像&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;hello world&quot;</span>&gt;</span>你好!阿汪<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="Ⅲ-HTML-注释规范"><a href="#Ⅲ-HTML-注释规范" class="headerlink" title="Ⅲ - HTML 注释规范"></a><strong>Ⅲ - HTML 注释规范</strong></h2><blockquote><p>这个注释规范每个团队都不一样的,主要团队能互相看得懂即可,这里列举我看到的觉得比较好的规范</p></blockquote><h3 id="1、遵循标准"><a href="#1、遵循标准" class="headerlink" title="1、遵循标准"></a>1、遵循标准</h3><blockquote><p>HTML注释规范写法应该遵循以下标准：</p><ul><li>必须以4个有序字符开始：编码为 U+003C LESS-THAN SIGN 的小于号, 编码为 U+0021 EXCLAMATION MARK 的感叹号, 编码为 U+002D HYPHEN-MINUS 横线, 编码为 U+002D HYPHEN-MINUS横线 ，即 “&lt;!–”</li><li>在此之后是注释内容，注释的内容有以下限制：不能以单个 “&gt;” (U+003E) 字符开始不能以由 “-“（U+002D HYPHEN-MINUS）和 ”&gt;” (U+003E) 组合的字符开始，即 “-&gt;”不能包含两个连续的 U+002D HYPHEN-MINUS 字符，即 “–”不能以一个 U+002D HYPHEN-MINUS 字符结束，即 “-”</li><li>必须以3个有序字符结束：U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN，即 “–&gt;”</li></ul><blockquote><h6 id="标准写法"><a href="#标准写法" class="headerlink" title="标准写法"></a>标准写法</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 这是一个正确的注释 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="错误的写法"><a href="#错误的写法" class="headerlink" title="错误的写法"></a>错误的写法</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!--&gt;这是一个错误的注释 --&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!---&gt;这是第二个错误的注释--&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!--这是--第三个--错误注释--&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!--这是第四个错误注释---&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2、长注释"><a href="#2、长注释" class="headerlink" title="2、长注释"></a>2、长注释</h3><blockquote><p>比较长的评论可以在 <code>&lt;!-- 和 --&gt;</code> 中分行写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 从前有个新生代农民工,他非常努力学习,同时又是一个单身狗</span></span><br><span class="line"><span class="comment"> 所以他叫 努力学习的汪 ~~</span></span><br><span class="line"><span class="comment">&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p>长评论第一个字符缩进两个空格，更易于阅读。</p></blockquote><h3 id="3、单行注释"><a href="#3、单行注释" class="headerlink" title="3、单行注释"></a>3、单行注释</h3><blockquote><ul><li>一般用于简单的描述，如某些状态描述、属性描述等</li><li>本人觉得比较好的习惯就是: 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span> </span><br></pre></td></tr></table></figure></blockquote><h3 id="4、模块注释"><a href="#4、模块注释" class="headerlink" title="4、模块注释"></a>4、模块注释</h3><blockquote><ul><li>一般用于描述模块的名称以及模块开始与结束的位置</li><li>注释内容前后各一个空格字符，<code>&lt;!-- S Comment Text --&gt;</code> 表示模块开始</li><li><code>&lt;!-- E Comment Text --&gt;</code> 表示模块结束，模块与模块之间相隔一行</li></ul><blockquote><h6 id="推荐写法"><a href="#推荐写法" class="headerlink" title="推荐写法"></a>推荐写法</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- S 模块A --&gt;</span>   </span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- E 模块 A --&gt;</span></span><br><span class="line">   </span><br><span class="line">&gt;<span class="comment">&lt;!-- S 模块 B --&gt;</span>   </span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- E 模块 B --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="不推荐写法"><a href="#不推荐写法" class="headerlink" title="不推荐写法"></a>不推荐写法</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- S 模块 A --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- E 模块 A --&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- S 模块 B --&gt;</span>   </span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- E 模块 B --&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5、嵌套模块注释"><a href="#5、嵌套模块注释" class="headerlink" title="5、嵌套模块注释"></a>5、嵌套模块注释</h3><blockquote><p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用 <code>S/E</code> 而是用<code>/</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- S Comment Text --&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- E Comment Text --&gt;</span></span><br><span class="line">&gt;换成下面这样</span><br><span class="line">&gt;<span class="comment">&lt;!-- /Comment Text --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h6 id="注释写在模块结尾标签底部，单独一行。"><a href="#注释写在模块结尾标签底部，单独一行。" class="headerlink" title="注释写在模块结尾标签底部，单独一行。"></a>注释写在模块结尾标签底部，单独一行。</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">       ...</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- /mod_b --&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_c&quot;</span>&gt;</span></span><br><span class="line">       ...</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- /mod_c --&gt;</span>   </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅳ-实用为王"><a href="#Ⅳ-实用为王" class="headerlink" title="Ⅳ - 实用为王"></a><strong>Ⅳ - 实用为王</strong></h2><blockquote><p>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。</p></blockquote><h3 id="1、属性顺序"><a href="#1、属性顺序" class="headerlink" title="1、属性顺序"></a>1、属性顺序</h3><blockquote><p>HTML 属性建议按照以下给出的顺序依次排列，确保代码的易读性</p><ul><li>class</li><li>id, name</li><li>data-*</li><li>src, for, type, href</li><li>title, alt</li><li>aria-*, role</li></ul><p>class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">data-modal</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://gitee.com/hongjilin&quot;</span>&gt;</span></span><br><span class="line"> 点我跳转</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2、布尔（boolean）型属性"><a href="#2、布尔（boolean）型属性" class="headerlink" title="2、布尔（boolean）型属性"></a>2、布尔（boolean）型属性</h3><blockquote><p>布尔型属性可以在声明时不赋值。XHTML 规范要求为其赋值，但是 HTML5 规范不需要。</p><blockquote><ul><li>元素的布尔型属性如果有值，就是 true，如果没有值，就是 false。</li><li><strong>如果一定</strong>要为其赋值的话，请参考 WhatWG 规范：</li><li>如果属性存在，其值必须是空字符串或 […] 属性的规范名称，并且不要再收尾添加空白符。</li></ul></blockquote><p>简单来说就是不用赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">selected</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3、减少标签的数量"><a href="#3、减少标签的数量" class="headerlink" title="3、减少标签的数量"></a>3、减少标签的数量</h3><blockquote><p>编写 HTML 代码时，尽量避免多余的父元素。很多时候，这需要迭代和重构来实现。请看下面的案例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 并不怎么好的写法 --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">&lt;!-- 更好的写法 --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="Ⅴ-W3C-XHTML1-0标准需要留意的几个问题"><a href="#Ⅴ-W3C-XHTML1-0标准需要留意的几个问题" class="headerlink" title="Ⅴ - W3C XHTML1.0标准需要留意的几个问题"></a><strong>Ⅴ - W3C XHTML1.0标准需要留意的几个问题</strong></h2><blockquote><p>前面说了那么多,也不知道看进去了多少. 光说不练假把式,看看下方几个问题你说出几个,也权当是巩固一下知识点</p></blockquote><h3 id="1、在-lt-div-class-hong-gt-My-name-is-努力学习的汪-lt-div-gt-这段语句中有什么错误？"><a href="#1、在-lt-div-class-hong-gt-My-name-is-努力学习的汪-lt-div-gt-这段语句中有什么错误？" class="headerlink" title="1、在 &lt;div class=hong&gt;My name is 努力学习的汪!&lt;/div&gt; 这段语句中有什么错误？"></a>1、在 <code>&lt;div class=hong&gt;My name is 努力学习的汪!&lt;/div&gt;</code> 这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">hong</span>&gt;</span>My name is 努力学习的汪!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>标点符号问题</strong>: 其实也是大家最容易忽略的文艺,实际上就是引号忘了加形成了这个错误.虽然很多浏览器在不加引号的情况加仍然能正确识别渲染.但是想要通过眼里的W3C XHTML国际标准是不可能的 </p><blockquote><h6 id="请大家记住等号后面一定要接引号-下面给出正确写法"><a href="#请大家记住等号后面一定要接引号-下面给出正确写法" class="headerlink" title="请大家记住等号后面一定要接引号,下面给出正确写法"></a>请大家记住等号后面一定要接引号,下面给出正确写法</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hong&quot;</span>&gt;</span>My name is 努力学习的汪!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2、在-lt-SPAN-class-quot-hong-quot-gt-My-name-is-努力学习的汪-lt-SPAN-gt-这段语句中有什么错误？"><a href="#2、在-lt-SPAN-class-quot-hong-quot-gt-My-name-is-努力学习的汪-lt-SPAN-gt-这段语句中有什么错误？" class="headerlink" title="2、在 &lt;SPAN class=&quot;hong&quot;&gt;My name is 努力学习的汪!&lt;/SPAN&gt;这段语句中有什么错误？"></a>2、在 <code>&lt;SPAN class=&quot;hong&quot;&gt;My name is 努力学习的汪!&lt;/SPAN&gt;</code>这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">SPAN</span> <span class="attr">class</span>=<span class="string">&quot;hong&quot;</span>&gt;</span>My name is 努力学习的汪!<span class="tag">&lt;/<span class="name">SPAN</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>大小写问题</strong>: 这与第一个问题是一样的,都是容易忽略的细节误问题. </p><blockquote><h6 id="上面说过-尽量使用小写的元素名-下面给出正确写法"><a href="#上面说过-尽量使用小写的元素名-下面给出正确写法" class="headerlink" title="上面说过,尽量使用小写的元素名,下面给出正确写法"></a>上面说过,<strong>尽量使用小写的元素名</strong>,下面给出正确写法</h6></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hong&quot;</span>&gt;</span>My name is 努力学习的汪!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3、在-lt-p-gt-How-are-you-lt-p-gt-lt-br-gt-lt-p-gt-I-39-m-fine-thanks-lt-p-gt-这段语句中有什么错误？"><a href="#3、在-lt-p-gt-How-are-you-lt-p-gt-lt-br-gt-lt-p-gt-I-39-m-fine-thanks-lt-p-gt-这段语句中有什么错误？" class="headerlink" title="3、在&lt;p&gt;How are you?&lt;/p&gt;&lt;br&gt;&lt;p&gt;I&#39;m fine, thanks.&lt;/p&gt;这段语句中有什么错误？"></a>3、在<code>&lt;p&gt;How are you?&lt;/p&gt;&lt;br&gt;&lt;p&gt;I&#39;m fine, thanks.&lt;/p&gt;</code>这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">p</span>&gt;</span>How are you?<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I&#x27;m fine, thanks.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　<code>&lt;br /&gt;</code>标签问题。对于强制换行标签<code>&lt;br /&gt;</code>来说，很多老手都分不清它和<code>&lt;br&gt;</code>的区别</p></blockquote><h4 id="a-知识点补充-lt-br-gt-与-lt-br-gt-or-lt-br-gt-的区别"><a href="#a-知识点补充-lt-br-gt-与-lt-br-gt-or-lt-br-gt-的区别" class="headerlink" title="a) 知识点补充: &lt;br /&gt;与&lt;br&gt; or &lt;/br&gt;的区别"></a>a) 知识点补充: <code>&lt;br /&gt;</code>与<code>&lt;br&gt; or &lt;/br&gt;</code>的区别</h4><blockquote><ul><li>在早先发布的html规范中<code>&lt;br&gt;</code>/<code>&lt;hr&gt;</code>/<code>&lt;img&gt;</code>等标记元素是无需“封闭自身”的</li><li>这就造成了html规范本身的不严谨，所以后来参考了更规范的XML语言的语法推出了<code>xhtml</code>。</li><li>在xhtml中所有类似br这样的孤立标签都需要自行封闭，具体的做法就是在标签名字的后面跟个“/”，例如<code>&lt;br /&gt;</code>，因此，是没有<code>&lt;/br&gt;</code>这个写法的。</li><li>从逻辑上讲<code>&lt;br /&gt;</code>=<code>&lt;br&gt;</code>…<code>&lt;/br&gt;</code>，这样做的目的是为了尽量减少网页的代码量，同时保持逻辑严谨。</li></ul></blockquote><h4 id="b-知识点补充-HTML-与-XHTML-之间的差异"><a href="#b-知识点补充-HTML-与-XHTML-之间的差异" class="headerlink" title="b) 知识点补充:HTML 与 XHTML 之间的差异"></a>b) 知识点补充:<strong>HTML 与 XHTML 之间的差异</strong></h4><blockquote><ul><li>在 HTML 中，<code>&lt;br&gt;</code> 标签没有结束标签。</li><li>在 XHTML 中，<code>&lt;br&gt;</code> 标签必须被正确地关闭，比如这样：<code>&lt;br /&gt;</code>。</li><li>同时所有浏览器都支持 <code>&lt;br&gt;</code> 标签。因为这是旧版本的写法,虽然不建议了,但仍需要兼容</li></ul></blockquote><h4 id="c-正确写法"><a href="#c-正确写法" class="headerlink" title="c) 正确写法"></a>c) 正确写法</h4><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">p</span>&gt;</span>How are you?<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I&#x27;m fine, thanks.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4、-lt-h1-gt-hey-努力学习的汪-lt-h1-gt-这段语句中有什么错误？"><a href="#4、-lt-h1-gt-hey-努力学习的汪-lt-h1-gt-这段语句中有什么错误？" class="headerlink" title="4、 &lt;h1&gt;~hey~~努力学习的汪~~&lt;/h1&gt; 这段语句中有什么错误？"></a>4、 <code>&lt;h1&gt;~hey~~努力学习的汪~~&lt;/h1&gt;</code> 这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>~hey~~努力学习的汪~~<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>留意标签结束后面接的标点符号，很多标签结束后都不能接特殊标点符号，比如这里的”~”波浪号，那怎样用才对呢？</p><ul><li>那就使用ISO Latin-1字符集（ISO Latin-1 Character Set），在这里，查找到“<del>”波浪号绝对应的字符集十进制编码是</del>，</li><li>然后就用这个十进制编码代替~波浪号，记住最后的分号不能丢。</li><li>在ISO Latin-1字符集中以已命名实体（Named entity）最优先，十进制编码（Decimal code）其次</li><li>也就是说，一个符号在同时有十进制编码和已命名实体的时候，优先选用已命名实体而不使用十进制编码。</li></ul></blockquote><h3 id="5、-在-lt-form-id-quot-999hong-quot-gt-lt-form-gt-这段语句中有什么错误？"><a href="#5、-在-lt-form-id-quot-999hong-quot-gt-lt-form-gt-这段语句中有什么错误？" class="headerlink" title="5、 在 &lt;form id=&quot;999hong&quot;&gt;&lt;/form&gt; 这段语句中有什么错误？"></a>5、 在<code> &lt;form id=&quot;999hong&quot;&gt;&lt;/form&gt;</code> 这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;999hong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>留意id和class特殊情况。W3C XHTML1.0 标准中规定，在id或class中，第一个字符是不能是数字的，必须是字母</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;hong999&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="6、在-lt-img-src-quot-logo-png-quot-gt-这段语句中有什么错误？"><a href="#6、在-lt-img-src-quot-logo-png-quot-gt-这段语句中有什么错误？" class="headerlink" title="6、在 &lt;img src=&quot;logo.png&quot;&gt; 这段语句中有什么错误？"></a>6、在 <code>&lt;img src=&quot;logo.png&quot;&gt; </code>这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签留意。W3C XHTML1.0 标准中规定，在<code>&lt;img&gt;</code>标签中，必须包括 <strong>alt</strong> 元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;hong的图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="7、在-lt-script-language-quot-JavaScript-quot-gt-这段语句中有什么错误？"><a href="#7、在-lt-script-language-quot-JavaScript-quot-gt-这段语句中有什么错误？" class="headerlink" title="7、在&lt;script language=&quot;JavaScript&quot;&gt; 这段语句中有什么错误？"></a>7、在<code>&lt;script language=&quot;JavaScript&quot;&gt;</code> 这段语句中有什么错误？</h3><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;script&gt;</code>标签留意: W3C XHTML1.0 标准中规定，在<code>&lt;script&gt;</code>标签中，必须包括type元素。</li><li>同时建议要闭合</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="8、在-lt-div-gt-lt-h1-gt-My-name-is-努力学习的汪-lt-div-gt-lt-h1-gt-这段语句中有什么错误？"><a href="#8、在-lt-div-gt-lt-h1-gt-My-name-is-努力学习的汪-lt-div-gt-lt-h1-gt-这段语句中有什么错误？" class="headerlink" title="8、在&lt;div&gt;&lt;h1&gt;My name is 努力学习的汪!&lt;/div&gt;&lt;/h1&gt; 这段语句中有什么错误？"></a>8、在<code>&lt;div&gt;&lt;h1&gt;My name is 努力学习的汪!&lt;/div&gt;&lt;/h1&gt; </code>这段语句中有什么错误？</h3><blockquote><p>留意标签开始结束顺序对应嵌套关系,不要乱了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My name is 努力学习的汪!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="9、其他"><a href="#9、其他" class="headerlink" title="9、其他"></a>9、其他</h3><blockquote><ul><li>留意特殊套装:比如：<code>&lt;dl&gt;&lt;dd&gt;&lt;ul&gt;&lt;li&gt;</code>等一些特殊标签，套装顺序中缺一不可。必须按照顺序将<code>&lt;dl&gt;&lt;dd&gt;&lt;ul&gt;&lt;li&gt;</code>四个标签写完全。类似的还有许多。</li><li>留意未打开标签。所谓未打开来自于W3C检测，这类错误显示的错误是 is not open，翻译过来也就是未打开的意思。如果按照中文的意思来理解就是有首无尾或者有尾无首。通常这种错误出现的缘由都是由于有一段代码在修正的时候被删除，而没有顾及到绝对较远的结束或者开始标签。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端代码规范 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序笔记</title>
      <link href="/2022/10/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、初识微信小程序"><a href="#一、初识微信小程序" class="headerlink" title="一、初识微信小程序"></a>一、初识微信小程序</h1><h2 id="1、什么是微信小程序"><a href="#1、什么是微信小程序" class="headerlink" title="1、什么是微信小程序"></a>1、什么是微信小程序</h2><h3 id="Ⅰ-小程序历史"><a href="#Ⅰ-小程序历史" class="headerlink" title="Ⅰ-小程序历史"></a>Ⅰ-小程序历史</h3><blockquote><ol><li>2017 年度百度百科十大热词之一 </li><li>微信小程序，简称小程序，英文名 Mini Program，是一种不需要下载安装即可使用的应用 (<code>张小龙对其的定义是无需安装,用完即走,实际上是需要安装的,只不过小程序的体积特别小,下载速度很快,用户感觉不到下载的过程</code> ) </li><li>小程序刚发布的时候要求压缩包的体积不能大于 1M,，否则无法通过，在2017年4月做了改进，由原来的1M提升到2M；</li><li>2017年1月9日0点，万众瞩目的微信第一批小程序正式低调上线。</li></ol></blockquote><h3 id="Ⅱ-小程序的优势"><a href="#Ⅱ-小程序的优势" class="headerlink" title="Ⅱ-小程序的优势"></a>Ⅱ-小程序的优势</h3><blockquote><ol><li>微信有海量⽤⼾，⽽且粘性很⾼，在微信⾥开发产品更容易触达⽤⼾；</li><li>推⼴app 或公众号的成本太⾼。 </li><li>开发适配成本低。</li><li>容易⼩规模试错，然后快速迭代。</li><li>跨平台。</li></ol></blockquote><h2 id="2、小程序准备"><a href="#2、小程序准备" class="headerlink" title="2、小程序准备"></a>2、小程序准备</h2><h3 id="Ⅰ-环境准备"><a href="#Ⅰ-环境准备" class="headerlink" title="Ⅰ-环境准备"></a>Ⅰ-环境准备</h3><blockquote><ol><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">安装微信小程序开发工具</a>,建议安装稳定版进行开发</p></li><li><p>注册小程序账号</p></li><li><p>使用注册的appid进行使用，如果是测试号会限制很多功能</p></li></ol><p>  在官网<a href="https://mp.weixin.qq.com/">登录</a>成功后可以看到下面的界面，然后复制你的APPID,悄悄的保存起来，<code>不要给别⼈看到</code>😄。<img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210420175717770.png" alt="image-20210420175717770"><img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210420175813507.png" alt="image-20210420175813507"></p></blockquote><h3 id="Ⅱ-新建小程序流程"><a href="#Ⅱ-新建小程序流程" class="headerlink" title="Ⅱ-新建小程序流程"></a>Ⅱ-新建小程序流程</h3><blockquote><ol><li><p>打开开发者工具，第一次打开需要扫码登陆</p></li><li><p>新建小程序项目</p></li></ol>  <img src="微信小程序学习笔记中的图片/image-20210420180254814.png" alt="image-20210420180254814" style="zoom: 80%;" /><ol start="3"><li>填写项目信息</li></ol>  <img src="微信小程序学习笔记中的图片/image-20210420180344226.png" alt="image-20210420180344226" style="zoom:80%;" /><ol start="4"><li>新建成功</li></ol></blockquote><h3 id="Ⅲ-微信开发者工具介绍"><a href="#Ⅲ-微信开发者工具介绍" class="headerlink" title="Ⅲ-微信开发者工具介绍"></a>Ⅲ-微信开发者工具介绍</h3><h4 id="1）开发工具界面图解"><a href="#1）开发工具界面图解" class="headerlink" title="1）开发工具界面图解"></a>1）开发工具界面图解</h4><blockquote><p>详细的使⽤，可以查看<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html">官⽹</a>:</p><p><img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E6%B3%A8%E9%87%8A%E5%9B%BE.png" alt="image-20210420181145002"></p></blockquote><h4 id="2）开发工具的一些基本配置"><a href="#2）开发工具的一些基本配置" class="headerlink" title="2）开发工具的一些基本配置"></a>2）开发工具的一些基本配置</h4><blockquote><ol><li>点击<code>工具栏</code>–&gt;<code>详情</code>–&gt;<code>本地设置</code>，除了默认勾选，需要勾选其他的几个如：增强编译、不校验合法域名…</li></ol><p> <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AF%A6%E6%83%85_%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%E5%9B%BE.png" alt="image-20210420183249939"></p><ol start="2"><li><p>常用快捷键<code>keyMap修改</code>设置(本人习惯记录)：</p><ol><li><p><code>ctrl+P</code>：全局搜索</p></li><li><p><code>alt+/</code>or <code>shift+j</code>:代码提示</p><p><img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210421141701374.png" alt="image-20210421141701374"></p></li></ol></li></ol></blockquote><h3 id="Ⅳ-微信小程序名称或者原始id该如何找回？"><a href="#Ⅳ-微信小程序名称或者原始id该如何找回？" class="headerlink" title="Ⅳ-微信小程序名称或者原始id该如何找回？"></a>Ⅳ-微信小程序名称或者原始id该如何找回？</h3><blockquote><p>问题描述：很久没有进行开发了，小程序的名称跟原始id都忘记了，找回需要先填写,如何解决</p><p>解决：首先<a href="https://developers.weixin.qq.com/community/develop/doc/000ea0f82d4f58b41589642b456809"><code>查询自己的原始id</code></a>,在这个网站能查询到自己的原始id，再通过这个原始id进行找回</p></blockquote><hr><h1 id="二、小程序的基本目录结构与文件作用剖析"><a href="#二、小程序的基本目录结构与文件作用剖析" class="headerlink" title="二、小程序的基本目录结构与文件作用剖析"></a>二、小程序的基本目录结构与文件作用剖析</h1><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html">小程序框架</a>的⽬标是通过尽可能简单、⾼效的⽅式让开发者可以在微信中开发具有原⽣APP体验的服务。 </p><p>⼩程序框架提供了⾃⼰的视图层描述语⾔ <code>WXML 和 WXSS</code> ，以及 JavaScript ，并<code>在视图层与逻辑层间提供了数据传输和事件系统</code>，让开发者能够专注于数据与逻辑。</p></blockquote><h2 id="1、小程序文件结构和传统web对比"><a href="#1、小程序文件结构和传统web对比" class="headerlink" title="1、小程序文件结构和传统web对比"></a>1、小程序文件结构和传统web对比</h2><blockquote><table><thead><tr><th></th><th>传统web</th><th>微信小程序</th></tr></thead><tbody><tr><td>项目骨架、结构</td><td>HTML</td><td>WXML</td></tr><tr><td>页面样式</td><td>CSS</td><td>WXSS</td></tr><tr><td>项目逻辑</td><td>Javascript</td><td>Javascript</td></tr><tr><td>配置</td><td>无</td><td>JSON</td></tr></tbody></table><ol><li><p>通过以上对⽐得出传统web是<code>三层结构</code>。⽽微信⼩程序是<code>四层结构</code>，多了⼀层<code>配置.json</code></p></li><li><p>当这几个文件在同一级目录下且命名相同(后缀不同),可以互相引用却不用导入</p></li></ol></blockquote><h2 id="2、基本的项目目录"><a href="#2、基本的项目目录" class="headerlink" title="2、基本的项目目录"></a>2、基本的项目目录</h2><h3 id="Ⅰ-项目目录解释"><a href="#Ⅰ-项目目录解释" class="headerlink" title="Ⅰ-项目目录解释"></a>Ⅰ-项目目录解释</h3><blockquote><ol><li>项目目录图解:</li></ol> <img src="微信小程序学习笔记中的图片/基本的项目目录图例.png" alt="image-20210420190111436" style="zoom: 67%;" /><ol start="2"><li>以<code>app</code>开头的文件是应用程序级别的文件,更改一处全局生效。而页面<code>pages</code>的配置优先级高于全局配置(<code>就近原则</code>)</li><li>小程序是允许你修改文件目录名的</li></ol></blockquote><h2 id="3、小程序配置文件"><a href="#3、小程序配置文件" class="headerlink" title="3、小程序配置文件"></a>3、小程序配置文件</h2><blockquote><p>⼀个⼩程序应⽤程序会包括最基本的两种配置⽂件。⼀种是全局的app.json 和 ⻚⾯⾃⼰的page.json</p></blockquote><h3 id="Ⅰ-全局配置app-json"><a href="#Ⅰ-全局配置app-json" class="headerlink" title="Ⅰ-全局配置app.json"></a>Ⅰ-<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html">全局配置app.json</a></h3><blockquote><ol><li><p><code>app.json</code> 是当前⼩程序的全局配置，包括了⼩程序的所有⻚⾯路径、界⾯表现、⽹络超时时间、底部tab等。普通快速启动项⽬⾥边的 app.json 配置</p></li><li><p>代码</p></li></ol> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line"> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;window&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;backgroundTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;light&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#fff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WeChat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarTextStyle&quot;</span><span class="punctuation">:</span><span class="string">&quot;black&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>字段的含义</p><p> 1）pages 字段⸺⽤于描述当前⼩程序所有⻚⾯路径，这是为了让微信客⼾端知道当前你的⼩程序⻚⾯定义在哪个⽬录。 </p></li></ol><p>​    <code>默认显示此字段中的第一项</code></p><p>​    2）window 字段⸺定义⼩程序所有⻚⾯的顶部背景颜⾊，⽂字颜⾊定义等。</p><p>​    3）完整的配置信息请参考 app.json配置</p><p>​    4) <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar">tabBar</a>-底部 <code>tab</code> 栏的表现:<br><img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/tabBar_%E5%BA%95%E9%83%A8tab%E6%A0%8F%E7%9A%84%E8%A1%A8%E7%8E%B0%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="image-20210421102125607"></p><p>更多配置详细请看<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html"><code>app配置文档</code></a></p></blockquote><h3 id="Ⅱ-页面配置page-json"><a href="#Ⅱ-页面配置page-json" class="headerlink" title="Ⅱ-页面配置page.json"></a>Ⅱ-<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html">页面配置page.json</a></h3><blockquote><ol><li><p>这⾥的 <code>page.json</code> 其实⽤来表⽰⻚⾯⽬录下的 page.json 这类和⼩程序⻚⾯相关的配置。 开发者可以独⽴定义每个⻚⾯的⼀些属性，如顶部颜⾊、是否允许下拉刷新等等。 ⻚⾯的配置只能设置 app.json 中部分 window 配置项的内容，⻚⾯中配置项会覆盖 app.json 的 window 中相同的配置项。</p></li><li><p>常用配置属性列举:</p></li></ol><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#000000</td><td>导航栏背景颜⾊，如 #000000</td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜⾊，仅⽀持 black / white</td></tr><tr><td>navigationBarTitleText</td><td>String</td><td></td><td>导航栏标题⽂字内容</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>#ffffff</td><td>窗⼝的背景⾊</td></tr><tr><td>backgroundTextStyle</td><td>String</td><td>dark</td><td>下拉<code>loading</code>的样式，仅⽀持 dark / light</td></tr><tr><td>enablePullDownRefresh</td><td>Boolean</td><td>false</td><td>是否全局开启下拉刷新。 详⻅ <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#onpulldownrefresh">Page.onPullDownRefresh</a></td></tr><tr><td>onReachBottomDistance</td><td>Number</td><td>50</td><td>⻚⾯上拉触底事件触发时距⻚⾯底部距离，单位为px。 详⻅ <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#onreachbottom">Page.onReachBottom</a></td></tr><tr><td>disableScroll</td><td>Boolean</td><td>false</td><td>设置为 true 则⻚⾯整体不能上下滚动；只在⻚⾯配置中有效，⽆法在 app.json 中设置该项</td></tr></tbody></table></blockquote><h3 id="Ⅲ-sitemap-配置-了解即可"><a href="#Ⅲ-sitemap-配置-了解即可" class="headerlink" title="Ⅲ-sitemap 配置-了解即可"></a>Ⅲ-<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html">sitemap 配置</a>-了解即可</h3><blockquote><p>⼩程序根⽬录下的 <code>sitemap.json</code> ⽂件⽤于配置⼩程序及其⻚⾯是否允许被微信索引。<code>主要服务于搜索</code></p></blockquote><h2 id="4、小程序框架接口"><a href="#4、小程序框架接口" class="headerlink" title="4、小程序框架接口"></a>4、小程序框架接口</h2><h3 id="Ⅰ-App-Object-object"><a href="#Ⅰ-App-Object-object" class="headerlink" title="Ⅰ-App(Object object)"></a>Ⅰ-App(Object object)</h3><blockquote><ol><li><p>注册小程序。接受一个 <code>Object</code> 参数，其指定小程序的生命周期回调等。</p></li><li><p><strong>App() 必须在 <code>app.js</code> 中调用，必须调用且只能调用一次。不然会出现无法预期的后果</strong></p></li><li><p>相应的app()参数在下方的<code>小程序生命周期中有指出</code></p></li></ol></blockquote><h4 id="AppObject-getApp-Object-object"><a href="#AppObject-getApp-Object-object" class="headerlink" title="AppObject getApp(Object object)"></a><strong>AppObject <code>getApp(Object object)</code></strong></h4><blockquote><ol><li><p>获取到小程序全局唯一的 <code>App</code> 实例。</p></li><li><p>代码示例</p></li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.js</span></span><br><span class="line"><span class="keyword">var</span> appInstance = <span class="title function_">getApp</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(appInstance.<span class="property">globalData</span>) <span class="comment">// I am global dat</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">GbaseUrl</span>&#125; =<span class="title function_">getApp</span>()  <span class="comment">//GbaseUrl是自己在app.js定义的全局变量</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Object object</li></ol><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">allowDefault</td><td align="left">boolean</td><td align="left">false</td><td align="left">否</td><td align="left">在 <code>App</code> 未定义时返回默认实现。当App被调用时，默认实现中定义的属性会被覆盖合并到App中。一般用于<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html">独立分包</a></td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.2.4</a></td></tr></tbody></table><ol start="4"><li>注意</li></ol><ul><li>不要在定义于 <code>App()</code> 内的函数中，或调用 <code>App</code> 前调用 <code>getApp()</code> 。使用 <code>this</code> 就可以拿到 app 实例。</li><li>通过 <code>getApp()</code> 获取实例之后，不要私自调用生命周期函数</li></ul></blockquote><hr><h1 id="三、小程序的基础知识储备"><a href="#三、小程序的基础知识储备" class="headerlink" title="三、小程序的基础知识储备"></a>三、小程序的基础知识储备</h1><blockquote><p>整个小程序学习过程中遇到的 所需基础知识 或 补充知识 将整合至此</p><p>相关知识点本人在<code>一二阶段补缺笔记</code>中有记录,在此便只举例大概,不详细记录</p></blockquote><h2 id="1、Flex-布局"><a href="#1、Flex-布局" class="headerlink" title="1、Flex 布局"></a>1、Flex 布局</h2><h3 id="Ⅰ-基本知识点概念"><a href="#Ⅰ-基本知识点概念" class="headerlink" title="Ⅰ-基本知识点概念"></a>Ⅰ-基本知识点概念</h3><blockquote><ol><li><p>Flex基本概念</p><ol><li><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 </p></li><li><p>任何一个容器都可以指定为 Flex 布局。 </p></li><li><p>display: ‘flex’</p></li></ol></li></ol><p>​    <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210421111211248.png" alt="image-20210421111211248"></p><p>​    4) 这部分是一阶段基础知识,可看<a href="http://www.runoob.com/w3cnote/flex-grammar.html">文档</a>学习</p><ol start="2"><li>在小程序中,通常使用<code>&lt;view/&gt;</code>代替<code>&lt;div/&gt;</code>作为容器来做布局–&gt;代码示例在<code>第一章的第三小节第三点</code></li></ol></blockquote><h3 id="Ⅱ-解决flex布局中-space-between方法的排版问题"><a href="#Ⅱ-解决flex布局中-space-between方法的排版问题" class="headerlink" title="Ⅱ-解决flex布局中 space-between方法的排版问题"></a>Ⅱ-解决flex布局中 space-between方法的排版问题</h3><blockquote><p>详见下方<code>杂记-初学阶段遇到的问题与解决-问题Ⅷ</code></p></blockquote><h2 id="2、移动端相关知识点"><a href="#2、移动端相关知识点" class="headerlink" title="2、移动端相关知识点"></a>2、移动端相关知识点</h2><blockquote><p>自行补充学习,相关知识点本人在<code>一二阶段补缺笔记</code>中有记录,便不再赘述</p></blockquote><h3 id="Ⅰ-物理像素"><a href="#Ⅰ-物理像素" class="headerlink" title="Ⅰ-物理像素"></a>Ⅰ-物理像素</h3><blockquote><ol><li><p>屏幕的分辨率 </p></li><li><p>设备能控制显示的最小单元，可以把物理像素看成是对应的像素点</p></li></ol></blockquote><h3 id="Ⅱ-设备独立像素-、-css-像素"><a href="#Ⅱ-设备独立像素-、-css-像素" class="headerlink" title="Ⅱ-设备独立像素 、 css 像素"></a>Ⅱ-设备独立像素 、 css 像素</h3><blockquote><p>设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的<code>虚拟像素</code>(比如：CSS 像素,只是在 android 机中 CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。 </p></blockquote><h3 id="Ⅲ-dpr比-、DPI-、PPI"><a href="#Ⅲ-dpr比-、DPI-、PPI" class="headerlink" title="Ⅲ-dpr比 、DPI 、PPI"></a>Ⅲ-dpr比 、DPI 、PPI</h3><blockquote><ol><li><p>概念</p><ol><li><p>dpr: 设备像素比，物理像素/设备独立像素 = dpr， 一般以 Iphon6 的 dpr 为准 dpr = 2</p></li><li><p>PPI: 一英寸显示屏上的像素点个数 </p></li><li><p>DPI：最早指的是打印机在单位面积上打印的墨点数，墨点越多越清晰</p></li></ol></li><li><p>不同机型对比表</p></li></ol><p>  <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210508115100483.png" alt="image-20210508115100483"></p><ol start="3"><li>部分机型图示</li></ol>  <img src="微信小程序学习笔记中的图片/image-20210508115306709.png" alt="image-20210508115306709" style="zoom: 80%;" /></blockquote><h2 id="3、移动端适配方案"><a href="#3、移动端适配方案" class="headerlink" title="3、移动端适配方案"></a>3、移动端适配方案</h2><blockquote><p>相关知识点本人在<code>一二阶段补缺笔记</code>中有记录,想详细查阅可以去看,这是个<code>面试考点</code></p></blockquote><h3 id="Ⅰ-viewport-适配"><a href="#Ⅰ-viewport-适配" class="headerlink" title="Ⅰ-viewport 适配"></a>Ⅰ-viewport 适配</h3><blockquote><ol><li><p>为什么做 <code>viewport</code> 适配 ?</p><p>  a) 手机厂商在生产手机的时候大部分手机默认页面宽度为 980px </p><p>  b) 手机实际视口宽度都要小于 980px，如: iphone6 为 750px</p><p>  c) 开发需求需要将 980 的页面完全显示在手机屏幕上且没有滚动条 </p></li><li><p>代码实现</p></li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-rem-适配"><a href="#Ⅱ-rem-适配" class="headerlink" title="Ⅱ- rem 适配"></a>Ⅱ- rem 适配</h3><blockquote><ol><li>为什么做 <code>rem</code> 适配?</li></ol><p>  a) 机型太多,不同的机型屏幕大小不一样 </p><p>  b) 需求：一套设计稿的内容在不同的机型上呈现的效果一致,根据屏幕大小不同的变化,页面中的内容也相应变化</p><ol start="2"><li>原生代码实现:</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">remRefresh</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> clientWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>; </span><br><span class="line"><span class="comment">// 将屏幕等分 10 份</span></span><br><span class="line"><span class="keyword">let</span> rem = clientWidth / <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;12px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">remRefresh</span>()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 函数防抖</span></span><br><span class="line"><span class="keyword">let</span> timeoutId;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">timeoutId &amp;&amp; <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="title function_">remRefresh</span>()</span><br><span class="line">&#125;, <span class="number">300</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>第三方库实现</li></ol><blockquote><p>lib-flexible + px2rem-loader</p></blockquote></blockquote><hr><h1 id="四、视图层详解"><a href="#四、视图层详解" class="headerlink" title="四、视图层详解"></a>四、视图层详解</h1><blockquote><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。</p><p>将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。</p><p>WXML(WeiXin Markup language) 用于描述页面的结构。</p><p>WXS(WeiXin Script) 是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p><p>WXSS(WeiXin Style Sheet) 用于描述页面的样式。</p><p>组件(Component)是视图的基本组成单元。</p><p>该部分将<code>截取官方文档</code>并加以注解</p></blockquote><h2 id="1、WXSS样式文件详解"><a href="#1、WXSS样式文件详解" class="headerlink" title="1、WXSS样式文件详解"></a>1、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">WXSS</a>样式文件详解</h2><blockquote><ol><li><p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p></li><li><p>WXSS 用来决定 WXML 的组件应该怎么显示。</p></li></ol><p>  为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p><ol start="3"><li><p>与 CSS 相比，WXSS 扩展的特性有：</p><ol><li>响应式⻓度单位:即尺寸单位 –&gt;<code>rpx</code></li><li>样式导入</li></ol></li><li><p>注意:</p></li></ol><p>  当页面文件在同一级目录下且命名相同(后缀不同),<code>可以互相引用却不用导入</code></p></blockquote><h3 id="Ⅰ-尺寸单位"><a href="#Ⅰ-尺寸单位" class="headerlink" title="Ⅰ-尺寸单位"></a>Ⅰ-尺寸单位</h3><blockquote><ol><li><code>rpx（responsive pixel）</code>: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 <code>iPhone6</code> 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li></ol><table><thead><tr><th align="left">设备</th><th align="left">rpx换算px (屏幕宽度/750)</th><th align="left">px换算rpx (750/屏幕宽度)</th></tr></thead><tbody><tr><td align="left">iPhone5</td><td align="left">1rpx = 0.42px</td><td align="left">1px = 2.34rpx</td></tr><tr><td align="left">iPhone6</td><td align="left">1rpx = 0.5px</td><td align="left">1px = 2rpx</td></tr><tr><td align="left">iPhone6 Plus</td><td align="left">1rpx = 0.552px</td><td align="left">1px = 1.81rpx</td></tr></tbody></table><ol start="2"><li><p>建议与注意点:</p><ol><li>开发微信小程序时<code>推荐设计师可以用iPhone6作为视觉稿的标准</code>–&gt;即只有在<code>iPhone6</code>标准中才可以<code>一比二换算</code>,更方便</li><li>在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况</li></ol></li></ol></blockquote><h3 id="Ⅱ-样式导⼊"><a href="#Ⅱ-样式导⼊" class="headerlink" title="Ⅱ-样式导⼊"></a>Ⅱ-样式导⼊</h3><blockquote><ol><li>使用<code>@import</code>语句可以导入外联样式表,也可以和less中的导⼊混⽤，<code>@import</code>后跟需要导入的外联样式表的<code>相对路径</code>(只⽀持相对路径)，用<code>;</code>表示语句结束。</li></ol>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** common.wxss **/</span></span><br><span class="line"><span class="selector-class">.small-p</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** app.wxss **/</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;common.wxss&quot;</span>;</span><br><span class="line"><span class="selector-class">.middle-p</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-内联样式"><a href="#Ⅲ-内联样式" class="headerlink" title="Ⅲ-内联样式"></a>Ⅲ-内联样式</h3><blockquote><p>框架组件上支持使用 style、class 属性来控制组件的样式。</p><ol><li><code>style</code>：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;color:&#123;&#123;color&#125;&#125;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>class</code>：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上<code>.</code>，样式类名之间用空格分隔</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;normal_view&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="1-单向简单数据绑定"><a href="#1-单向简单数据绑定" class="headerlink" title="1) 单向简单数据绑定"></a>1) 单向简单数据绑定</h4><blockquote><ol><li><p>此处是单向绑定(数据驱动视图),双向绑定出现的场景如(input等)将在下方<code>四-3、双向绑定</code>处记录</p></li><li><p><code>简单绑定</code>:数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于：</p></li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pages.wxml</span></span><br><span class="line">&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages.js</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello MINA!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>绑定<code>boolean</code>类型(需要在双引号之内)</li></ol><p>  <code>true</code>：boolean 类型的 true，代表真值。<code>false</code>： boolean 类型的 false，代表假值。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;checkbox checked=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt; &lt;/checkbox&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-运算"><a href="#2-运算" class="headerlink" title="2) 运算"></a>2) 运算</h4><blockquote><p>可以在 <code>&#123;&#123;&#125;&#125;</code> 内进行简单的运算，支持的有如下几种方式：</p><ol><li>三元运算</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view hidden=<span class="string">&quot;&#123;&#123;flag ? true : false&#125;&#125;&quot;</span>&gt; <span class="title class_">Hidden</span> &lt;/view&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>算数运算</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt; &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d &lt;/view&gt;</span><br><span class="line"><span class="comment">//view中的内容为 `3 + 3 + d`。</span></span><br><span class="line"><span class="comment">//pages.js</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>逻辑判断</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">if</span>=<span class="string">&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;</span>&gt; &lt;/view&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>字符串运算</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;&#123;&#123;<span class="string">&quot;hello&quot;</span> + name&#125;&#125;&lt;/view&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;<span class="attr">name</span>: <span class="string">&#x27;MINA&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><ol start="5"><li>数据路径运算</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;&#123;&#123;object.<span class="property">key</span>&#125;&#125; &#123;&#123;array[<span class="number">0</span>]&#125;&#125;&lt;/view&gt;</span><br><span class="line"><span class="comment">//view中的内容为 hello  MINA</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">object</span>: &#123;</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;Hello &#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">array</span>: [<span class="string">&#x27;MINA&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-组合"><a href="#3-组合" class="headerlink" title="3) 组合"></a>3) 组合</h4><blockquote><p>也可以在 Mustache 内直接进行组合，构成新的对象或者数组。</p><ol><li>数组 –&gt; 最终组合成数组<code>[0, 1, 2, 3, 4]</code>。</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;[zero, 1, 2, 3, 4]&#125;&#125;&quot;</span>&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">zero</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>对象   –&gt;</p><ol><li><p>最终组合成的对象是 <code>&#123;for: 1, bar: 2&#125;</code> </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">&quot;objectCombine&quot;</span> data=<span class="string">&quot;&#123;&#123;for: a, bar: b&#125;&#125;&quot;</span>&gt;&lt;/template&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>也可以用扩展运算符 <code>...</code> 来将一个对象展开–&gt;最终组合成的对象是 <code>&#123;a: 1, b: 2, c: 3, d: 4, e: 5&#125;</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">&quot;objectCombine&quot;</span> data=<span class="string">&quot;&#123;&#123;...obj1, ...obj2, e: 5&#125;&#125;&quot;</span>&gt;&lt;/template&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">obj1</span>: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    <span class="attr">obj2</span>: &#123; <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果对象的 key 和 value 相同，也可以间接地表达。–&gt;最终组合成的对象是 <code>&#123;foo: &#39;my-foo&#39;, bar:&#39;my-bar&#39;&#125;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">&quot;objectCombine&quot;</span> data=<span class="string">&quot;&#123;&#123;foo, bar&#125;&#125;&quot;</span>&gt;&lt;/template&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;my-foo&#x27;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;my-bar&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>注意</code>：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面 –&gt; 最终组合成的对象是 <code>&#123;a: 5, b: 3, c: 6&#125;</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">&quot;objectCombine&quot;</span> data=<span class="string">&quot;&#123;&#123;...obj1, ...obj2, a, c: 6&#125;&#125;&quot;</span>&gt;&lt;/template&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">obj1</span>: &#123; <span class="attr">a</span>: <span class="number">1</span>,  <span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="attr">obj2</span>: &#123; <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>&#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>注意</code>： 花括号和引号之间如果有空格，将最终被解析成为字符串</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;[1,2,3]&#125;&#125; &quot;</span>&gt;</span><br><span class="line">  &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">等同于</span><br><span class="line">                      </span><br><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;[1,2,3] + &#x27; &#x27;&#125;&#125;&quot;</span>&gt;</span><br><span class="line">  &#123;&#123;item&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><h4 id="4-自定义属性data-的命名与使用"><a href="#4-自定义属性data-的命名与使用" class="headerlink" title="4) 自定义属性data-*的命名与使用"></a>4) 自定义属性<code>data-*</code>的命名与使用</h4><blockquote><ol><li>同一容器中可以存在多个<code>data-*</code></li><li>凡是以<code>data-</code>开头的数据,都会在<code>event的currentTarget</code>中体现,且回缺省<code>data-</code>(data-id  –&gt;  id)</li><li><code>data-*</code>后面接的单词将自动转换 第一个单词首字母小写,第二个及之后的单词首字母大写 (data-post-my-id –&gt; postMyId)</li></ol></blockquote><h3 id="Ⅱ-列表渲染"><a href="#Ⅱ-列表渲染" class="headerlink" title="Ⅱ-列表渲染"></a>Ⅱ-列表渲染</h3><h4 id="1-wx-for"><a href="#1-wx-for" class="headerlink" title="1) wx:for"></a>1) wx:for</h4><blockquote><ol><li><p>在组件上使用 <code>wx:for</code> 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。</p></li><li><p>默认数组的当前项的下标变量名默认为 <code>index</code>，数组当前项的变量名默认为 <code>item</code></p></li><li><p>使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，使用 <code>wx:for-index</code> 可以指定数组当前下标的变量名：</p></li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>-index=<span class="string">&quot;idx&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>-item=<span class="string">&quot;itemName&quot;</span>&gt;</span><br><span class="line">  &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.<span class="property">message</span>&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>wx:for</code> 也可以嵌套，下边是一个九九乘法表</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>-item=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;j&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;i &lt;= j&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-block-wx-for"><a href="#2-block-wx-for" class="headerlink" title="2) block wx:for"></a>2) block wx:for</h4><blockquote><p>类似 <code>block wx:if</code>，也可以将 <code>wx:for</code> 用在<code>&lt;block/&gt;</code>标签上，以渲染一个包含多节点的结构块。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;[1, 2, 3]&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">view</span>&gt;</span> &#123;&#123;index&#125;&#125;: <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">view</span>&gt;</span> &#123;&#123;item&#125;&#125; <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>&lt;block/&gt;</code> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性</p></blockquote><h4 id="3-wx-key"><a href="#3-wx-key" class="headerlink" title="3) wx:key"></a>3) wx:key</h4><blockquote><p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">input</a> 中的输入内容，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/switch.html">switch</a> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p></blockquote><h5 id="①-wx-key-的值以两种形式提供"><a href="#①-wx-key-的值以两种形式提供" class="headerlink" title="① wx:key 的值以两种形式提供"></a>① <code>wx:key</code> 的值以两种形式提供</h5><blockquote><ol><li><p>字符串，代表在for循环的array中<code>item的某个property</code>，该property的值需要是列表中唯一的字符串或数字，且不能动态改变。</p></li><li><p>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个<code>唯一的字符串或者数字</code>。</p></li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;block <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;posts&#125;&#125;&quot;</span>   <span class="attr">wx</span>:key=<span class="string">&quot;id&quot;</span>&gt;&lt;/blocK&gt;</span><br><span class="line"><span class="comment">//id是posts数组中的对象里的一个属性</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="②使用-wx-key-的意义"><a href="#②使用-wx-key-的意义" class="headerlink" title="②使用 wx:key 的意义"></a>②使用 <code>wx:key</code> 的意义</h5><blockquote><p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件<code>，框架会确保他们被重新排序，而不是重新创建</code>，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p><p>如不提供 <code>wx:key</code>，会报一个 <code>warning</code>， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p></blockquote><h4 id="4-列表渲染注意点"><a href="#4-列表渲染注意点" class="headerlink" title="4) 列表渲染注意点"></a>4) 列表渲染注意点</h4><h5 id="①-当-wx-for-的值为字符串时，会将字符串解析成字符串数组"><a href="#①-当-wx-for-的值为字符串时，会将字符串解析成字符串数组" class="headerlink" title="① 当 wx:for 的值为字符串时，会将字符串解析成字符串数组"></a>① 当 <code>wx:for</code> 的值为字符串时，会将字符串解析成字符串数组</h5><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> &#123;&#123;item&#125;&#125;</span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&gt;等同于</span><br><span class="line"></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;[&#x27;a&#x27;,&#x27;r&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;y&#x27;]&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> &#123;&#123;item&#125;&#125;</span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h5 id="②-花括号和引号之间如果有空格，将最终被解析成为字符串"><a href="#②-花括号和引号之间如果有空格，将最终被解析成为字符串" class="headerlink" title="② 花括号和引号之间如果有空格，将最终被解析成为字符串"></a>② 花括号和引号之间如果有空格，将最终被解析成为字符串</h5><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;[1,2,3]&#125;&#125; &quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> &#123;&#123;item&#125;&#125;</span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&gt;等同于</span><br><span class="line"></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;[1,2,3] + &#x27; &#x27;&#125;&#125;&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml"> &#123;&#123;item&#125;&#125;</span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-条件渲染"><a href="#Ⅲ-条件渲染" class="headerlink" title="Ⅲ-条件渲染"></a>Ⅲ-条件渲染</h3><h4 id="1-wx-if"><a href="#1-wx-if" class="headerlink" title="1) wx:if"></a>1) wx:if</h4><blockquote><ol><li>在框架中，使用 <code>wx:if=&quot;&quot;</code> 来判断是否需要渲染该代码块：</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">if</span>=<span class="string">&quot;&#123;&#123;condition&#125;&#125;&quot;</span>&gt; <span class="title class_">True</span> &lt;/view&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以用 <code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块:</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="attr">wx</span>:<span class="keyword">if</span>=<span class="string">&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;</span>&gt; <span class="number">1</span> &lt;/view&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="2-block-wx-if"><a href="#2-block-wx-if" class="headerlink" title="2) block wx:if"></a>2) block wx:if</h4><blockquote><p>因为 <code>wx:if</code> 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用 <code>wx:if</code> 控制属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">view</span>&gt;</span> view1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">view</span>&gt;</span> view2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>&lt;block/&gt;</code> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性</p></blockquote><h4 id="3-wx-if-vs-hidden"><a href="#3-wx-if-vs-hidden" class="headerlink" title="3) wx:if vs hidden"></a>3) <code>wx:if</code> vs <code>hidden</code></h4><blockquote><ol><li><p>因为 <code>wx:if</code> 之中的模板也可能包含数据绑定，所以当 <code>wx:if</code> 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。</p></li><li><p>同时 <code>wx:if</code> 也是<strong>惰性的</strong>，如果在初始渲染条件为 <code>false</code>，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。</p></li></ol><p>  相比之下，<code>hidden</code> 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p><ol start="3"><li>一般来说，<code>wx:if</code> 有更高的切换消耗而 <code>hidden</code> 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 <code>hidden</code> 更好，如果在运行时条件不大可能改变则 <code>wx:if</code> 较好。</li></ol></blockquote><h3 id="Ⅳ-模板"><a href="#Ⅳ-模板" class="headerlink" title="Ⅳ-模板"></a>Ⅳ-模板</h3><blockquote><ol><li><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用</p></li><li><p>模板拥有自己的<code>作用域</code>，只能使用 <code>data</code> 传入的数据以及模板定义文件中定义的 <code>&lt;wxs /&gt;</code> 模块。</p></li></ol></blockquote><h4 id="1-定义模板"><a href="#1-定义模板" class="headerlink" title="1) 定义模板"></a>1) 定义模板</h4><blockquote><p>使用 name 属性，作为模板的名字。然后在<code>&lt;template/&gt;</code>内定义代码片段，如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;!--</span><br><span class="line"> <span class="attr">index</span>: int</span><br><span class="line"> <span class="attr">msg</span>: string</span><br><span class="line"> <span class="attr">time</span>: string</span><br><span class="line">&gt;--&gt;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;msgItem&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">text</span>&gt;</span> &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">text</span>&gt;</span> Time: &#123;&#123;time&#125;&#125; <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="2-使用模板"><a href="#2-使用模板" class="headerlink" title="2) 使用模板"></a>2) 使用模板</h4><blockquote><ol><li>使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如：</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=<span class="string">&quot;msgItem&quot;</span> data=<span class="string">&quot;&#123;&#123;...item&#125;&#125;&quot;</span>/&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">item</span>: &#123; <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;this is a template&#x27;</span>, <span class="attr">time</span>: <span class="string">&#x27;2016-09-15&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=<span class="string">&quot;odd&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span> odd <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;even&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> even <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">&quot;&#123;&#123;item % 2 == 0 ? &#x27;even&#x27; : &#x27;odd&#x27;&#125;&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-引用"><a href="#Ⅴ-引用" class="headerlink" title="Ⅴ-引用"></a>Ⅴ-引用</h3><blockquote><p>WXML 提供两种文件引用方式<code>import</code>和<code>include</code></p></blockquote><h4 id="1-import"><a href="#1-import" class="headerlink" title="1) import"></a>1) import</h4><h5 id="①-使用示例"><a href="#①-使用示例" class="headerlink" title="① 使用示例"></a>① 使用示例</h5><blockquote><ol><li>在 item.wxml 中定义了一个叫<code>item</code>的<code>template</code>：</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- item.<span class="property">wxml</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 index.wxml 中引用了 item.wxml，就可以使用<code>item</code>模板：</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> src=<span class="string">&quot;item.wxml&quot;</span>/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">&quot;item&quot;</span> <span class="attr">data</span>=<span class="string">&quot;&#123;&#123;text: &#x27;forbar&#x27;&#125;&#125;&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h5 id="②-import-的作用域"><a href="#②-import-的作用域" class="headerlink" title="② import 的作用域"></a>② import 的作用域</h5><blockquote><p>import有作用域的概念，即只会 import 目标文件中定义的 template，而不会import目标文件import的template。</p><p>**如：C import B，B import A，在C中可以使用B定义的<code>template</code>，在B中可以使用A定义的<code>template</code>，但是C不能使用A定义的<code>template</code>**。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;!-- A.<span class="property">wxml</span> --&gt;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">text</span>&gt;</span> A template <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&gt;&lt;!-- B.<span class="property">wxml</span> --&gt;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">&quot;a.wxml&quot;</span>/&gt;</span></span></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;B&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">text</span>&gt;</span> B template <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&gt;&lt;!-- C.<span class="property">wxml</span> --&gt;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">&quot;b.wxml&quot;</span>/&gt;</span></span></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">&quot;A&quot;</span>/&gt;</span></span>  &lt;!-- <span class="title class_">Error</span>! <span class="title class_">Can</span> not use tempalte when not <span class="keyword">import</span> A. --&gt;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">&quot;B&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="2-include"><a href="#2-include" class="headerlink" title="2) include"></a>2) include</h4><blockquote><p><code>include</code> 可以将目标文件<strong>除了</strong> <code>&lt;template/&gt;</code> <code>&lt;wxs/&gt;</code> 外的整个代码引入，相当于是拷贝到 <code>include</code> 位置，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.<span class="property">wxml</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">include</span> <span class="attr">src</span>=<span class="string">&quot;header.wxml&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span> body <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">include</span> <span class="attr">src</span>=<span class="string">&quot;footer.wxml&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;!-- header.<span class="property">wxml</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span> header <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;!-- footer.<span class="property">wxml</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span> footer <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="3、双向绑定"><a href="#3、双向绑定" class="headerlink" title="3、双向绑定"></a>3、双向绑定</h2><h3 id="Ⅰ-双向绑定语法"><a href="#Ⅰ-双向绑定语法" class="headerlink" title="Ⅰ-双向绑定语法"></a>Ⅰ-双向绑定语法</h3><blockquote></blockquote><h3 id="Ⅱ-setData–-gt-数据更新"><a href="#Ⅱ-setData–-gt-数据更新" class="headerlink" title="Ⅱ- setData–&gt;数据更新"></a>Ⅱ- <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html"><code>setData</code></a>–&gt;数据更新</h3><blockquote><ol><li><p><code>setData</code> 是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。</p></li><li><p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 <code>evaluateJavascript</code> 所实现。即用户传输的数据，①<code>需要将其转换为字符串形式传递</code>，② <code>同时把转换后的数据内容拼接成一份 JS 脚本</code>，③<code>再通过执行 JS 脚本的形式传递到两边独立环境</code>。</p></li><li><p>而 <code>evaluateJavascript</code> 的执行会受很多方面的影响，数据到达视图层并不是实时的</p></li></ol></blockquote><h4 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1) 简单使用"></a>1) 简单使用</h4><blockquote><p><code>setData</code>可以直接将数据加入data中;如果在data中已经有该值,则修改它有着创建+更新功能  但正常是用来更新</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Page</span>(&#123;</span><br><span class="line">   <span class="attr">data</span>: &#123;<span class="attr">posts</span>: [],<span class="attr">test</span>: <span class="string">&quot;测试数据&quot;</span>,<span class="attr">flag</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">   <span class="comment">//更新</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;<span class="attr">posts</span>: content&#125;)</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-常见的-setData-操作错误"><a href="#2-常见的-setData-操作错误" class="headerlink" title="2) 常见的 setData 操作错误"></a>2) 常见的 setData 操作错误</h4><h5 id="①-频繁的去-setData"><a href="#①-频繁的去-setData" class="headerlink" title="① 频繁的去 setData"></a>① <strong>频繁的去 setData</strong></h5><blockquote><p>在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去<code>setData</code>，其导致了两个后果：</p><ul><li>Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；</li><li>渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；</li></ul></blockquote><h5 id="②-每次-setData-都传递大量新数据"><a href="#②-每次-setData-都传递大量新数据" class="headerlink" title="② 每次 setData 都传递大量新数据"></a>② <strong>每次 setData 都传递大量新数据</strong></h5><blockquote><p>由<code>setData</code>的底层实现可知，我们的数据传输实际是一次 <code>evaluateJavascript</code> 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程，</p></blockquote><h5 id="③-后台态页面进行-setData"><a href="#③-后台态页面进行-setData" class="headerlink" title="③ 后台态页面进行 setData"></a>③ <strong>后台态页面进行 setData</strong></h5><blockquote><p>当页面进入后台态（用户不可见），不应该继续去进行<code>setData</code>，后台态页面的渲染用户是无法感受的，另外后台态页面去<code>setData</code>也会抢占前台页面的执行</p></blockquote><h2 id="4、事件系统"><a href="#4、事件系统" class="headerlink" title="4、事件系统"></a>4、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">事件系统</a></h2><h3 id="Ⅰ-什么是事件"><a href="#Ⅰ-什么是事件" class="headerlink" title="Ⅰ-什么是事件?"></a>Ⅰ-什么是事件?</h3><blockquote><ul><li><code>事件是视图层到逻辑层的通讯方式</code>。</li><li>事件可以将用户的行为反馈到逻辑层进行处理。</li><li>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。</li><li>事件对象可以携带额外信息，如 id, dataset, touches。</li></ul></blockquote><h3 id="Ⅱ-事件分类"><a href="#Ⅱ-事件分类" class="headerlink" title="Ⅱ-事件分类"></a>Ⅱ-事件分类</h3><blockquote><p>事件分为冒泡事件和非冒泡事件：</p><ol><li><p><code>冒泡事件</code>：当一个组件上的事件被触发后，该事件会向父节点传递。</p></li><li><p><code>非冒泡事件</code>：当一个组件上的事件被触发后，该事件不会向父节点传递。</p></li><li><p>WXML的冒泡事件列表：</p></li></ol><table><thead><tr><th align="left">类型</th><th align="left">触发条件</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">touchstart</td><td align="left">手指触摸动作开始</td><td align="left"></td></tr><tr><td align="left">touchmove</td><td align="left">手指触摸后移动</td><td align="left"></td></tr><tr><td align="left">touchcancel</td><td align="left">手指触摸动作被打断，如来电提醒，弹窗</td><td align="left"></td></tr><tr><td align="left">touchend</td><td align="left">手指触摸动作结束</td><td align="left"></td></tr><tr><td align="left">tap</td><td align="left">手指触摸后马上离开</td><td align="left"></td></tr><tr><td align="left">longpress</td><td align="left">手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a></td></tr><tr><td align="left">longtap</td><td align="left">手指触摸后，超过350ms再离开（推荐使用longpress事件代替）</td><td align="left"></td></tr><tr><td align="left">transitionend</td><td align="left">会在 WXSS transition 或 wx.createAnimation 动画结束后触发</td><td align="left"></td></tr><tr><td align="left">animationstart</td><td align="left">会在一个 WXSS animation 动画开始时触发</td><td align="left"></td></tr><tr><td align="left">animationiteration</td><td align="left">会在一个 WXSS animation 一次迭代结束时触发</td><td align="left"></td></tr><tr><td align="left">animationend</td><td align="left">会在一个 WXSS animation 动画完成时触发</td><td align="left"></td></tr><tr><td align="left">touchforcechange</td><td align="left">在支持 3D Touch 的 iPhone 设备，重按时会触发</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.90</a></td></tr></tbody></table><ol start="4"><li><code>注</code>：除上表之外的其他组件自定义事件如无特殊声明<code>都是非冒泡事件</code>，如 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/form.html">form</a> 的<code>submit</code>事件，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">input</a> 的<code>input</code>事件，<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html">scroll-view</a> 的<code>scroll</code>事件，(详见各个<a href="https://developers.weixin.qq.com/miniprogram/dev/component/">组件</a>)</li></ol></blockquote><h3 id="Ⅲ-事件的绑定方式"><a href="#Ⅲ-事件的绑定方式" class="headerlink" title="Ⅲ-事件的绑定方式"></a>Ⅲ-事件的绑定方式</h3><h4 id="1-普通事件绑定-bind-绑定"><a href="#1-普通事件绑定-bind-绑定" class="headerlink" title="1) 普通事件绑定-bind 绑定"></a>1) 普通事件绑定-<code>bind</code> 绑定</h4><blockquote><ol><li>代码示例</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;view bindtap=<span class="string">&quot;tapName&quot;</span> <span class="keyword">class</span>=<span class="string">&#x27;start_container&#x27;</span>&gt;</span><br><span class="line"><span class="comment">//也可以加冒号分隔</span></span><br><span class="line"><span class="comment">//&lt;view bind:tap=&quot;tapName&quot; class=&#x27;start_container&#x27;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&#x27;start&#x27;</span>&gt;</span>开启小程序之旅<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">tapName</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(event)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果用户点击这个 view ，则页面的 <code>tapName</code> 会被调用。</p></li><li><p>此时，页面的 <code>this.data.tapName</code> 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）</p></li><li><p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a> 起，在大多数组件和自定义组件中， <code>bind</code> 后可以紧跟一个冒号，其含义不变，如 <code>bind:tap</code> 。基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.8.1</a> 起，在所有组件中开始提供这个支持。</p></li></ol></blockquote><h4 id="2-绑定并阻止事件冒泡-catch-绑定"><a href="#2-绑定并阻止事件冒泡-catch-绑定" class="headerlink" title="2) 绑定并阻止事件冒泡-catch 绑定:"></a>2) 绑定并阻止事件冒泡-<code>catch</code> 绑定:</h4><blockquote><ol><li><p>除 <code>bind</code> 外，也可以用 <code>catch</code> 来绑定事件。与 <code>bind</code> 不同， <code>catch</code> 会阻止事件向上冒泡。</p></li><li><p>代码示例:</p></li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">&quot;outer&quot;</span> bindtap=<span class="string">&quot;handleTap1&quot;</span>&gt;</span><br><span class="line">  outer view</span><br><span class="line">  &lt;view id=<span class="string">&quot;middle&quot;</span> catchtap=<span class="string">&quot;handleTap2&quot;</span>&gt;</span><br><span class="line">    middle view</span><br><span class="line">    &lt;view id=<span class="string">&quot;inner&quot;</span> bindtap=<span class="string">&quot;handleTap3&quot;</span>&gt;</span><br><span class="line">      inner view</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>例如在上边这个例子中，点击 inner view 会先后调用<code>handleTap3</code>和<code>handleTap2</code>(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发<code>handleTap2</code>，点击 outer view 会触发<code>handleTap1</code>。</li></ol></blockquote><h4 id="3-互斥事件绑定"><a href="#3-互斥事件绑定" class="headerlink" title="3) 互斥事件绑定"></a>3) 互斥事件绑定</h4><blockquote><ol><li><p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.8.2</a> 起，除 <code>bind</code> 和 <code>catch</code> 外，还可以使用 <code>mut-bind</code> 来绑定事件。一个 <code>mut-bind</code> 触发后，如果事件冒泡到其他节点上，其他节点上的 <code>mut-bind</code> 绑定函数不会被触发，但 <code>bind</code> 绑定函数和 <code>catch</code> 绑定函数依旧会被触发。</p></li><li><p>换而言之，所有 <code>mut-bind</code> 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 <code>bind</code> 和 <code>catch</code> 的绑定效果</p></li><li><p>例如在下边这个例子中，点击 inner view 会先后调用 <code>handleTap3</code> 和 <code>handleTap2</code> ，点击 middle view 会调用 <code>handleTap2</code> 和 <code>handleTap1</code> </p></li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">&quot;outer&quot;</span> mut-<span class="attr">bind</span>:tap=<span class="string">&quot;handleTap1&quot;</span>&gt;</span><br><span class="line">  outer view</span><br><span class="line">  &lt;view id=<span class="string">&quot;middle&quot;</span> bindtap=<span class="string">&quot;handleTap2&quot;</span>&gt;</span><br><span class="line">    middle view</span><br><span class="line">    &lt;view id=<span class="string">&quot;inner&quot;</span> mut-<span class="attr">bind</span>:tap=<span class="string">&quot;handleTap3&quot;</span>&gt;</span><br><span class="line">      inner view</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-事件的捕获阶段"><a href="#Ⅳ-事件的捕获阶段" class="headerlink" title="Ⅳ-事件的捕获阶段"></a>Ⅳ-事件的捕获阶段</h3><blockquote><ol><li><p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a> 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段<code>恰好相反</code>。需要在捕获阶段监听事件时，可以采用<code>capture-bind</code>、<code>capture-catch</code>关键字，后者将中断捕获阶段和取消冒泡阶段。</p></li><li><p>在下面的代码中，点击 inner view 会先后调用<code>handleTap2</code>、<code>handleTap4</code>、<code>handleTap3</code>、<code>handleTap1</code></p></li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">&quot;outer&quot;</span> <span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap1&quot;</span> capture-<span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap2&quot;</span>&gt;</span><br><span class="line">  outer view</span><br><span class="line">  &lt;view id=<span class="string">&quot;inner&quot;</span> <span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap3&quot;</span> capture-<span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap4&quot;</span>&gt;</span><br><span class="line">    inner view</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>  如果将上面代码中的第一个capture-bind改为capture-catch，将<code>只触发handleTap2</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">&quot;outer&quot;</span> <span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap1&quot;</span> capture-<span class="attr">catch</span>:touchstart=<span class="string">&quot;handleTap2&quot;</span>&gt;</span><br><span class="line">  outer view</span><br><span class="line">  &lt;view id=<span class="string">&quot;inner&quot;</span> <span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap3&quot;</span> capture-<span class="attr">bind</span>:touchstart=<span class="string">&quot;handleTap4&quot;</span>&gt;</span><br><span class="line">    inner view</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-事件对象"><a href="#Ⅴ-事件对象" class="headerlink" title="Ⅴ-事件对象"></a>Ⅴ-事件对象</h3><blockquote><p>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p></blockquote><h4 id="1-BaseEvent-基础事件对象属性列表"><a href="#1-BaseEvent-基础事件对象属性列表" class="headerlink" title="1) BaseEvent 基础事件对象属性列表"></a>1) <strong>BaseEvent 基础事件对象属性列表</strong></h4><blockquote><ol><li>表格:</li></ol><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th><th align="left">基础库版本</th></tr></thead><tbody><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type">type</a></td><td align="left">String</td><td align="left">代表事件的类型</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp">timeStamp</a></td><td align="left">Integer</td><td align="left">事件生成时的时间戳–页面打开到触发事件所经过的毫秒数</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target">target</a></td><td align="left">Object</td><td align="left">触发事件的组件的一些属性值集合–触发事件的源组件</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget">currentTarget</a></td><td align="left">Object</td><td align="left">当前组件的一些属性值集合–事件绑定的当前组件</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark">mark</a></td><td align="left">Object</td><td align="left">事件标记数据</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.7.1</a></td></tr></tbody></table><ol start="2"><li><p>补充说明</p></li><li><p>target</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">String</td><td align="left">事件源组件的id</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td><td align="left">Object</td><td align="left">事件源组件上由<code>data-</code>开头的自定义属性组成的集合</td></tr></tbody></table></li><li><p>currentTarget</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">String</td><td align="left">当前组件的id</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td><td align="left">Object</td><td align="left">当前组件上由<code>data-</code>开头的自定义属性组成的集合</td></tr></tbody></table><p><code>说明</code>： target 和 currentTarget 可以参考上例中，点击 inner view 时，<code>handleTap3</code> 收到的事件对象 target 和 currentTarget 都是 inner，而 <code>handleTap2</code> 收到的事件对象 target 就是 inner，currentTarget 就是 middle</p></li></ol></blockquote><h4 id="2-TouchEvent-触摸事件对象属性列表（继承-BaseEvent）："><a href="#2-TouchEvent-触摸事件对象属性列表（继承-BaseEvent）：" class="headerlink" title="2) TouchEvent 触摸事件对象属性列表（继承 BaseEvent）："></a>2) <strong>TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：</strong></h4><blockquote><ol><li>表格:</li></ol><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#touches">touches</a></td><td align="left">Array</td><td align="left">触摸事件，当前停留在屏幕中的触摸点信息的数组</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#changedTouches">changedTouches</a></td><td align="left">Array</td><td align="left">触摸事件，当前变化的触摸点信息的数组</td></tr></tbody></table><ol start="2"><li><p>补充说明</p></li><li><p>touches</p><p>touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">identifier</td><td align="left">Number</td><td align="left">触摸点的标识符</td></tr><tr><td align="left">pageX, pageY</td><td align="left">Number</td><td align="left">距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴</td></tr><tr><td align="left">clientX, clientY</td><td align="left">Number</td><td align="left">距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴</td></tr></tbody></table></li><li><p>changedTouches</p><p>changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）</p></li></ol></blockquote><h4 id="3-CustomEvent-自定义事件对象属性列表（继承-BaseEvent）："><a href="#3-CustomEvent-自定义事件对象属性列表（继承-BaseEvent）：" class="headerlink" title="3) CustomEvent 自定义事件对象属性列表（继承 BaseEvent）："></a>3) <strong>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</strong></h4><blockquote><ol><li>表格</li></ol><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#detail">detail</a></td><td align="left">Object</td><td align="left">额外的信息<br />自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见<a href="https://developers.weixin.qq.com/miniprogram/dev/component">组件</a>定义中各个事件的定义。</td></tr></tbody></table></blockquote><hr><h1 id="五、逻辑层详解"><a href="#五、逻辑层详解" class="headerlink" title="五、逻辑层详解"></a>五、逻辑层详解</h1><blockquote><ol><li>原理:小程序开发框架的逻辑层使用 <code>JavaScript</code> 引擎为小程序提供开发者 <code>JavaScript</code> 代码的运行环境以及微信小程序的特有功能。</li></ol><p>  ​    逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p><p>  ​    开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似<a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p><ol start="2"><li>在 <code>JavaScript</code> 的基础上，我们增加了一些功能，以方便小程序的开发：</li></ol><ul><li>增加 <code>App</code> 和 <code>Page</code> 方法，进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html">程序注册</a>和<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html">页面注册</a>。</li><li>增加 <code>getApp</code> 和 <code>getCurrentPages</code> 方法，分别用来获取 <code>App</code> 实例和当前页面栈。</li><li>提供丰富的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html">API</a>，如微信用户数据，扫一扫，支付等微信特有能力。</li><li>提供<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96">模块化</a>能力，每个页面有独立的<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>。</li></ul><p><strong>注意：小程序框架的逻辑层并非运行在浏览器中，因此 <code>JavaScript</code> 在 web 中一些能力都无法使用，如 <code>window</code>，<code>document</code> 等。</strong></p><p>该部分将<code>截取官方文档</code>并加以注解</p></blockquote><h2 id="1、页面路由"><a href="#1、页面路由" class="headerlink" title="1、页面路由"></a>1、页面路由</h2><blockquote><p>在小程序中所有页面的路由全部由框架进行管理</p></blockquote><h3 id="Ⅰ-页面栈与路由方式"><a href="#Ⅰ-页面栈与路由方式" class="headerlink" title="Ⅰ-页面栈与路由方式"></a>Ⅰ-页面栈与路由方式</h3><blockquote><ol><li>框架以<code>栈</code>的形式维护了当前的所有页面。</li><li>对于路由的<code>触发方式</code>以及页面<code>生命周期函数</code>如下：</li></ol><table><thead><tr><th align="left">路由方式</th><th>页面栈表现</th><th align="left">触发时机</th><th align="left">路由前页面</th><th align="left">路由后页面</th></tr></thead><tbody><tr><td align="left">初始化</td><td>新页面入栈</td><td align="left">小程序打开的第一个页面</td><td align="left"></td><td align="left">onLoad, onShow</td></tr><tr><td align="left">打开新页面</td><td>新页面入栈</td><td align="left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo</a> <br />使用组件<navigator open-type="navigateTo"/></td><td align="left">onHide</td><td align="left">onLoad, onShow</td></tr><tr><td align="left">页面重定向</td><td>当前页面出栈，新页面入栈</td><td align="left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html">wx.redirectTo</a> <br />使用组件<navigator open-type="redirectTo"/></td><td align="left">onUnload</td><td align="left">onLoad, onShow</td></tr><tr><td align="left">页面返回</td><td>页面不断出栈，直到目标返回页</td><td align="left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> <br />使用组件<navigator open-type="navigateBack"/> <br />用户按左上角返回按钮</td><td align="left">onUnload</td><td align="left">onShow</td></tr><tr><td align="left">Tab 切换</td><td>页面全部出栈，只留下新的 Tab 页面<br />如果从没有<code>tabBar</code>的页面跳转至有<code>tabBar</code>的页面就<code>一定要用这个</code>,而不是上面的,否则会报错</td><td align="left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">wx.switchTab</a> <br />使用组件<navigator open-type="switchTab"/><br />用户切换 Tab</td><td align="left"></td><td align="left">各种情况请参考下表</td></tr><tr><td align="left">重启动</td><td>页面全部出栈，只留下新的页面</td><td align="left">调用 API <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html">wx.reLaunch</a> <br />使用组件<navigator open-type="reLaunch"/></td><td align="left">onUnload</td><td align="left">onLoad, onShow</td></tr></tbody></table><ol start="2"><li>代码示例:</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123; <span class="comment">//当前页面被隐藏，缓存在栈中，最多存放10个页面</span></span><br><span class="line"><span class="attr">url</span>: <span class="string">&quot;/pages/posts/post&quot;</span> <span class="comment">//跳转的页面路径</span></span><br><span class="line">&#125;)</span><br><span class="line"> wx.<span class="title function_">redirectTo</span>(&#123; <span class="comment">//当前页面被销毁</span></span><br><span class="line"><span class="attr">url</span>: <span class="string">&quot;/pages/posts/post&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：</li></ol><table><thead><tr><th align="left">当前页面</th><th align="left">路由后页面</th><th align="left">触发的生命周期（按顺序）</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">A</td><td align="left">Nothing happend</td></tr><tr><td align="left">A</td><td align="left">B</td><td align="left">A.onHide(), B.onLoad(), B.onShow()</td></tr><tr><td align="left">A</td><td align="left">B（再次打开）</td><td align="left">A.onHide(), B.onShow()</td></tr><tr><td align="left">C</td><td align="left">A</td><td align="left">C.onUnload(), A.onShow()</td></tr><tr><td align="left">C</td><td align="left">B</td><td align="left">C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td align="left">D</td><td align="left">B</td><td align="left">D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td></tr><tr><td align="left">D（从转发进入）</td><td align="left">A</td><td align="left">D.onUnload(), A.onLoad(), A.onShow()</td></tr><tr><td align="left">D（从转发进入）</td><td align="left">B</td><td align="left">D.onUnload(), B.onLoad(), B.onShow()</td></tr></tbody></table></blockquote><h3 id="Ⅱ-Tips"><a href="#Ⅱ-Tips" class="headerlink" title="Ⅱ-Tips"></a>Ⅱ-Tips</h3><blockquote><ul><li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li><li><code>switchTab</code> 只能打开 tabBar 页面。</li><li><code>reLaunch</code> 可以打开任意页面。</li><li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li><li>调用页面路由带的参数可以在目标页面的<code>onLoad</code>中获取。</li><li><code>注意</code>:开发者可以使用 <code>getCurrentPages()</code> 函数获取当前页面栈</li><li>页面栈中最多存在<code>10</code>个</li></ul></blockquote><h2 id="2、模块化"><a href="#2、模块化" class="headerlink" title="2、模块化"></a>2、模块化</h2><blockquote><p>可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html"><code>module.exports</code></a> 或者 <code>exports</code> 才能对外暴露接口。</p></blockquote><hr><h1 id="六、组件与组件库"><a href="#六、组件与组件库" class="headerlink" title="六、组件与组件库"></a>六、组件与组件库</h1><h2 id="1、官方组件"><a href="#1、官方组件" class="headerlink" title="1、官方组件"></a>1、官方组件</h2><blockquote><p>重点举例⼩程序中常⽤的布局组件 view,tex 等,现只举例部分,之后遇到觉得需要mark再写入,大部分可以看<a href="https://developers.weixin.qq.com/miniprogram/dev/component/">官方文档组件部分</a>,便不太多赘述</p></blockquote><h3 id="Ⅰ-view"><a href="#Ⅰ-view" class="headerlink" title="Ⅰ-view"></a>Ⅰ-<a href="https://developers.weixin.qq.com/miniprogram/dev/component/view.html">view</a></h3><blockquote><ol><li>在小程序中,通常使用<code>&lt;view/&gt;</code>代替<code>&lt;div/&gt;</code>作为容器来做布局</li></ol>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--pages/welcome/welcome.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/测试头像图片.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span>&gt;</span>Hello,洪jl<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button&gt;开启小程序之旅&lt;/button&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>开启小程序之旅<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-text"><a href="#Ⅱ-text" class="headerlink" title="Ⅱ-text"></a>Ⅱ-<a href="https://developers.weixin.qq.com/miniprogram/dev/component/text.html">text</a></h3><blockquote><ol><li><p>⽂本标签 </p></li><li><p>只能嵌套text </p></li><li><p>⻓按⽂字可以复制（只有该标签有这个功能）–&gt;selectable</p></li><li><p>可以对如: <code>空格回车&amp;nbsp;</code> 进⾏编码  –&gt;decode</p></li></ol><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>selectable</td><td>Boolean</td><td>false</td><td>⽂本是否可选</td></tr><tr><td>decode</td><td>Boolean</td><td>false</td><td>是否解码</td></tr></tbody></table>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;text selectable=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span> decode=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span>&gt;</span><br><span class="line">   普&amp;nbsp;通</span><br><span class="line"> &lt;/text&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-image"><a href="#Ⅲ-image" class="headerlink" title="Ⅲ-image"></a>Ⅲ-<a href="https://developers.weixin.qq.com/miniprogram/dev/component/image.html">image</a></h3><blockquote><ol><li><p>图⽚标签，image组件<code>默认</code>宽度320px、⾼度240px,所以如果不进行宽高设置,不会进行自适应</p></li><li><p>⽀持懒加载</p></li></ol><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>String</td><td></td><td>图⽚资源地址</td></tr><tr><td>mode</td><td>String</td><td><code>scaleToFill</code></td><td>图⽚裁剪、缩放的模式</td></tr><tr><td>lazy-load</td><td>Boolean</td><td>false</td><td>图⽚懒加载</td></tr></tbody></table><ol start="3"><li><code>mode</code>模式列举:</li></ol><table><thead><tr><th>模式</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>缩放</td><td>scaleToFill</td><td>不保持纵横⽐缩放图⽚，使图⽚的宽⾼完全拉伸⾄填满image 元素</td></tr><tr><td>缩放</td><td>aspectFit</td><td>保持纵横⽐缩放图⽚，使图⽚的⻓边能完全显⽰出来。</td></tr><tr><td>缩放</td><td>aspectFill</td><td>保持纵横⽐缩放图⽚，只保证图⽚的短边能完全显⽰出来</td></tr><tr><td>缩放</td><td>widthFix</td><td>宽度不变，⾼度⾃动变化，保持原图宽⾼⽐不变</td></tr><tr><td>裁剪</td><td>top</td><td>不缩放图⽚，只显⽰图⽚的顶部区域</td></tr><tr><td>裁剪</td><td>bottom</td><td>不缩放图⽚，只显⽰图⽚的底部区域</td></tr><tr><td>裁剪</td><td>center</td><td>不缩放图⽚，只显⽰图⽚的中间区域</td></tr><tr><td>裁剪</td><td>left</td><td>不缩放图⽚，只显⽰图⽚的左边区域</td></tr><tr><td>裁剪</td><td>right</td><td>不缩放图⽚，只显⽰图⽚的右边区域</td></tr><tr><td>裁剪</td><td><code>top left</code>、<code>top right</code><br /><code>bottom left</code>、<code>bottom right</code></td><td>不缩放图⽚,只显示值所指向区域</td></tr></tbody></table><ol start="4"><li>代码示例:</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image <span class="keyword">class</span>=<span class="string">&quot;avatar&quot;</span>  mode=<span class="string">&quot;aspectFit&quot;</span> src=<span class="string">&quot;/images/测试头像图片.jpg&quot;</span>&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>应用场景举例,简单效果对比</p><ol><li><p>使用默认mode效果 –&gt;会将图片进行拉伸,导致图片变形</p><p>  <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210507145239985.png" alt="image-20210507145239985"></p></li><li><p>设置为<code>aspectFill</code>效果 –&gt;保持纵横⽐缩放图⽚，只保证图⽚的短边能完全显⽰出来,图片不会变形</p><p><img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210507145301242.png" alt="image-20210507145301242"></p></li><li><p>根据不同的场景选择不同的<code>mode</code>才是最正确的,就如同该截图场景中,<code>aspectFill</code>明显优于默认</p></li></ol></li></ol></blockquote><h3 id="Ⅳ-swiper"><a href="#Ⅳ-swiper" class="headerlink" title="Ⅳ-swiper"></a>Ⅳ-<a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html">swiper</a></h3><blockquote><p>滑块<code>视图容器</code>。其中只可放置<a href="https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html">swiper-item</a>组件，否则会导致未定义的行为。</p><ol><li>代码示例</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/posts/posts.<span class="property">wxml</span>--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    //1. &quot;false&quot; ==true 普通字符串  </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    //    &quot;&#123;&#123;false&#125;&#125;&quot;==false   &#123;&#123;&#125;&#125;视作运算标记,里面的内容表示表达式 </span></span></span><br><span class="line"><span class="comment"><span class="language-xml">    //2. 当你的属性为true时,可以省略value值-- indicator-dots=&quot;&#123;&#123;true&#125;&#125;&quot; == indicator-dots</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">  --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">indicator-dots</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span> <span class="attr">autoplay</span> <span class="attr">interval</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">duration</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">vertical</span> <span class="attr">circular</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;scaleToFill&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;scaleToFill&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">mode</span>=<span class="string">&quot;scaleToFill&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>该轮播图代码效果预览:<img src="微信小程序学习笔记中的图片/swiper代码轮播图效果预览.gif" style="zoom:50%;" /></li></ol></blockquote><h3 id="Ⅴ-scroll-view"><a href="#Ⅴ-scroll-view" class="headerlink" title="Ⅴ-scroll-view"></a>Ⅴ-<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html">scroll-view</a></h3><blockquote><p>可滚动视图区域。使用竖向滚动时，需要给<a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html">scroll-view</a>一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.4.0</a>起支持传入单位(rpx/px)。</p><ol><li>使用举例图</li></ol><p>  <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210507172539074.png" alt="image-20210507172539074"></p></blockquote><h2 id="2、LinUi组件库"><a href="#2、LinUi组件库" class="headerlink" title="2、LinUi组件库"></a>2、<a href="https://doc.mini.talelin.com/">LinUi</a>组件库</h2><h3 id="Ⅰ-安装与使用"><a href="#Ⅰ-安装与使用" class="headerlink" title="Ⅰ-安装与使用"></a>Ⅰ-安装与使用</h3><blockquote><ol><li><p><code>Lin UI</code> 是基于 <strong>微信小程序原生语法</strong> 实现的组件库。遵循简洁，易用的设计规范。</p></li><li><p>与其他组件库不同的是，除了提供基本的组件外，还会提供 <code>wxs模块</code> 、<code>高级组件</code> 、 <code>电商组件模块</code> 等等。 例如，在电商项目里常用的 <code>SKU联动选择</code> ，<code>城市选择器</code> 等</p></li><li><p><a href="https://doc.mini.talelin.com/start/"><code>安装</code></a>过程可看官方文档:</p></li></ol><ol><li>打开小程序的项目根目录，执行下面的命令（如果使用了云开发，需要进入miniprogram文件夹下执行下面的命令）</li></ol> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">/*注意事项</span><br><span class="line">1.执行npm init进行初始化，此时会生成一个package.json文件，如果不进行npm init，在构建npm的时候会报一个错误：没有找到 node_modules 目录</span><br><span class="line">2.不建议使用cnpm，这样会带来一些未知的错误。如果网络情况不佳，可以使用下面的命令行更换为淘宝源。</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org */</span><br></pre></td></tr></table></figure><p> 2)继续执行下面的命令</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lin-ui</span><br></pre></td></tr></table></figure><ol start="4"><li>安装完成后在小程序需要点击<code>工具</code>–&gt;<code>构建 npm</code>才可以使用(<code>所有npm引入的都需要这一步</code>)</li><li>要使用<code>自定义组件</code>的话,需要在<code>配置.json</code>文件中(可以在全局的也可以在页面的,作用域不同)注册,具体实现看下面示例</li></ol></blockquote><h3 id="Ⅱ-avatar头像"><a href="#Ⅱ-avatar头像" class="headerlink" title="Ⅱ-avatar头像"></a>Ⅱ-<a href="https://doc.mini.talelin.com/component/view/avatar.html">avatar</a>头像</h3><blockquote><ol><li>要使用<code>自定义组件</code>的话,需要在当前page页面.json文件中注册</li></ol> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;l-avatar&quot;</span><span class="punctuation">:</span><span class="string">&quot;/miniprogram_npm/lin-ui/avatar/index&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;组件名(可以自取,一般如果是linui,就l-xxx)&quot;</span><span class="punctuation">:</span><span class="string">&quot;构建后的路径--要具体到那个文件夹下的js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用:</li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/welcome/welcome.<span class="property">wxml</span>--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- &lt;image class=&quot;avatar&quot; lazy-load=&quot;true&quot; mode=&quot;aspectFit&quot; src=&quot;/images/测试头像图片.jpg&quot;&gt;&lt;/image&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">l-avatar</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> <span class="attr">class</span>=<span class="string">&quot;l-avatar&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> <span class="attr">placement</span>=<span class="string">&quot;bottom&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> <span class="attr">open-data</span>=<span class="string">&quot;&#123;&#123;[&#x27;userAvatarUrl&#x27;,&#x27;userNickName&#x27;]&#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> <span class="attr">size</span>=<span class="string">&quot;200&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pages/welcome/welcome.wxss */</span></span><br><span class="line"><span class="comment">//可以自己写样式类,加到组件上</span></span><br><span class="line">.<span class="property">l</span>-avatar&#123;</span><br><span class="line">  margin-<span class="attr">top</span>: 160rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-icon"><a href="#Ⅲ-icon" class="headerlink" title="Ⅲ-icon"></a>Ⅲ-icon</h3><blockquote><ol><li>在当前page页面.json文件中注册</li></ol>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;l-icon&quot;</span><span class="punctuation">:</span><span class="string">&quot;/miniprogram_npm/lin-ui/icon/index&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;l-icon size=<span class="string">&quot;20&quot;</span> color=<span class="string">&quot;#34bfa3&quot;</span> name=<span class="string">&quot;cart&quot;</span>&gt;&lt;/l-icon&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">l-icon</span> <span class="attr">name</span>=<span class="string">&quot;research&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">l-icon</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="七、小程序API"><a href="#七、小程序API" class="headerlink" title="七、小程序API"></a>七、小程序<a href="https://developers.weixin.qq.com/miniprogram/dev/api/">API</a></h1><h2 id="1、数据缓存"><a href="#1、数据缓存" class="headerlink" title="1、数据缓存"></a>1、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html">数据缓存</a></h2><blockquote><p>类似于网页的<code>localStorage</code></p><p>官方文档很详细,此处给出具体地址,翻阅文档即可</p></blockquote><h2 id="2、交互"><a href="#2、交互" class="headerlink" title="2、交互"></a>2、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html">交互</a></h2><blockquote><p>一些微信官方给出的组件,具体参数解释看文档,以下给出学习过程中代码示例</p></blockquote><h3 id="Ⅰ-wx-showToast与wx-showModal"><a href="#Ⅰ-wx-showToast与wx-showModal" class="headerlink" title="Ⅰ-wx.showToast与wx.showModal"></a>Ⅰ-wx.showToast与wx.showModal</h3><blockquote><ol><li><code>wx.showToast</code>代码示例:</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">    <span class="comment">//此处其实已经被修改完状态,才开始提示,所以要反过来</span></span><br><span class="line">    <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;收藏成功&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>wx.showModal</code>代码示例:</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">onCollect</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>:  !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;进行收藏&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!result.<span class="property">confirm</span>) <span class="keyword">return</span>; <span class="comment">//点击取消退出</span></span><br><span class="line">   .......<span class="comment">//点击确认后运行的代码</span></span><br><span class="line">    wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">    <span class="comment">//此处其实已经被修改完状态,才开始提示,所以要反过来</span></span><br><span class="line">    <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;收藏成功&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol start="3"><li>运行效果示例(两者并存的效果):<img src="微信小程序学习笔记中的图片/showToas与showModal运行效果图.gif" style="zoom:67%;" /></li></ol></blockquote><h2 id="3、媒体"><a href="#3、媒体" class="headerlink" title="3、媒体"></a>3、媒体</h2><h3 id="Ⅰ-媒体音乐播放"><a href="#Ⅰ-媒体音乐播放" class="headerlink" title="Ⅰ-媒体音乐播放"></a>Ⅰ-<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html">媒体音乐播放</a></h3><blockquote><ol><li><p>wx.getBackgroundAudioManager–播放音乐</p></li><li><p>代码示例</p></li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">getApp</span>() <span class="comment">//此处keyi </span></span><br><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mgr = wx.<span class="title function_">getBackgroundAudioManager</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_mgr</span> = mgr</span><br><span class="line">    <span class="comment">// if(app.gIsPlayMusic) &#123;  此处进入即默认播放</span></span><br><span class="line">    <span class="comment">//   mgr.src = this.data.postData.music.url</span></span><br><span class="line">    <span class="comment">//   mgr.title = this.data.postData.music.title</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    mgr.<span class="title function_">onPlay</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听播放&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    mgr.<span class="title function_">onPause</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;监听暂停&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 音乐播放</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onMusic</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mgr = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_mgr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isPlaying</span>) &#123;</span><br><span class="line">      mgr.<span class="title function_">pause</span>()</span><br><span class="line">      app.<span class="property">gIsPlayMusicId</span> = -<span class="number">1</span></span><br><span class="line">    &#125; <span class="comment">//当前播放状态如果为true则终止(stop())、pause()暂停</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      mgr.<span class="property">src</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">postData</span>.<span class="property">music</span>.<span class="property">url</span>  <span class="comment">//此处为播放</span></span><br><span class="line">      mgr.<span class="property">title</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">postData</span>.<span class="property">music</span>.<span class="property">title</span></span><br><span class="line">      app.<span class="property">gIsPlayMusicId</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_pid</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">isPlaying</span>: !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isPlaying</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-图片"><a href="#Ⅱ-图片" class="headerlink" title="Ⅱ-图片"></a>Ⅱ-<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.saveImageToPhotosAlbum.html">图片</a></h3><h4 id="1-wx-previewImage-Object-object"><a href="#1-wx-previewImage-Object-object" class="headerlink" title="1) wx.previewImage(Object object)"></a>1) <a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html">wx.previewImage(Object object)</a></h4><blockquote><p>在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作</p><ol><li><p>代码示例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/movie-detail/movie-detail.<span class="property">wxml</span>--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">image</span> <span class="attr">catch:tap</span>=<span class="string">&quot;onViewPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;movie-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;movie.images&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span></span><br><span class="line"><span class="comment">// pages/movie-detail/movie-detail.js</span></span><br><span class="line"><span class="title function_">onViewPost</span>(<span class="params">e</span>) &#123; <span class="comment">//相册功能(预览)</span></span><br><span class="line">    wx.<span class="title function_">previewImage</span>(&#123;</span><br><span class="line">      <span class="attr">urls</span>: [images1,images2],</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><p>详见开发文档</p></li></ol></blockquote><h2 id="4、界面"><a href="#4、界面" class="headerlink" title="4、界面"></a>4、界面</h2><h3 id="Ⅰ-Tab-Bar"><a href="#Ⅰ-Tab-Bar" class="headerlink" title="Ⅰ-Tab Bar"></a>Ⅰ-<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">Tab Bar</a></h3><blockquote><p>使用时在<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html">app.json</a>中进行配置即可,相关配置详情看全局配置文档,如果需要进行相应操作看官方文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attr">&quot;tabBar&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;selectedColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#333333&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#999999&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;borderStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="string">&quot;top&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">     <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/posts/posts&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;阅读&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/tabBar/yuedu.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/tabBar/yuedu_1.png&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/movies/movies&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;电影&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/tabBar/dianying_1.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/tabBar/dianying.png&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="八、小程序生命周期"><a href="#八、小程序生命周期" class="headerlink" title="八、小程序生命周期"></a>八、小程序生命周期</h1><blockquote><p>分为<code>应⽤⽣命周期</code>和<code>⻚⾯⽣命周期</code></p><p>关于小程序前后台的定义和小程序的运行机制，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html">运行机制</a>章节。</p></blockquote><h2 id="1、应用生命周期"><a href="#1、应用生命周期" class="headerlink" title="1、应用生命周期"></a>1、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html">应用生命周期</a></h2><blockquote><ol><li>应用生命周期表</li></ol><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th><th>场景</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object">onLaunch</a></td><td align="left">function</td><td align="left">否</td><td align="left">生命周期回调——监听小程序初始化。</td><td>小程序初始化完成时触发，全局只触发一次。参数也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html">wx.getLaunchOptionsSync</a> 获取。</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onShow-Object-object">onShow</a></td><td align="left">function</td><td align="left">否</td><td align="left">生命周期回调——监听小程序启动或切前台。</td><td>小程序启动，或从后台进入前台显示时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html">wx.onAppShow</a> 绑定监听</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onHide">onHide</a></td><td align="left">function</td><td align="left">否</td><td align="left">生命周期回调——监听小程序切后台。</td><td>小程序从前台进入后台时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppHide.html">wx.onAppHide</a> 绑定监听</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onError-String-error">onError</a></td><td align="left">function</td><td align="left">否</td><td align="left">错误监听函数。</td><td>小程序发生脚本错误或 API 调用报错时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onError.html">wx.onError</a> 绑定监听</td><td align="left"></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onPageNotFound-Object-object">onPageNotFound</a></td><td align="left">function</td><td align="left">否</td><td align="left">页面不存在监听函数。</td><td>小程序要打开的页面不存在时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html">wx.onPageNotFound</a> 绑定监听。</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.90</a></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onUnhandledRejection-Object-object">onUnhandledRejection</a></td><td align="left">function</td><td align="left">否</td><td align="left">未处理的 Promise 拒绝事件监听函数。</td><td>小程序有未处理的 Promise 拒绝时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html">wx.onUnhandledRejection</a> 绑定监听</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.0</a></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onThemeChange-Object-object">onThemeChange</a></td><td align="left">function</td><td align="left">否</td><td align="left">监听系统主题变化</td><td>系统切换主题时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onThemeChange.html">wx.onThemeChange</a> 绑定监听</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.11.0</a></td></tr><tr><td align="left">其他</td><td align="left">any</td><td align="left">否</td><td align="left">开发者可以添加任意的函数或数据变量到 <code>Object</code> 参数中，用 <code>this</code> 可以访问</td><td></td><td align="left"></td></tr></tbody></table><ol start="2"><li>代码示例:</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">  onLaunch (options) &#123;</span><br><span class="line">    <span class="comment">// Do something initial when launch.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onShow (options) &#123;</span><br><span class="line">    <span class="comment">// Do something when show.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    <span class="comment">// Do something when hide.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  onError (msg) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">globalData</span>: <span class="string">&#x27;I am global data&#x27;</span></span><br><span class="line">  ,</span><br><span class="line">  <span class="title function_">onPageNotFound</span>(<span class="params">res</span>) &#123;</span><br><span class="line">  wx.<span class="title function_">redirectTo</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;pages/...&#x27;</span></span><br><span class="line">  &#125;) <span class="comment">// 如果是 tabbar 页面，请使用 wx.switchTab</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h2 id="2、页面生命周期"><a href="#2、页面生命周期" class="headerlink" title="2、页面生命周期"></a>2、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html">页面生命周期</a></h2><blockquote><ol><li>页面生命周期表</li></ol><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#data">data</a></td><td align="left">Object</td><td align="left">页面的初始数据</td></tr><tr><td align="left">options</td><td align="left">Object</td><td align="left">页面的组件选项，同 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html"><code>Component</code> 构造器</a> 中的 <code>options</code> ，需要基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.1</a></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query">onLoad</a></td><td align="left">function</td><td align="left">生命周期回调—监听页面加载</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShow">onShow</a></td><td align="left">function</td><td align="left">生命周期回调—监听页面显示</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onReady">onReady</a></td><td align="left">function</td><td align="left">生命周期回调—监听页面初次渲染完成</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onHide">onHide</a></td><td align="left">function</td><td align="left">生命周期回调—监听页面隐藏</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onUnload">onUnload</a></td><td align="left">function</td><td align="left">生命周期回调—监听页面卸载</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onPullDownRefresh">onPullDownRefresh</a></td><td align="left">function</td><td align="left">监听用户下拉动作</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onReachBottom">onReachBottom</a></td><td align="left">function</td><td align="left">页面上拉触底事件的处理函数</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareAppMessage-Object-object">onShareAppMessage</a></td><td align="left">function</td><td align="left">用户点击右上角转发</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareTimeline">onShareTimeline</a></td><td align="left">function</td><td align="left">用户点击右上角转发到朋友圈</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onAddToFavorites-Object-object">onAddToFavorites</a></td><td align="left">function</td><td align="left">用户点击右上角收藏</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onPageScroll-Object-object">onPageScroll</a></td><td align="left">function</td><td align="left">页面滚动触发事件的处理函数</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onResize-Object-object">onResize</a></td><td align="left">function</td><td align="left">页面尺寸改变时触发，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html#%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E5%90%AF%E7%94%A8%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E6%94%AF%E6%8C%81">响应显示区域变化</a></td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onTabItemTap-Object-object">onTabItemTap</a></td><td align="left">function</td><td align="left">当前是 tab 页时，点击 tab 时触发</td></tr><tr><td align="left">其他</td><td align="left">any</td><td align="left">开发者可以添加任意的函数或数据到 <code>Object</code> 参数中，在页面的函数中用 <code>this</code> 可以访</td></tr></tbody></table><ol start="2"><li>官方的小程序页面生命周期图:</li></ol>  <img src="微信小程序学习笔记中的图片/官方的小程序页面生命周期图.png" alt="image-20210425142044724" style="zoom:80%;" /></blockquote><h2 id="3、组件生命周期-不算在小程序生命周期中"><a href="#3、组件生命周期-不算在小程序生命周期中" class="headerlink" title="3、组件生命周期-不算在小程序生命周期中"></a>3、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html">组件生命周期</a>-不算在小程序生命周期中</h2><blockquote><p>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发</p></blockquote><hr><h1 id="九、自定义组件"><a href="#九、自定义组件" class="headerlink" title="九、自定义组件"></a>九、<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/">自定义组件</a></h1><blockquote><p>开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似</p><p>这部分将截取<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">文档自定义组件部分</a>中常见的部分进行注解</p></blockquote><h2 id="1、组件模板和样式"><a href="#1、组件模板和样式" class="headerlink" title="1、组件模板和样式"></a>1、组件模板和样式</h2><blockquote><p>类似于页面，自定义组件拥有自己的 <code>wxml</code> 模板和 <code>wxss</code> 样式。</p></blockquote><h3 id="Ⅰ-组件样式"><a href="#Ⅰ-组件样式" class="headerlink" title="Ⅰ-组件样式"></a>Ⅰ-组件样式</h3><blockquote><p>组件对应 <code>wxss</code> 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：</p><ul><li><p>组件和引用组件的页面不能使用id选择器（<code>#a</code>）、属性选择器（<code>[a]</code>）和标签名选择器，请改用class选择器。</p></li><li><p>组件和引用组件的页面中使用后代选择器（<code>.a .b</code>）在一些极端情况下会有非预期的表现，如遇，请避免使用。</p></li><li><p>子元素选择器（<code>.a&gt;.b</code>）只能用于 <code>view</code> 组件与其子节点之间，用于其他组件可能导致非预期的情况。</p></li><li><p>继承样式，如 <code>font</code> 、 <code>color</code> ，会从组件外继承到组件内。</p></li><li><p>除继承样式外， <code>app.wxss</code> 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。</p></li></ul> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#a</span> &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line"><span class="selector-attr">[a]</span> &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line"><span class="selector-tag">button</span> &#123; &#125; <span class="comment">/* 在组件中不能使用 */</span></span><br><span class="line"><span class="selector-class">.a</span> &gt; <span class="selector-class">.b</span> &#123; &#125; <span class="comment">/* 除非 .a 是 view 组件节点，否则不一定会生效 */</span></span><br></pre></td></tr></table></figure><p>除此以外，组件可以指定它所在节点的默认样式，使用 <code>:host</code> 选择器（需要包含基础库 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.7.2</a> 或更高版本的开发者工具支持）。</p><p>注:此处本人出了一个<code>问题</code>,详见—&gt;本笔记的<code>杂记-&gt;初学者阶段遇到的问题与解决-&gt;Ⅶ</code></p></blockquote><h3 id="Ⅱ-外部样式类"><a href="#Ⅱ-外部样式类" class="headerlink" title="Ⅱ-外部样式类"></a>Ⅱ-外部样式类</h3><blockquote><ol><li>有时，组件希望接受外部传入的样式类。此时可以在 <code>Component</code> 中用 <code>externalClasses</code> 定义段定义若干个外部样式类。这个特性可以用于实现类似于 <code>view</code> 组件的 <code>hover-class</code> 属性：页面可以提供一个样式类，赋予 <code>view</code> 的 <code>hover-class</code> ，这个样式类本身写在页面中而非 <code>view</code> 组件的实现中。</li></ol><p> <strong>注意：在同一个节点上使用普通样式类和外部样式类时，两个类的<code>优先级是未定义</code>的，因此最好避免这种情况。</strong></p><ol start="2"><li><p><strong>代码示例：</strong></p><ol><li><p>自定义组件部分定义与占位符示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 组件 custom-component.js */</span><br><span class="line">Component(&#123;</span><br><span class="line">  externalClasses: [&#x27;my-class&#x27;]</span><br><span class="line">&#125;)</span><br><span class="line">                                                                  </span><br><span class="line">&lt;!-- 组件 custom-component.wxml 如何引用 --&gt;</span><br><span class="line">&lt;custom-component class=&quot;my-class&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/custom-component&gt;                                 </span><br></pre></td></tr></table></figure><p>这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.7.1</a> 之后，可以指定多个对应的 class 。</p></li></ol></li><li><p>外部使用自定义组件并传入样式类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面的 WXML --&gt;</span><br><span class="line">&lt;custom-component my-class=&quot;red-text&quot; /&gt;</span><br><span class="line">&lt;custom-component my-class=&quot;large-text&quot; /&gt;</span><br><span class="line">&lt;!-- 以下写法需要基础库版本 2.7.1 以上  注意 这只是一个组件传入两个类名,而不是分别创建两个组件--&gt;</span><br><span class="line">&lt;custom-component my-class=&quot;red-text large-text&quot; /&gt;</span><br><span class="line">                                                                                                              </span><br><span class="line">------------ 样式类声明 页面.wxss ---------------------------------</span><br><span class="line">.red-text &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.large-text &#123;</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主要用途:</p><ol><li><p>如果子组件都是我们自己开发的,而且无所谓改动自定义组件源码,那可以不使用这个</p></li><li><p>如果自定义组件封装已经足够成熟,不想再动其中样式源码,就可以用外部样式类进行对自定义组件样式改变(使用<code>!important</code>属性能将样式优先级提高),以此进行对于封装好的组件的样式修改,同理可以运用于第三方库</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.movielist</span>&#123; //外部样式类</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">25</span>rpx;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;  //此处就可以将这个样式提升到自定义组件样式优先级之上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>以后如果自己封装自定义组件,就可以向外暴露外部样式类</p></li></ol></blockquote><h2 id="2、组件间通信与事件"><a href="#2、组件间通信与事件" class="headerlink" title="2、组件间通信与事件"></a>2、组件间通信与事件</h2><h3 id="Ⅰ-组件间通信"><a href="#Ⅰ-组件间通信" class="headerlink" title="Ⅰ-组件间通信"></a>Ⅰ-组件间通信</h3><blockquote><p>组件间的基本通信方式有以下几种。</p><ul><li>WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.0.9</a> 开始，还可以在数据中包含函数）。具体在 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">组件模板和样式</a> 章节中介绍。</li><li>事件：用于子组件向父组件传递数据，可以传递任意数据。</li><li>如果以上两种方式不足以满足需要，父组件还可以通过 <code>this.selectComponent</code> 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。</li></ul></blockquote><h3 id="Ⅱ-触发事件"><a href="#Ⅱ-触发事件" class="headerlink" title="Ⅱ-触发事件"></a>Ⅱ-触发事件</h3><blockquote><p>自定义组件触发事件时，需要使用 <code>triggerEvent</code> 方法，指定事件名、detail对象和事件选项</p><ol><li>官方代码示例</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在自定义组件中 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;onTap&quot;</span>&gt;</span>点击这个按钮将触发“myevent”事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">//js文件中</span></span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">properties</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">onTap</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> myEventDetail = &#123;&#125; <span class="comment">// detail对象，提供给事件监听函数</span></span><br><span class="line">      <span class="keyword">var</span> myEventOption = &#123;&#125; <span class="comment">// 触发事件的选项</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;myevent&#x27;</span>, myEventDetail, myEventOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>本人在<a href="https://gitee.com/hongjilin/wechat-applet-demo-source-code"><code>hello小程序</code></a>源码中应用</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/posts/posts.<span class="property">wxml</span>--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;posts&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;postId&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">post</span> <span class="attr">bind:posttap</span>=<span class="string">&quot;onGoDetail&quot;</span> <span class="attr">res</span>=<span class="string">&quot;&#123;&#123;item&#125;&#125;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="comment">// components/posts/index.js  这是自定义组件</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">methods</span>: &#123;</span><br><span class="line">    onTap (e) &#123;  <span class="comment">//此处不能用箭头函数,否则`  this.triggerEvent`将会找不到报错</span></span><br><span class="line">    <span class="keyword">const</span> pid = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">res</span>.<span class="property">postId</span></span><br><span class="line">    <span class="comment">// console.log( this.data)</span></span><br><span class="line">    <span class="comment">// console.log( this.properties)</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;posttap&#x27;</span>,&#123;</span><br><span class="line">        pid   <span class="comment">//这个参数会在事件调用处获取到</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/posts/posts.js  这个是在调用自定义组件的页面的js中,即可以使用自己的方法,单纯是调用自定义组件定义的事件</span></span><br><span class="line">  <span class="attr">onGoDetail</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; <span class="comment">//获取组件的自定义属性</span></span><br><span class="line">    <span class="comment">//先判断,如果e.currentTarget.dataset去得到值,就取有值的 下面这3种写法效果等同</span></span><br><span class="line">    <span class="comment">//  let pid = (e.currentTarget.dataset.id)?e.currentTarget.dataset.id:e.detail.pid </span></span><br><span class="line">    <span class="comment">// let pid = e.detail.pid|e.currentTarget.dataset.id  </span></span><br><span class="line">    <span class="keyword">let</span> pid = e.<span class="property">detail</span>.<span class="property">pid</span> || e.<span class="property">currentTarget</span>.<span class="property">dataset</span>.<span class="property">id</span></span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/pages/post-detail/post-detail?pid=&#x27;</span> + pid,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><blockquote><p>体系学习过程笔记外的知识点</p></blockquote><h2 id="1、微信开发者工具使用技巧"><a href="#1、微信开发者工具使用技巧" class="headerlink" title="1、微信开发者工具使用技巧"></a>1、微信开发者工具使用技巧</h2><h3 id="Ⅰ-新建页面的技巧与规则"><a href="#Ⅰ-新建页面的技巧与规则" class="headerlink" title="Ⅰ-新建页面的技巧与规则:"></a>Ⅰ-新建页面的技巧与规则:</h3><blockquote><ol><li>本技巧适用于<code>微信开发者工具</code></li><li>当你需要新建一个页面时:新建一个page文件目录–&gt;右键<code>新建page</code>–&gt;输入page名字–&gt;一次生成所需四个文件 且自动注册到<code>app.json</code>中</li><li>##如果配置文件中出现错误时,自动新建无法成功,更无法自动注册</li></ol></blockquote><h3 id="Ⅱ-指定初始页面"><a href="#Ⅱ-指定初始页面" class="headerlink" title="Ⅱ-指定初始页面"></a>Ⅱ-指定初始页面</h3><blockquote><p>当你写多个page时,如果每次通过修改<code>app.json</code>的配置项来指定初始页面,十分麻烦</p><ol><li><p>可以在<code>app.json</code>用”entryPagePath”:”pages/页面文件夹/页面文件名” 配置首页,但仍要修改配置文件,十分麻烦</p></li><li><p>使用编译器的<code>工具栏</code>–&gt;添加<code>编译模式</code>进行指定初始化页面(启动页面默认值要先删除才有提示)</p></li></ol>  <img src="微信小程序学习笔记中的图片/image-20210421181759900.png" alt="image-20210421181759900" style="zoom: 80%;" /><ol start="3"><li>添加后每次调试只要<code>选择编译模式</code>,就可以切换初始页面</li></ol></blockquote><h3 id="Ⅲ-ctrl-滚轮缩放工具界面"><a href="#Ⅲ-ctrl-滚轮缩放工具界面" class="headerlink" title="Ⅲ-ctrl+滚轮缩放工具界面"></a>Ⅲ-ctrl+滚轮缩放工具界面</h3><blockquote><p>只能调成字体了,<code>这个BUG被修复了</code>:dog:<img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210423095423566.png" alt="image-20210423095423566"></p></blockquote><h2 id="2、微信开发常见编程方法与细节"><a href="#2、微信开发常见编程方法与细节" class="headerlink" title="2、微信开发常见编程方法与细节"></a>2、微信开发常见编程方法与细节</h2><blockquote><p>学习、练习、开发微信小程序过程中遇到的一些基础知识与细节记录</p></blockquote><h3 id="Ⅰ-相对路径规则"><a href="#Ⅰ-相对路径规则" class="headerlink" title="Ⅰ-相对路径规则:"></a>Ⅰ-相对路径规则:</h3><blockquote><ol><li><p><code>/</code>代表根目录:如引入根目录下的images/图片 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/images/测试头像图片.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>其余的如:<code>../</code>上一级目录、<code>./</code>同级目录,都与一般无异</p></li></ol></blockquote><h3 id="Ⅱ-npm引入第三方库后需进行构建"><a href="#Ⅱ-npm引入第三方库后需进行构建" class="headerlink" title="Ⅱ-npm引入第三方库后需进行构建"></a>Ⅱ-npm引入第三方库后需进行构建</h3><blockquote><p>安装第三方库后在小程序需要点击<code>工具</code>–&gt;<code>构建 npm</code>才可以使用</p><p><code>所有npm引入的都需要这一步</code></p></blockquote><h2 id="3、初学阶段遇到的问题与解决"><a href="#3、初学阶段遇到的问题与解决" class="headerlink" title="3、初学阶段遇到的问题与解决"></a>3、初学阶段遇到的问题与解决</h2><blockquote><p>这部分将记录本人初学小程序过程遇到的问题,这部分应该大部分是小程序初学者才会遇到的,或者是本人虽然可以直接解决但觉得别人可能会遇到的便记录下来。而后续进阶阶段或者实战开发时遇到的问题,将记录在下面另一章节</p></blockquote><h3 id="Ⅰ-设置整个page的背景色"><a href="#Ⅰ-设置整个page的背景色" class="headerlink" title="Ⅰ-设置整个page的背景色"></a>Ⅰ-设置整个page的背景色</h3><blockquote><ol><li><p>问题:当我设置页面背景色时,发现添加背景色的page的高度是被内容撑起而不是全屏?如何解决最简单<br>问题截图<img src="微信小程序学习笔记中的图片/image-20210421153332813.png" alt="image-20210421153332813" style="zoom: 50%;" />解决后<img src="微信小程序学习笔记中的图片/image-20210421153607334.png" alt="image-20210421153607334" style="zoom: 50%;" /></p><p>解决:可以在你需要修改的page的样式文件中,给<code>&lt;page/&gt;</code>标签加样式,默认小程序是使用<page/>作为最外层的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#b3d4db</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="Ⅱ-小程序中使用less"><a href="#Ⅱ-小程序中使用less" class="headerlink" title="Ⅱ-小程序中使用less"></a>Ⅱ-小程序中使用less</h3><blockquote><p>原⽣⼩程序不⽀持 less ，其他基于⼩程序的框架⼤体都⽀持，如 wepy ， mpvue ， taro 等。 但是仅仅因为⼀个less功能，⽽去引⼊⼀个框架，肯定是不可取的。因此可以⽤以下⽅式来实现</p><ol><li><p>编辑器是<code>vscode</code></p></li><li><p>安装插件<code>easy less</code></p></li></ol><p>  <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210421151330740.png" alt="image-20210421151330740"></p><ol start="3"><li>在vscode的设置中加⼊如下，配置</li></ol>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;less.compile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;outExt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.wxss&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在要编写样式的地⽅，新建 less ⽂件，如 index.less ,然后正常编辑即可。</li></ol></blockquote><h3 id="Ⅲ-报错-TypeError-wx-getMenuButtonBoundingClientRect-is-not-a-function"><a href="#Ⅲ-报错-TypeError-wx-getMenuButtonBoundingClientRect-is-not-a-function" class="headerlink" title="Ⅲ-报错: TypeError: wx.getMenuButtonBoundingClientRect is not a function"></a>Ⅲ-报错: <code>TypeError: wx.getMenuButtonBoundingClientRect is not a function</code></h3><blockquote><p>控制台报错: <code>TypeError: wx.getMenuButtonBoundingClientRect is not a function</code></p><p>问题分析:这个 api是 更高版本版本支持的，你的用户有的客户端基础库版本 小于这个基础库。你在小程序后台设置下 最低基础库2.1.0.那样用户客户端基础库版本低于此就会提示升级</p><p>解决:<img src="微信小程序学习笔记中的图片/报错1图例.png" alt="image-20210421172805580" style="zoom: 67%;" /></p></blockquote><h3 id="Ⅳ-警告-无效的page-json"><a href="#Ⅳ-警告-无效的page-json" class="headerlink" title="Ⅳ-警告:无效的page.json"></a>Ⅳ-警告:<code>无效的page.json</code></h3><blockquote><p>这是初学者才会犯下的错误,但也记录下来</p><ol><li>问题:在page.json配置文件中与要修改导航栏颜色,却发生报错 <img src="微信小程序学习笔记中的图片/警告pagejson无效问题.png" alt="image-20210422094205182" style="zoom: 67%;" /></li><li>解决:修改相应报错配置(<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html">翻阅文档</a>),虽然响应的属性值相同,但一个外层包裹window,另一个没有包裹 <img src="微信小程序学习笔记中的图片/警告pagejson无效问题解决.png" alt="image-20210422094901528" style="zoom:67%;" /></li></ol></blockquote><h3 id="Ⅴ-报错-typeError-Cannot-read-property-39-mark-39-of-undefined"><a href="#Ⅴ-报错-typeError-Cannot-read-property-39-mark-39-of-undefined" class="headerlink" title="Ⅴ-报错:typeError: Cannot read property &#39;mark&#39; of undefined"></a>Ⅴ-报错:<code>typeError: Cannot read property &#39;mark&#39; of undefined</code></h3><blockquote><ol><li>报错</li></ol><p> ​    <img src="微信小程序学习笔记中的图片/image-20210426170705465.png" alt="image-20210426170705465" style="zoom:80%;" /></p><ol start="2"><li>解决:最终发现是小程序工具设置问题</li></ol><p> 需要勾选增强编译</p><p> <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210426170827112.png" alt="image-20210426170827112"></p></blockquote><h3 id="Ⅵ-微信小程序中使用箭头函数导致this指向错误的问题"><a href="#Ⅵ-微信小程序中使用箭头函数导致this指向错误的问题" class="headerlink" title="Ⅵ-微信小程序中使用箭头函数导致this指向错误的问题"></a>Ⅵ-微信小程序中使用箭头函数导致this指向错误的问题</h3><blockquote><ol><li>问题代码截图:</li></ol><img src="微信小程序学习笔记中的图片/image-20210427161221380.png" alt="image-20210427161221380" style="zoom: 67%;" /><ol start="2"><li>问题分析:</li></ol><p>众所周知,箭头函数<code>会改变this指向</code>,当我使用箭头函数后,函数中的this不再指向实例而是指向函数本身,导致data其实是找不到的发生报错</p><ol start="3"><li><p>问题解决:</p><ol><li><p>不使用箭头函数:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">onCollect</span>(<span class="params">e</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">     <span class="attr">title</span>:  !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;进行收藏&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">if</span> (!result.<span class="property">confirm</span>) <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">let</span> postCollected = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_postCollected</span> <span class="comment">//将当前data中(相当于之前本地缓存的postCollected)拉去下来,防止被覆盖</span></span><br><span class="line">   postCollected[<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">_pid</span>] = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">     <span class="attr">collected</span>: !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span></span><br><span class="line">   &#125;)</span><br><span class="line">   wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;posts_collected&#x27;</span>, postCollected)</span><br><span class="line">   wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">     <span class="comment">//此处其实已经被修改完状态,才开始提示,所以要反过来</span></span><br><span class="line">     <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;收藏成功&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">     <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><p>使用箭头函数,但需要保存this指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> con  <span class="comment">//用来保存this指向</span></span><br><span class="line">                                                                            </span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="comment">//1. 生命周期函数中保存this指向</span></span><br><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    con=<span class="variable language_">this</span>  <span class="comment">//用来保存this指向</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="comment">//2. 函数体写法</span></span><br><span class="line"><span class="attr">onCollect</span>:<span class="keyword">async</span> (e)=&gt; &#123;  箭头函数写法,需要保存<span class="variable language_">this</span>指向</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(con)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>:  !con.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;进行收藏&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!result.<span class="property">confirm</span>) <span class="keyword">return</span>;</span><br><span class="line">                                                                            </span><br><span class="line">  <span class="keyword">let</span> postCollected = con.<span class="property">data</span>.<span class="property">_postCollected</span> <span class="comment">//将当前data中(相当于之前本地缓存的postCollected)拉去下来,防止被覆盖</span></span><br><span class="line">  postCollected[con.<span class="property">data</span>.<span class="property">_pid</span>] = !con.<span class="property">data</span>.<span class="property">collected</span></span><br><span class="line">  con.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">collected</span>: !con.<span class="property">data</span>.<span class="property">collected</span></span><br><span class="line">  &#125;)</span><br><span class="line">  wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;posts_collected&#x27;</span>, postCollected)</span><br><span class="line">  wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">    <span class="comment">//此处其实已经被修改完状态,才开始提示,所以要反过来</span></span><br><span class="line">    <span class="attr">title</span>: con.<span class="property">data</span>.<span class="property">collected</span> ? <span class="string">&#x27;收藏成功&#x27;</span> : <span class="string">&#x27;取消收藏&#x27;</span>,</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li></ol></blockquote><h3 id="Ⅶ-警告-Some-selectors-are-not-allowed-in-component-wxss-including-tag-name-selectors-ID-selectors-and-attribute-selectors"><a href="#Ⅶ-警告-Some-selectors-are-not-allowed-in-component-wxss-including-tag-name-selectors-ID-selectors-and-attribute-selectors" class="headerlink" title="Ⅶ-警告: Some selectors are not allowed in component wxss, including tag name selectors, ID selectors, and attribute selectors"></a>Ⅶ-警告: <code>Some selectors are not allowed in component wxss, including tag name selectors, ID selectors, and attribute selectors</code></h3><blockquote><ol><li>出现场景:在我将之前写好的样式模块抽出成<code>自定义组件</code>时,控制台突然出现警告</li></ol><p>  <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210430101549430.png" alt="image-20210430101549430"></p><ol start="2"><li>分析:我使用了<code>属性选择器</code>,而<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">官方文档在自定义组件部分</a>有要求不能使用,防止出现样式错误,</li></ol>  <img src="微信小程序学习笔记中的图片/image-20210430101700628.png" alt="image-20210430101700628" style="zoom: 80%;" /><ol start="3"><li>解决:将属性选择器删除即可</li></ol></blockquote><h3 id="Ⅷ-解决flex布局中-space-between方法的排版问题"><a href="#Ⅷ-解决flex布局中-space-between方法的排版问题" class="headerlink" title="Ⅷ-解决flex布局中 space-between方法的排版问题"></a>Ⅷ-解决flex布局中 space-between方法的排版问题</h3><blockquote><p>flex布局 justify-content：space-between； 解决最后一排数量不够自动向两端排列问题</p><ol><li>问题图示:</li></ol>  <img src="微信小程序学习笔记中的图片/image-20210507095120687.png" alt="image-20210507095120687" style="zoom: 50%;" /><ol start="2"><li>分析:flex 布局两端对齐当最后一排数量不够时，会出现以下布局情况</li></ol><p>  <img src="%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210507095230974.png" alt="image-20210507095230974"></p><ol start="3"><li>解决方法1:父级添加after伪类法</li></ol>  <img src="微信小程序学习笔记中的图片/image-20210507095349825.png" alt="image-20210507095349825" style="zoom: 67%;" /><p>  ps:这种解决方案只适合每列有<code>3个</code>的分布情况，如果布局每列有4个，5个,就需要解决方法2</p><ol start="4"><li>解决方法2:使用grid栅格布局,此处不详解,只将解决方案指出,有需要的直接百度搜索<code>使用grid栅格布局</code>即可</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ajax学习笔记</title>
      <link href="/2022/10/13/Ajax/"/>
      <url>/2022/10/13/Ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Ajax简介"><a href="#一、Ajax简介" class="headerlink" title="一、Ajax简介"></a>一、Ajax简介</h1><blockquote><p>AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。</p><p>通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：<code>无刷新获取数据</code>。</p><p>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p></blockquote><h2 id="1、XML简介"><a href="#1、XML简介" class="headerlink" title="1、XML简介"></a>1、XML简介</h2><blockquote><ol><li><p>XML 可扩展标记语言。</p></li><li><p>XML 被设计用来传输和存储数据。 </p></li><li><p>XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。</p></li></ol></blockquote><blockquote><p>比如说我有一个学生数据：<br>name = “孙悟空” ; age = 18 ; gender = “男” ;</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用 XML 表示：</span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>孙悟空<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现在已经被 JSON 取代了。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;孙悟空&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;男&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2、Ajax的特点"><a href="#2、Ajax的特点" class="headerlink" title="2、Ajax的特点"></a>2、Ajax的特点</h2><h3 id="Ⅰ-AJAX-的优点"><a href="#Ⅰ-AJAX-的优点" class="headerlink" title="Ⅰ-AJAX 的优点"></a>Ⅰ-AJAX 的优点</h3><blockquote><ol><li><p>可以无需刷新页面而与服务器端进行通信。 </p></li><li><p>允许你根据用户事件来更新部分页面内容。</p></li></ol></blockquote><h3 id="Ⅱ-Ajax的缺点"><a href="#Ⅱ-Ajax的缺点" class="headerlink" title="Ⅱ-Ajax的缺点"></a>Ⅱ-Ajax的缺点</h3><blockquote><ol><li><p>没有浏览历史，不能回退</p></li><li><p>存在跨域问题(同源)</p></li><li><p>SEO 不友好</p></li></ol></blockquote><h2 id="3、HTTP简介"><a href="#3、HTTP简介" class="headerlink" title="3、HTTP简介"></a>3、HTTP简介</h2><blockquote><p>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则</p></blockquote><h3 id="Ⅰ-请求报文"><a href="#Ⅰ-请求报文" class="headerlink" title="Ⅰ-请求报文"></a>Ⅰ-请求报文</h3><blockquote><p><code>重点是格式与参数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;行   <span class="variable constant_">POST</span> /s?ie=utf-<span class="number">8</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> </span><br><span class="line"></span><br><span class="line">&gt;头   <span class="title class_">Host</span>: atguigu.<span class="property">com</span></span><br><span class="line">&gt;​    <span class="title class_">Cookie</span>: name=guigu</span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">type</span>: application/x-www-form-urlencoded</span><br><span class="line">&gt;​    <span class="title class_">User</span>-<span class="title class_">Agent</span>: chrome <span class="number">83</span></span><br><span class="line">&gt;空行</span><br><span class="line">&gt;体   username=admin&amp;password=admin</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-响应报文"><a href="#Ⅱ-响应报文" class="headerlink" title="Ⅱ-响应报文"></a>Ⅱ-响应报文</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;行   <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span>（状态码） <span class="variable constant_">OK</span></span><br><span class="line"></span><br><span class="line">&gt;头   <span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">length</span>: <span class="number">2048</span></span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">encoding</span>: gzip</span><br><span class="line">&gt;空行  </span><br><span class="line">&gt;体   &lt;html&gt;</span><br><span class="line">&gt;​      &lt;head&gt;</span><br><span class="line">&gt;​      &lt;/head&gt;</span><br><span class="line">&gt;​      &lt;body&gt;</span><br><span class="line">&gt;​        &lt;h1&gt;尚硅谷&lt;/h1&gt;</span><br><span class="line">&gt;​      &lt;/body&gt;</span><br><span class="line">&gt;​    &lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Chrome网络控制台查看通信报文"><a href="#Ⅲ-Chrome网络控制台查看通信报文" class="headerlink" title="Ⅲ-Chrome网络控制台查看通信报文"></a>Ⅲ-Chrome网络控制台查看通信报文</h3><blockquote><p>1、Network  –&gt; Hearders  请求头</p><p>2、Network  –&gt; Response 响应体:通常返回的是html</p></blockquote><h1 id="二、原生Ajax"><a href="#二、原生Ajax" class="headerlink" title="二、原生Ajax"></a>二、原生Ajax</h1><blockquote><p>1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。</p><p>2、当你前端想设置自定义的请求头时,需要如此后端设置响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示接收任意类型的请求</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123; <span class="comment">//响应头 允许跨域     运行自定义响应头</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure></blockquote><p>//引入express<br>const { response } = require(‘express’);<br>const express = require(‘express’);<br>//创建应用对象<br>const app = express();<br>// 创建路由规则<br>//request 请求报文<br>//response响应报文<br>app.get(‘/‘, (require, response) =&gt; {<br>    //  设置响应<br>    response.send(‘Hello Express’);</p><p>});<br>// 监听端口<br>app.listen(8000, () =&gt; {<br>    console.log(“服务启动，监听中8080端口”);<br>})</p><blockquote><p>3、<code>ajax请求状态</code>:xhr.readyState<br>    0：请求未初始化，还没有调用 open()。</p><p>​    1：请求已经建立，但是还没有发送，还没有调用 send()。</p><p>​    2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</p><p>​    3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。</p><p>​    4：响应已完成；您可以获取并使用服务器的响应了</p></blockquote><h3 id="〇-Ajax的使用"><a href="#〇-Ajax的使用" class="headerlink" title="〇-Ajax的使用"></a>〇-Ajax的使用</h3><blockquote><p>使用步骤:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>) 创建 <span class="title class_">XMLHttpRequest</span> 对象</span><br><span class="line">&gt;<span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&gt;<span class="number">2</span>) 设置请求信息</span><br><span class="line">&gt;xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">&gt;<span class="comment">//可以设置请求头，一般不设置</span></span><br><span class="line">&gt;xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">&gt;<span class="number">3</span>) 发送请求</span><br><span class="line">&gt;xhr.<span class="title function_">send</span>(body) <span class="comment">//get 请求不传 body 参数，只有 post 请求使用</span></span><br><span class="line">&gt;<span class="number">4</span>) 接收响应</span><br><span class="line">&gt;<span class="comment">//xhr.responseXML 接收 xml 格式的响应数据</span></span><br><span class="line">&gt;<span class="comment">//xhr.responseText 接收文本格式的响应数据</span></span><br><span class="line">&gt;xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">var</span> text = xhr.<span class="property">responseText</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&gt;&#125;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅰ-Get方式"><a href="#Ⅰ-Get方式" class="headerlink" title="Ⅰ-Get方式"></a>Ⅰ-Get方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//1. 创建对象</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="comment">//2. 初始化 设置请求方法和 url</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:3000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">  <span class="comment">//3. 发送</span></span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  <span class="comment">//4. 事件绑定 处理服务端返回的结果</span></span><br><span class="line">  <span class="comment">// on  when 当....时候</span></span><br><span class="line">  <span class="comment">// readystate 是 xhr 对象中的属性, 表示状态 0(未初始化) 1（open方法调用完毕） 2（send方法调用完毕） 3（服务端返回部分结果） 4（服务端返回所有结果）</span></span><br><span class="line">  <span class="comment">// change  改变时触发</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//判断 (服务端返回了所有的结果)</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">//判断响应状态码 200  404  403 401 500</span></span><br><span class="line">      <span class="comment">// 2xx 成功</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="comment">//处理结果  行 头 空行 体</span></span><br><span class="line">        <span class="comment">//响应 </span></span><br><span class="line">        <span class="comment">// console.log(xhr.status);//状态码</span></span><br><span class="line">        <span class="comment">// console.log(xhr.statusText);//状态字符串</span></span><br><span class="line">        <span class="comment">// console.log(xhr.getAllResponseHeaders());//所有响应头</span></span><br><span class="line">        <span class="comment">// console.log(xhr.response);//响应体</span></span><br><span class="line">        <span class="comment">//设置 result 的文本</span></span><br><span class="line">        result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-Post方式"><a href="#Ⅱ-Post方式" class="headerlink" title="Ⅱ-Post方式"></a>Ⅱ-Post方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">   result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">//1. 创建对象</span></span><br><span class="line">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">       <span class="comment">//2. 初始化 设置类型与 URL</span></span><br><span class="line">       xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line">       <span class="comment">//设置请求头</span></span><br><span class="line">       xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">       xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span>);</span><br><span class="line">       <span class="comment">//3. 发送</span></span><br><span class="line">       xhr.<span class="title function_">send</span>(<span class="string">&#x27;a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">       <span class="comment">// xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;);</span></span><br><span class="line">       <span class="comment">// xhr.send(&#x27;1233211234567&#x27;);</span></span><br><span class="line">       <span class="comment">//4. 事件绑定</span></span><br><span class="line">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="comment">//判断</span></span><br><span class="line">           <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                   <span class="comment">//处理服务端返回的结果</span></span><br><span class="line">                   result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-解决ie缓存问题"><a href="#Ⅲ-解决ie缓存问题" class="headerlink" title="Ⅲ-解决ie缓存问题"></a>Ⅲ-解决ie缓存问题</h3><blockquote><p>问题：在一些浏览器中(IE),由于<code>缓存机制</code>的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。</p><p>解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 <code>xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now());</code></p></blockquote><h3 id="Ⅳ-请求超时与网络异常"><a href="#Ⅳ-请求超时与网络异常" class="headerlink" title="Ⅳ-请求超时与网络异常"></a>Ⅳ-请求超时与网络异常</h3><blockquote><p>当你的请求时间过长,或者无网络时,进行的相应处理</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">         <span class="comment">//超时设置 2s 设置</span></span><br><span class="line">         xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">         <span class="comment">//超时回调</span></span><br><span class="line">         xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;网络异常, 请稍后重试!!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//网络异常回调</span></span><br><span class="line">         xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;你的网络似乎出了一些问题!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         xhr.<span class="title function_">send</span>();</span><br><span class="line">         xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span>&lt; <span class="number">300</span>)&#123;</span><br><span class="line">                     result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><h3 id="Ⅴ-取消请求"><a href="#Ⅴ-取消请求" class="headerlink" title="Ⅴ-取消请求"></a>Ⅴ-取消请求</h3><blockquote><p>在请求发出去后<code>但是未响应完成</code>时可以进行取消请求操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">    x.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abort</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x.<span class="title function_">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅵ-重复请求问题"><a href="#Ⅵ-重复请求问题" class="headerlink" title="Ⅵ-重复请求问题"></a>Ⅵ-重复请求问题</h3><blockquote><p>利用之前Ⅴ中取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="comment">//判断标识变量</span></span><br><span class="line">         <span class="keyword">if</span>(isSending) x.<span class="title function_">abort</span>();<span class="comment">// 如果正在发送, 则取消该请求, 创建一个新的请求</span></span><br><span class="line">         x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">         <span class="comment">//修改 标识变量的值</span></span><br><span class="line">         isSending = <span class="literal">true</span>;</span><br><span class="line">         x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         x.<span class="title function_">send</span>();</span><br><span class="line">         x.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(x.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="comment">//修改标识变量</span></span><br><span class="line">                 isSending = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="三、常见三种Ajax请求方式"><a href="#三、常见三种Ajax请求方式" class="headerlink" title="三、常见三种Ajax请求方式"></a>三、常见三种Ajax请求方式</h1><h2 id="1、jQuery发送AJAX请求"><a href="#1、jQuery发送AJAX请求" class="headerlink" title="1、jQuery发送AJAX请求"></a>1、jQuery发送AJAX请求</h2><blockquote><p>jQuery有三种发送请求方法:</p><p>当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用<code>$.ajax()</code>方法</p></blockquote><h3 id="Ⅰ-get"><a href="#Ⅰ-get" class="headerlink" title="Ⅰ-$.get()"></a>Ⅰ-$.get()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          $.<span class="title function_">get</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">          &#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-post"><a href="#Ⅱ-post" class="headerlink" title="Ⅱ-$.post()"></a>Ⅱ-$.post()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">1</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          $.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-ajax"><a href="#Ⅲ-ajax" class="headerlink" title="Ⅲ-$.ajax"></a>Ⅲ-$.ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">2</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">             <span class="comment">//url</span></span><br><span class="line">             <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>,</span><br><span class="line">             <span class="comment">//参数</span></span><br><span class="line">             <span class="attr">data</span>: &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;,</span><br><span class="line">             <span class="comment">//请求类型</span></span><br><span class="line">             <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">             <span class="comment">//响应体结果</span></span><br><span class="line">             <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">             <span class="comment">//成功的回调</span></span><br><span class="line">             <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">                 <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//超时时间</span></span><br><span class="line">             <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">             <span class="comment">//失败的回调</span></span><br><span class="line">             <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出错啦!!&#x27;</span>);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//头信息</span></span><br><span class="line">             <span class="attr">headers</span>: &#123;</span><br><span class="line">                 <span class="attr">c</span>:<span class="number">300</span>,</span><br><span class="line">                 <span class="attr">d</span>:<span class="number">400</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h2 id="2、Axios发送AJAX请求"><a href="#2、Axios发送AJAX请求" class="headerlink" title="2、Axios发送AJAX请求"></a>2、Axios发送AJAX请求</h2><h3 id="Ⅰ-axios-get"><a href="#Ⅰ-axios-get" class="headerlink" title="Ⅰ-axios.get()"></a>Ⅰ-axios.get()</h3><blockquote><p>axios.get(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置 baseURL</span></span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//GET 请求</span></span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//url 参数</span></span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">vip</span>: <span class="number">7</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求头信息</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-axios-get"><a href="#Ⅱ-axios-get" class="headerlink" title="Ⅱ-axios.get()"></a>Ⅱ-axios.get()</h3><blockquote><p>axios.post(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;  </span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     axios.<span class="title function_">post</span>(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">       <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">       <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">     &#125;, &#123;</span><br><span class="line">       <span class="comment">//url </span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: <span class="number">200</span>,</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">9</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求头参数</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">         <span class="attr">weight</span>: <span class="number">180</span>,</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-axios-常用"><a href="#Ⅲ-axios-常用" class="headerlink" title="Ⅲ-axios() 常用"></a>Ⅲ-axios() <code>常用</code></h3><blockquote><p>axios({})</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line">btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="title function_">axios</span>(&#123;</span><br><span class="line">       <span class="comment">//请求方法</span></span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">       <span class="comment">//url</span></span><br><span class="line">       <span class="attr">url</span>: <span class="string">&#x27;/axios-server&#x27;</span>,</span><br><span class="line">       <span class="comment">//url参数</span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">level</span>: <span class="number">30</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">         <span class="attr">b</span>: <span class="number">200</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求体参数</span></span><br><span class="line">       <span class="attr">data</span>: &#123;</span><br><span class="line">         <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">         <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//响应状态码</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">       <span class="comment">//响应状态字符串</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">       <span class="comment">//响应头信息</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">       <span class="comment">//响应体</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3、Fetch发送AJAX请求"><a href="#3、Fetch发送AJAX请求" class="headerlink" title="3、Fetch发送AJAX请求"></a>3、Fetch发送AJAX请求</h2><blockquote><p>代码示例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//请求方法</span></span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="comment">//请求头</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求体</span></span><br><span class="line">      <span class="attr">body</span>: <span class="string">&#x27;username=admin&amp;password=admin&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return response.text();</span></span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="四、跨域与解决"><a href="#四、跨域与解决" class="headerlink" title="四、跨域与解决"></a>四、跨域与解决</h1><blockquote><h5 id="1、什么是跨越？"><a href="#1、什么是跨越？" class="headerlink" title="1、什么是跨越？"></a>1、什么是跨越？</h5><ul><li>一个网页向另一个不同域名/不同协议/不同端口的网页请求资源，这就是跨域。</li><li>跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。</li></ul><h5 id="2、为什么会产生跨域请求？"><a href="#2、为什么会产生跨域请求？" class="headerlink" title="2、为什么会产生跨域请求？"></a>2、为什么会产生跨域请求？</h5><ul><li>因为浏览器使用了同源策略</li></ul><h5 id="3、什么是同源策略？"><a href="#3、什么是同源策略？" class="headerlink" title="3、什么是同源策略？"></a>3、什么是同源策略？</h5><ul><li>同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。</li><li>同源： 协议、域名、端口号 必须完全相同。 <code>违背同源策略就是跨域</code>。</li></ul><h5 id="4、为什么浏览器要使用同源策略？"><a href="#4、为什么浏览器要使用同源策略？" class="headerlink" title="4、为什么浏览器要使用同源策略？"></a>4、为什么浏览器要使用同源策略？</h5><ul><li>是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能:</li><li><ul><li>1、共享Cookie、LocalStorage、IndexDB</li></ul></li><li><ul><li>2、获取DOM</li></ul></li><li><ul><li>3、AJAX请求不能发送</li></ul></li></ul><h5 id="5、跨域的五个解决方式"><a href="#5、跨域的五个解决方式" class="headerlink" title="5、跨域的五个解决方式:"></a>5、跨域的五个解决方式:</h5><p>​    1、前端使用jsonp （不推荐使用）</p><p>​    2、后台Http请求转发</p><p>​    3、后台配置同源Cors （推荐）</p><p>​    4、使用SpringCloud网关</p><p>​    5、使用nginx做转发 (推荐)</p><p>本课程提到了其中的两种:</p></blockquote><h2 id="1、jsonP"><a href="#1、jsonP" class="headerlink" title="1、jsonP"></a>1、jsonP</h2><blockquote><p>1)JSONP 是什么?</p><p>​    JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。</p><p>2)JSONP 怎么工作的？</p><p>​    在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p></blockquote><h3 id="Ⅰ-jsonP的使用"><a href="#Ⅰ-jsonP的使用" class="headerlink" title="Ⅰ-jsonP的使用"></a>Ⅰ-jsonP的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1. 动态的创建一个 script 标签------------------------------------------------------------</span></span><br><span class="line">   <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//2. 设置 script 的 src， 设置回调函数</span></span><br><span class="line">   script.<span class="property">src</span> = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">abc</span>(<span class="params">data</span>) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(data.<span class="property">name</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">// 3. 将 script 添加到 body 中</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 服务器中路由的处理------------------------------------------------------</span></span><br><span class="line">   router.<span class="title function_">get</span>(<span class="string">&quot;/testAJAX&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">     <span class="keyword">var</span> callback = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">ame</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">       <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">     &#125;</span><br><span class="line">     res.<span class="title function_">send</span>(callback + <span class="string">&quot;(&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-jQuery发送jsonP请求"><a href="#Ⅱ-jQuery发送jsonP请求" class="headerlink" title="Ⅱ-jQuery发送jsonP请求"></a>Ⅱ-jQuery发送jsonP请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端代码-----------------------------------------------------------------------------------</span></span><br><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  $.<span class="title function_">getJSON</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">                名称: <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;</span></span><br><span class="line"><span class="string">                校区: <span class="subst">$&#123;data.city&#125;</span></span></span><br><span class="line"><span class="string">            `</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码-----------------------------------------------------------</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-我自己开发封装的jsonP插件"><a href="#Ⅲ-我自己开发封装的jsonP插件" class="headerlink" title="Ⅲ-我自己开发封装的jsonP插件"></a>Ⅲ-我自己开发封装的jsonP插件</h3><blockquote><p>1、代价:需要前后端联动<br>2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数<br>3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子）<br>4、参数拼接：url已经是带参的。和不带参的<br>5、id优化 额可以添加一个容器来管理id</p></blockquote><blockquote><p>1、前端调用测试封装好的jsonP代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试调用函数</span></span><br><span class="line">    <span class="keyword">let</span> test=<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        jsonP.<span class="title function_">req</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/jsonpx&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="string">&quot;111&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">callback</span>:<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&quot;成功&quot;</span>+result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、服务端测试代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/jsonpx&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">req, resp, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callback=req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="keyword">let</span> data=req.<span class="property">query</span>.<span class="property">a</span>;</span><br><span class="line">    <span class="keyword">if</span> (!data)&#123;</span><br><span class="line">        resp.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码&#x27;)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码`</span>+data+<span class="string">`&#x27;)`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>3、封装原生代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/**author:<span class="doctag">@hongjilin</span></span></span><br><span class="line"><span class="comment">     * 1.声明一个jsonP插件对象</span></span><br><span class="line"><span class="comment">     * 作用：隔开作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> jsonP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *2.在插件对象中创建两个名字备用符数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">char</span> = &#123;</span><br><span class="line">        <span class="title class_">Number</span>: <span class="string">&#x27;0123456789&#x27;</span>,</span><br><span class="line">        <span class="title class_">Letter</span>: <span class="string">&#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过随机数抽取备用字符数组库拼凑函数id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">charLen</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">numLen</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">newFunId</span> = <span class="keyword">function</span> (<span class="params">charLen, numLen</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; charLen; i++) &#123;</span><br><span class="line">            id += <span class="variable language_">this</span>.<span class="property">char</span>.<span class="property">Letter</span>.<span class="title function_">charAt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numLen; j++) &#123;</span><br><span class="line">            id += <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼接路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">url</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">jointUrl</span> = <span class="keyword">function</span> (<span class="params">url, key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url &amp;&amp; key &amp;&amp; value) &#123;</span><br><span class="line">            <span class="keyword">let</span> sign = <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">            <span class="comment">//如果是第一次</span></span><br><span class="line">            <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                sign = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            url += sign + key + <span class="string">&quot;=&quot;</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     封装err属性方便</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">err</span> = <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">options</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">req</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> jsonId=&#123;&#125;;</span><br><span class="line">        <span class="comment">//1.生成方法名</span></span><br><span class="line">        jsonId.<span class="property">funId</span> = <span class="variable language_">this</span>.<span class="title function_">newFunId</span>(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Userurl</span> = options.<span class="property">url</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Userdata</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">err</span>(<span class="string">&quot;输入不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">Userurl</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">err</span>(<span class="string">&quot;url不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">Userdata</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有data,初始化</span></span><br><span class="line">            <span class="title class_">Userdata</span> = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将函数名赋值给userdata的回调函数属性中</span></span><br><span class="line">        <span class="title class_">Userdata</span>.<span class="property">callback</span> = jsonId.<span class="property">funId</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="title class_">Userdata</span>) &#123;</span><br><span class="line">            <span class="title class_">Userurl</span> = <span class="variable language_">this</span>.<span class="title function_">jointUrl</span>(<span class="title class_">Userurl</span>, key, <span class="title class_">Userdata</span>[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span> , jsonId.<span class="property">funId</span>);</span><br><span class="line">        script.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span> , <span class="title class_">Userurl</span>);</span><br><span class="line">        <span class="comment">//动态生成函数</span></span><br><span class="line">        <span class="keyword">let</span> callback=<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">            <span class="comment">//业务逻辑回调</span></span><br><span class="line">            <span class="keyword">if</span> (options.<span class="property">callback</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    options.<span class="title function_">callback</span>(result)</span><br><span class="line">                &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">err</span>(e.<span class="property">message</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//善后</span></span><br><span class="line">            <span class="keyword">let</span> tmp=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(jsonId.<span class="property">funId</span>)</span><br><span class="line">            tmp.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(tmp);</span><br><span class="line">            <span class="built_in">eval</span>(jsonId.<span class="property">funId</span>+<span class="string">&#x27;=null&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;window.&quot;</span>+jsonId.<span class="property">funId</span>+<span class="string">&quot;=function(result)&#123; callback(result) &#125;&quot;</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h2><blockquote><p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS文档链接</a></p><p>2、CORS是什么?</p><p>​    CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p><p>3、CORS是怎么工作的?</p><p>​    CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。</p></blockquote><h3 id="Ⅰ-代码示例"><a href="#Ⅰ-代码示例" class="headerlink" title="Ⅰ-代码示例"></a>Ⅰ-代码示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">    <span class="comment">//响应首部中可以携带一个 Access-Control-Allow-Origin 字段</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-HTTP-响应首部字段"><a href="#Ⅱ-HTTP-响应首部字段" class="headerlink" title="Ⅱ-HTTP 响应首部字段"></a>Ⅱ-<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#http_%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 响应首部字段</a></h3><blockquote><p>本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。</p></blockquote><h4 id="1、Access-Control-Allow-Origin"><a href="#1、Access-Control-Allow-Origin" class="headerlink" title="1、Access-Control-Allow-Origin"></a>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-origin">Access-Control-Allow-Origin</a></h4><blockquote><p>响应首部中可以携带一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 字段，其语法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。</p><p>例如，下面的字段值将允许来自 <a href="http://mozilla.com/">http://mozilla.com</a> 的请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//mozilla.com</span></span><br></pre></td></tr></table></figure><p>如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。</p></blockquote><h4 id="2、Access-Control-Expose-Headers"><a href="#2、Access-Control-Expose-Headers" class="headerlink" title="2、Access-Control-Expose-Headers"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-expose-headers">Access-Control-Expose-Headers</a></h4><blockquote><p>译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a> 头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: X-<span class="title class_">My</span>-<span class="title class_">Custom</span>-<span class="title class_">Header</span>, X-<span class="title class_">Another</span>-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br></pre></td></tr></table></figure><p>这样浏览器就能够通过getResponseHeader访问<code>X-My-Custom-Header</code>和 <code>X-Another-Custom-Header</code> 响应头了。</p></blockquote><h4 id="3、Access-Control-Max-Age"><a href="#3、Access-Control-Max-Age" class="headerlink" title="3、Access-Control-Max-Age"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-max-age">Access-Control-Max-Age</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age"><code>Access-Control-Max-Age</code></a> 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure><p><code>delta-seconds</code> 参数表示preflight请求的结果在多少秒内有效。</p></blockquote><h4 id="4、Access-Control-Allow-Credentials"><a href="#4、Access-Control-Allow-Credentials" class="headerlink" title="4、Access-Control-Allow-Credentials"></a>4、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-credentials">Access-Control-Allow-Credentials</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a> 头指定了当浏览器的<code>credentials</code>设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用<code>credentials</code>。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="5、Access-Control-Allow-Methods"><a href="#5、Access-Control-Allow-Methods" class="headerlink" title="5、Access-Control-Allow-Methods"></a>5、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-methods">Access-Control-Allow-Methods</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h4 id="6、Access-Control-Allow-Headers"><a href="#6、Access-Control-Allow-Headers" class="headerlink" title="6、Access-Control-Allow-Headers"></a>6、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-headers">Access-Control-Allow-Headers</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a> 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-HTTP-请求首部字段"><a href="#Ⅲ-HTTP-请求首部字段" class="headerlink" title="Ⅲ-HTTP 请求首部字段"></a>Ⅲ-<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#http_%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 请求首部字段</a></h3><blockquote><p>本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。</p></blockquote><h4 id="1、Origin"><a href="#1、Origin" class="headerlink" title="1、Origin"></a>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#origin">Origin</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 首部字段表明预检请求或实际请求的源站。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Origin</span>: &lt;origin&gt;</span><br></pre></td></tr></table></figure><p>origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。</p><p><strong>Note:</strong> 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。</p><p>注意，在所有访问控制请求（Access control request）中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 首部字段<strong>总是</strong>被发送</p></blockquote><h4 id="2、Access-Control-Request-Method"><a href="#2、Access-Control-Request-Method" class="headerlink" title="2、Access-Control-Request-Method"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-request-method">Access-Control-Request-Method</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a> 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: &lt;method&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3、Access-Control-Request-Headers"><a href="#3、Access-Control-Request-Headers" class="headerlink" title="3、Access-Control-Request-Headers"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-request-headers">Access-Control-Request-Headers</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></blockquote><hr><hr><h1 id="五、服务端代码示例"><a href="#五、服务端代码示例" class="headerlink" title="五、服务端代码示例"></a>五、服务端代码示例</h1><blockquote><p>配合以上前端代码的服务端代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX - 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以接收任意类型的请求 </span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX POST&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON 响应</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应一个数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//对对象进行字符串转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对 IE 缓存</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO IE - 5&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时响应</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/delay&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&#x27;延时响应&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//axios 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/axios-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetch 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/fetch-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户名检测是否存在</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/check-username&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">exist</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;用户名已经存在&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列基础知识</title>
      <link href="/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一-栈结构"><a href="#一-栈结构" class="headerlink" title="一.栈结构"></a>一.栈结构</h1><h2 id="栈的简介"><a href="#栈的简介" class="headerlink" title="栈的简介"></a>栈的简介</h2><blockquote><p>avaScript中本无“栈”的这种类型，但是我们有时候又需要用到这类的数据结构，还记得上一篇文章提到的数组吗？JavaScript中的栈数据结构就是基于Array类型来进行封装的。让我们拭目以待吧！</p></blockquote><blockquote><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p></blockquote><blockquote><p>栈方法:</p></blockquote><blockquote><p>(1)push(element(s))：添加一个(或几个)新元素到栈顶。</p></blockquote><blockquote><p>(2)pop()：移除栈顶的元素，同时返回被移除的元素。<br>peek()：返回栈顶的元素，不对栈做任何修改(该方法不会移除栈顶的元素，仅仅返回它)。</p></blockquote><blockquote><p>(3)isEmpty()：如果栈里没有任何元素就返回true，否则返回false。</p></blockquote><blockquote><p>(4)clear()：移除栈里的所有元素。</p></blockquote><blockquote><p>(5)size()：返回栈里的元素个数。该方法和数组的length属性很类似。</p></blockquote><h2 id="基于数组的栈"><a href="#基于数组的栈" class="headerlink" title="基于数组的栈"></a>基于数组的栈</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">item</span>=[]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//入栈</span></span><br><span class="line">   <span class="title function_">push</span>(<span class="params">element</span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">item</span>.<span class="title function_">push</span>(element)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 删除并返回栈顶元素(出栈)</span></span><br><span class="line">   <span class="title function_">pop</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">item</span>.<span class="title function_">pop</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回栈顶元素</span></span><br><span class="line">   <span class="title function_">peek</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">item</span>[<span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 栈是否为空</span></span><br><span class="line">   <span class="title function_">isEmpty</span>(<span class="params"></span>)&#123;    </span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">length</span>===<span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 栈的大小</span></span><br><span class="line">   <span class="title function_">size</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">item</span>.<span class="property">length</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//清除栈</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>)&#123; <span class="variable language_">this</span>.<span class="property">item</span>=[]&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 创建实例</span></span><br><span class="line">&gt;<span class="keyword">const</span> stack=<span class="keyword">new</span> <span class="title class_">Stack</span>()</span><br><span class="line">&gt;<span class="comment">// 入栈</span></span><br><span class="line">&gt;stack.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">&gt;stack.<span class="title function_">push</span>(<span class="number">2</span>)</span><br><span class="line">&gt;stack.<span class="title function_">push</span>(<span class="number">3</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(stack)       <span class="comment">//Stack&#123;item:Array&gt;(3)&#125;</span></span><br><span class="line">&gt;<span class="comment">// 返回栈顶元素</span></span><br><span class="line">&gt;<span class="keyword">let</span> topStack=stack.<span class="title function_">peek</span>() </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(topStack);  <span class="comment">//3</span></span><br><span class="line">&gt;<span class="comment">// 返回栈大小</span></span><br><span class="line">&gt;<span class="keyword">let</span> stackLen=stack.<span class="title function_">size</span>() </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(stackLen)  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"># 二.队列</span><br><span class="line">## 队列简介</span><br><span class="line">&gt;队列是是一种受限的线性表，特点为先进先出（<span class="variable constant_">FIFO</span>：first <span class="keyword">in</span> first out）。</span><br><span class="line">&gt;受限之处在于它只允许在表的前端（front）进行删除操作；在表的后端（rear）进行插入操作；</span><br><span class="line">&gt;![avatar](<span class="attr">https</span>:<span class="comment">//img-blog.csdnimg.cn/c28366756b374a049c1c3d84895e0ed7.png)</span></span><br><span class="line"></span><br><span class="line">队列的应用：</span><br><span class="line"></span><br><span class="line">打印队列：计算机打印多个文件的时候，需要排队打印；</span><br><span class="line">线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待<span class="variable constant_">CPU</span>处理；</span><br><span class="line">队列类的实现：</span><br><span class="line"></span><br><span class="line">队列的实现和栈一样，有两种方案：</span><br><span class="line"></span><br><span class="line">基于数组实现；</span><br><span class="line">基于链表实现；</span><br><span class="line">队列的常见操作：</span><br><span class="line"></span><br><span class="line">&gt;(<span class="number">1</span>)enqueue（element）：向队列尾部添加一个（或多个）新的项；</span><br><span class="line"></span><br><span class="line">&gt;(<span class="number">2</span>)dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；</span><br><span class="line"></span><br><span class="line">&gt;(<span class="number">3</span>)front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与<span class="title class_">Stack</span>类的peek方法非常类似）；</span><br><span class="line"></span><br><span class="line">&gt;(<span class="number">4</span>)isEmpty（）：如果队列中不包含任何元素，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>；</span><br><span class="line"></span><br><span class="line">&gt;(<span class="number">5</span>)size（）：返回队列包含的元素个数，与数组的length属性类似；</span><br><span class="line"></span><br><span class="line">&gt;(<span class="number">6</span>)toString（）：将队列中的内容，转成字符串形式；</span><br><span class="line"></span><br><span class="line">## 封装队列</span><br><span class="line"></span><br><span class="line">### 基于数组封装队列</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string"> function Queue() &#123;</span></span><br><span class="line"><span class="string">   // 属性</span></span><br><span class="line"><span class="string">    this.items = []</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  // 方法</span></span><br><span class="line"><span class="string">  // 1.enqueue():将元素加入到队列中</span></span><br><span class="line"><span class="string">  Queue.prototype.enqueue = element =&gt; &#123;</span></span><br><span class="line"><span class="string">    this.items.push(element)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 2.dequeue():从队列中删除前端元素</span></span><br><span class="line"><span class="string">  Queue.prototype.dequeue = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    return this.items.shift()</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 3.查看前端的元素</span></span><br><span class="line"><span class="string">  Queue.prototype.front = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    return this.items[0]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 4.查看队列是否为空</span></span><br><span class="line"><span class="string">  Queue.prototype.isEmpty = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    return this.items.length == 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 5.查看队列中元素的个数</span></span><br><span class="line"><span class="string">  Queue.prototype.size = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    return this.items.length</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 6.:将队列中元素以字符串形式输出</span></span><br><span class="line"><span class="string">  Queue.prototype.toString = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    let resultString = &#x27;&#x27;</span></span><br><span class="line"><span class="string">      for (let i of this.items)&#123;</span></span><br><span class="line"><span class="string">        resultString += i + &#x27; &#x27;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      return resultString</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="封装优先级队列"><a href="#封装优先级队列" class="headerlink" title="封装优先级队列"></a>封装优先级队列</h3><blockquote><p>有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列，在这种情况下使用队列就不行了，比如玩王者的时候突然女朋友一通电话，游戏屏幕瞬间被电话占领，这时候就应该优先处理电话。</p></blockquote><blockquote><p>在这种情况下，我们的数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新对象，这种数据结构就是优先级队列（PriorityQueue）</p></blockquote><pre><code class="js">    function PriorityQueue() &#123;       //内部类：在类里面再封装一个类;表示带优先级的数据      function QueueElement(element, priority) &#123;        this.element = element;        this.priority = priority;      &#125;        // 封装属性      this.items = []       // 1.实现按照优先级插入方法      PriorityQueue.prototype.enqueue = (element, priority) =&gt; &#123;        // 1.1.创建QueueElement对象        let queueElement = new QueueElement(element, priority)         // 1.2.判断队列是否为空        if(this.items.length == 0)&#123;          this.items.push(queueElement)        &#125;else&#123;          // 定义一个变量记录是否成功添加了新元素          let added = false          for(let i of this.items)&#123;            // 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)            if(queueElement.priority &lt; i.priority)&#123;              this.items.splice(i, 0, queueElement)              added = true              // 新元素已经找到插入位置了可以使用break停止循环              break            &#125;          &#125;          // 新元素没有成功插入，就把它放在队列的最前面          if(!added)&#123;            this.items.push(queueElement)          &#125;        &#125;      &#125;       // 2.dequeue():从队列中删除前端元素      PriorityQueue.prototype.dequeue = () =&gt; &#123;        return this.items.shift()      &#125;       // 3.front():查看前端的元素      PriorityQueue.prototype.front = () =&gt; &#123;        return this.items[0]      &#125;       // 4.isEmpty():查看队列是否为空      PriorityQueue.prototype.isEmpty = () =&gt; &#123;        return this.items.length == 0;      &#125;       // 5.size():查看队列中元素的个数      PriorityQueue.prototype.size = () =&gt; &#123;        return this.items.length      &#125;       // 6.toString():以字符串形式输出队列中的元素      PriorityQueue.prototype.toString = () =&gt; &#123;        let resultString = &#39;&#39;          for (let i of this.items)&#123;            resultString += i.element + &#39;-&#39; + i.priority + &#39; &#39;          &#125;          return resultString        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式表规范</title>
      <link href="/2022/10/12/CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2022/10/12/CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS开发规范"><a href="#CSS开发规范" class="headerlink" title="CSS开发规范"></a>CSS开发规范</h2><blockquote><p>怎么说呢,大部分前端编写样式表的时候并没有特意按照良好地CSS书写规范来写CSS代码,这样写出来的CSS代码不止不够直观,甚至非常影响代码的阅读体验与维护难度,这边我参考了一些文章以及个人经验进行梳理整合,整理出一些常用或者指的学习的CSS开发规范</p></blockquote><h2 id="Ⅰ-常见语法规范"><a href="#Ⅰ-常见语法规范" class="headerlink" title="Ⅰ- 常见语法规范"></a>Ⅰ- 常见语法规范</h2><h3 id="1、常见语法规范总结"><a href="#1、常见语法规范总结" class="headerlink" title="1、常见语法规范总结"></a>1、常见语法规范总结</h3><blockquote><blockquote><h6 id="常见语法规范"><a href="#常见语法规范" class="headerlink" title="常见语法规范"></a>常见语法规范</h6></blockquote><ol><li>用<code>两个空格来代替tab</code> – 这是唯一能保证在所有环境下获得一致展现的方法。</li><li>为选择器分组时，将单独的选择器单独放在一行。</li><li>为了代码的易读性，在每个声明块的左花括号前添加一个空格。</li><li>声明块的右花括号应当单独成行。</li><li>每条声明语句的 <code>:</code> 后应该插入一个空格。</li><li>为了获得更准确的错误报告，每条声明都应该独占一行。</li><li>所有声明语句都应当以分号结尾。最后一条声明语句后面的分号是可选的，但是，如果省略这个分号，你的代码可能更易出错。</li><li>对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，<code>box-shadow</code>）。</li><li>不要在 <code>rgb()</code>、<code>rgba()</code>、<code>hsl()</code>、<code>hsla()</code> 或 <code>rect()</code> 值的<em>内部</em>的逗号后面插入空格。这样利于从多个属性值（既加逗号也加空格）中区分多个颜色值（只加逗号，不加空格）。</li><li>对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，<code>.5</code> 代替 <code>0.5</code>；<code>-.5px</code> 代替 <code>-0.5px</code>）。</li><li>十六进制值应该全部小写，例如，<code>#fff</code>。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。</li><li>尽量使用简写形式的十六进制值，例如，用 <code>#fff</code> 代替 <code>#ffffff</code>。</li><li>为选择器中的属性添加双引号，例如，<code>input[type=&quot;text&quot;]</code>。<a href="http://mathiasbynens.be/notes/unquoted-attribute-values#css">只有在某些情况下是可选的</a>，但是，为了代码的一致性，建议都加上双引号。</li><li>避免为 0 值指定单位，例如，用 <code>margin: 0;</code> 代替 <code>margin: 0px;</code>。</li></ol><blockquote><h6 id="直接上例子"><a href="#直接上例子" class="headerlink" title="直接上例子"></a>直接上例子</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/************************** 不好的CSS 写法 **********************************/</span></span><br><span class="line">&gt;<span class="selector-class">.selector</span>, <span class="selector-class">.selector-secondary</span>, <span class="selector-class">.selector</span><span class="selector-attr">[type=text]</span> &#123;</span><br><span class="line"> <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line">  <span class="comment">/* 避免为 0 值指定单位，例如，用 `margin: 0;` 代替 `margin: 0px;` */</span></span><br><span class="line"> <span class="attribute">margin</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">15px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line"> <span class="comment">/* 十六进制值应该全部小写,同时尽量使用简写形式的十六进制值  */</span>  </span><br><span class="line"> <span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#CCC</span>,inset <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#FFFFFF</span>  </span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/************************** 好的 CSS 写法 ***************************************/</span></span><br><span class="line">&gt;<span class="selector-class">.selector</span>,                           --&gt;为选择器分组时，将单独的选择器单独放在一行</span><br><span class="line">&gt;<span class="selector-class">.selector-secondary</span>,</span><br><span class="line">&gt;<span class="selector-class">.selector</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123;             --&gt;建议为选择器中的属性 `<span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>` 添加双引号</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">15px</span>;     --&gt;每条声明语句的 `:` 后应该插入一个空格</span><br><span class="line"> margin-bottom: <span class="number">15px</span>; </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">   不要在 `rgb()`、`rgba()`、`hsl()`、`hsla()` 或 `rect()` 值的内部的逗号后面插入空格</span></span><br><span class="line"><span class="comment">   对于属性值或颜色参数，省略小于 1 的小数前面的 0</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"> <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">   所有声明语句都应当以分号结尾.后一条声明语句后面的分号是可选的,但略这个分号,你的代码可能更易出错</span></span><br><span class="line"><span class="comment">   对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#ccc</span>, inset <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#fff</span>; </span><br><span class="line">&gt;&#125;       --&gt;声明块的右花括号应当单独成行</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、声明顺序"><a href="#2、声明顺序" class="headerlink" title="2、声明顺序"></a>2、声明顺序</h3><blockquote><p>相关的属性声明应当归为一组，并按照下面的顺序排列：</p><blockquote><ol><li>Positioning  –&gt;由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式,因此排在首位</li><li>Box model  –&gt;盒模型排在第二位，因为它决定了组件的尺寸和位置。</li><li>Typographic  –&gt;文字类</li><li>Visual     –&gt;其他属性只是影响组件的<em>内部（inside）</em>或者是不影响前两组属性，因此排在后面。</li></ol></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-class">.declaration-order</span> &#123;</span><br><span class="line"> <span class="comment">/* Positioning 定位之类*/</span></span><br><span class="line"> <span class="attribute">position</span>: absolute;</span><br><span class="line"> <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Box-model 盒模型*/</span></span><br><span class="line"> <span class="attribute">display</span>: block;</span><br><span class="line"> <span class="attribute">float</span>: right;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Typography 排版印刷类 */</span></span><br><span class="line"> <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">&quot;Helvetica Neue&quot;</span>, sans-serif;</span><br><span class="line"> <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line"> <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line"> <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Visual 视觉类 */</span></span><br><span class="line"> <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Misc 其他混杂类 */</span></span><br><span class="line"> <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、尽量不要使用-import-引入css文件"><a href="#3、尽量不要使用-import-引入css文件" class="headerlink" title="3、尽量不要使用 @import 引入css文件"></a>3、尽量不要使用 <code>@import</code> 引入css文件</h3><blockquote><p>与 <code>&lt;link&gt;</code> 标签相比，<code>@import</code> 指令要慢很多，不光增加了额外的请求次数，还会导致不可预料的问题。替代办法有以下几种：</p><ul><li>使用多个 <code>&lt;link&gt;</code> 元素</li><li>通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件</li><li>通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">&lt;!-- 使用 link 元素 --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;core.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">&lt;!-- 应避免的 @imports --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"> <span class="keyword">@import</span> url(<span class="string">&quot;more.css&quot;</span>);</span></span><br><span class="line"><span class="language-css">&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4、媒体查询（Media-query）的位置"><a href="#4、媒体查询（Media-query）的位置" class="headerlink" title="4、媒体查询（Media query）的位置"></a>4、媒体查询（Media query）的位置</h3><blockquote><p>将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘(同时也会增大维护力度)</p></blockquote><h3 id="5、带前缀的属性"><a href="#5、带前缀的属性" class="headerlink" title="5、带前缀的属性"></a>5、带前缀的属性</h3><blockquote><p>当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 带前缀的属性 */</span></span><br><span class="line">&gt;<span class="selector-class">.selector</span> &#123;</span><br><span class="line"> -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">15</span>);</span><br><span class="line">         <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">15</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="6、单行规则声明"><a href="#6、单行规则声明" class="headerlink" title="6、单行规则声明"></a>6、单行规则声明</h3><blockquote><p>对于<strong>只包含一条声明</strong>的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。</p><p>这样做的关键因素是为了错误检测 –-&gt; 例如，CSS 校验器指出在 xxx 行有语法错误。如果是单行单条声明，你就不会忽略这个错误；如果是单行多条声明的话，你就要仔细分析避免漏掉错误了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 一行上的单个声明,这种直接放在一行即可 */</span></span><br><span class="line">&gt;<span class="selector-class">.span1</span> &#123; <span class="attribute">width</span>: <span class="number">60px</span>; &#125;</span><br><span class="line">&gt;<span class="selector-class">.span2</span> &#123; <span class="attribute">width</span>: <span class="number">140px</span>; &#125;</span><br><span class="line">&gt;<span class="selector-class">.span3</span> &#123; <span class="attribute">width</span>: <span class="number">220px</span>; &#125;</span><br><span class="line">&gt;<span class="selector-class">.icon</span>           &#123; <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>; &#125;</span><br><span class="line">&gt;<span class="selector-class">.icon-home</span>      &#123; <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">20px</span>; &#125;</span><br><span class="line">&gt;<span class="selector-class">.icon-account</span>   &#123; <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">40px</span>; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* 多个声明，需要将样式分行 */</span></span><br><span class="line">&gt;<span class="selector-class">.sprite</span> &#123;</span><br><span class="line"> <span class="attribute">display</span>: inline-block;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">16px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">./hong.png</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="7、简写形式的属性"><a href="#7、简写形式的属性" class="headerlink" title="7、简写形式的属性"></a>7、简写形式的属性</h3><blockquote><p>在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。常见的滥用简写属性声明的情况如下</p><blockquote><ul><li><code>padding</code></li><li><code>margin</code></li><li><code>font</code></li><li><code>background</code></li><li><code>border</code></li><li><code>border-radius</code></li></ul></blockquote><p>大部分情况下，我们不需要为简写形式的属性声明指定所有值。例如，HTML 的 heading 元素只需要设置上、下边距（margin）的值，因此，在必要的时候，只需覆盖这两个值就可以。过度使用简写形式的属性声明会导致代码混乱，并且会对属性值带来不必要的覆盖从而引起意外的副作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 不好的例子 */</span></span><br><span class="line">&gt;<span class="selector-class">.element</span> &#123;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;  --&gt; 实际上只要 单独指定 `<span class="attribute">margin-bottom</span>: <span class="number">10px</span>` 即可;这样可能会导致覆盖上、水平方向的样式被覆盖</span><br><span class="line"> <span class="attribute">background</span>: red;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">0</span> <span class="number">0</span>;  --有时候简化实际上反而不易理解,像这种可以不简化</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* 好的例子 */</span></span><br><span class="line">&gt;<span class="selector-class">.element</span> &#123;</span><br><span class="line"> <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>: red;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line"> <span class="attribute">border-top-left-radius</span>: <span class="number">3px</span>;</span><br><span class="line"> <span class="attribute">border-top-right-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>**正好趁着这个机会补充梳理下简写属性的知识点 ** –&gt;查阅资料 : MDN的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Shorthand_properties"><code>CSS 的简写属性</code></a>; </p></blockquote><h4 id="①简写属性-的举🌰"><a href="#①简写属性-的举🌰" class="headerlink" title="①简写属性 的举🌰"></a>①简写属性 的举🌰</h4><blockquote><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 属性就是一个简写属性，它可以定义 </li></ol><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a> </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a> </li></ul><ol start="2"><li>类似地，最常见的字体相关的属性可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a> 的简写，</li><li>盒子（box）各方向的外边距（margin） 可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 这个简写。</li></ol></blockquote><h4 id="②-棘手的边界情况"><a href="#②-棘手的边界情况" class="headerlink" title="② 棘手的边界情况"></a>② 棘手的边界情况</h4><blockquote><p>虽然它们使用起来非常方便，但在使用时，仍需牢记一些边界情况：</p></blockquote><h5 id="a-没有指定的值会被设置为它的初始值-实际上将会覆盖之前设置的值"><a href="#a-没有指定的值会被设置为它的初始值-实际上将会覆盖之前设置的值" class="headerlink" title="a) 没有指定的值会被设置为它的初始值,实际上将会覆盖之前设置的值"></a>a) 没有指定的值会被设置为它的初始值,实际上将会覆盖之前设置的值</h5><blockquote><p>没有指定的值会被设置为它的初始值。这听起来似乎本来就很合理的样子，但这确实意味着，它将会覆盖之前设置的值。因此：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">background-color</span>: red;</span><br><span class="line">&gt;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">images/bg.gif</span>) no-repeat top right;</span><br></pre></td></tr></table></figure><p>以上样式是将 [ background-color ] 的默认值 <code>transparent</code>，而不会将 background 的 color 值设置为 <code>red</code></p><p>因为第二条规则优先。</p></blockquote><h5 id="b-关键词-inherit-只可以应用于单独属性"><a href="#b-关键词-inherit-只可以应用于单独属性" class="headerlink" title="b) 关键词 inherit 只可以应用于单独属性"></a>b) 关键词 inherit 只可以应用于单独属性</h5><blockquote><ul><li>关键词 inherit 只可以应用于单独属性（individual properties）</li><li>如果应用于一个简写属性（shorthand property），则必须整体应用，而能对简写属性值的每一个部分单独应用。</li><li>由于单独属性的漏掉的值会被它们的初始值（initial value）替代，因此不可能允许单个属性通过省略继承的 。</li><li>这意味着让一个属性的值使用继承值的唯一方法就是使用值是 inherit 的普通属性（longhand property）。</li></ul></blockquote><h5 id="c-简写属性不试图强制它们替代属性的值的特定顺序"><a href="#c-简写属性不试图强制它们替代属性的值的特定顺序" class="headerlink" title="c) 简写属性不试图强制它们替代属性的值的特定顺序"></a>c) 简写属性不试图强制它们替代属性的值的特定顺序</h5><blockquote><ol><li>简写属性不试图强制它们替代属性的值的特定顺序。</li><li>这适用于当这些属性使用不同类型的值时，因为这个时候顺序并不重要。</li><li>但当几个属性可以设置相同值的时候，就没那么简单了。处理这些情况分以下几种类型:</li></ol><blockquote><h6 id="处理和盒子（box）边界（edge）相关的属性时-比如-border-style、margin-或者-padding，"><a href="#处理和盒子（box）边界（edge）相关的属性时-比如-border-style、margin-或者-padding，" class="headerlink" title="处理和盒子（box）边界（edge）相关的属性时,比如 border-style、margin 或者 padding，"></a>处理和盒子（box）边界（edge）相关的属性时,比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>，</h6></blockquote><ul><li><strong>1个值的语法：</strong><code>border-width: 1em</code> —&gt; 这一个值表示所有的边框宽度,margin、padding同理</li><li><strong>2个值的语法：</strong><code>border-width: 1em 2em</code> — 第一个值表示垂直方向的，即 top 和 bottom；第二个值表示水平方向的，即 left 和 right</li><li><strong>3个值的语法：</strong><code>border-width: 1em 2em 3em</code> — 第一个值表示 top；第二个值表示水平方向的，即 left 和 right； 第三个值表示 bottom</li><li><strong>4个值的语法：</strong><code>border-width: 1em 2em 3em 4em</code> — 这四个值分别表示 top、right、bottom、left，总是按此顺序，即从 top 开始的顺时针顺序（Top-Right-Bottom-Left 首字母与英文单词 trouble 的顺序一致：TRBL）</li><li>可以发现,实际上1~4个参数不同时,代表的含义完全不同</li></ul><blockquote><h6 id="同样，在处理和盒子的角相关的属性时，比如-border-radius"><a href="#同样，在处理和盒子的角相关的属性时，比如-border-radius" class="headerlink" title="同样，在处理和盒子的角相关的属性时，比如 border-radius"></a>同样，在处理和盒子的角相关的属性时，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a></h6></blockquote><ul><li><strong>1个值的语法：</strong><code>border-radius: 1em</code> — 这一个值表示所有的表框角度的半径</li><li><strong>2个值的语法：</strong><code>border-radius: 1em 2em</code> — 第一个值表示 top-left 和 bottom-right 方向的角；第二个值表示 top-right 和 bottom-left 方向的角</li><li><strong>3个值的语法：</strong><code>border-radius: 1em 2em 3em</code> — 第一个值表示 top-left 方向的角 ，第二个值表示top-right 和 bottom-left 方向的角，第三个值表示 bottom-right 方向的角</li><li><strong>4个值的语法：</strong><code>border-radius: 1em 2em 3em 4em</code> — 这四个值分别表示top-left、 top-right、 bottom-right 、bottom-left 方向的角。总是按此顺序，即从top-left开始的顺时针顺序</li></ul></blockquote><h4 id="③-Background-属性"><a href="#③-Background-属性" class="headerlink" title="③  Background 属性"></a>③  Background 属性</h4><blockquote><p>background 有以下属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&gt;<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">images/bg.gif</span>);</span><br><span class="line">&gt;<span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&gt;<span class="attribute">background-position</span>: top right;</span><br></pre></td></tr></table></figure><p>可以简写成一行声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">background</span>: <span class="number">#000</span> <span class="built_in">url</span>(<span class="string">images/bg.gif</span>) no-repeat top right;</span><br></pre></td></tr></table></figure><p>简写的形式实际上等价于以上普通属性再加上 <code>background-attachment: scroll</code> 以及 CSS3 中的一些附加属性。</p></blockquote><h4 id="④-Font-属性"><a href="#④-Font-属性" class="headerlink" title="④ Font 属性"></a>④ Font 属性</h4><blockquote><p>下面的声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">font-style</span>: italic;</span><br><span class="line">&gt;<span class="attribute">font-weight</span>: bold;</span><br><span class="line">&gt;<span class="attribute">font-size</span>: .<span class="number">8em</span>;</span><br><span class="line">&gt;<span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">&gt;<span class="attribute">font-family</span>: Arial, sans-serif;</span><br></pre></td></tr></table></figure><p>可以简写成下面的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">font</span>: italic bold .<span class="number">8em</span>/<span class="number">1.2</span> Arial, sans-serif;</span><br></pre></td></tr></table></figure><p>这个简写声明实际上等价于以上普通属性再加上 <code>font-variant: normal</code> 和 <code>font-size-adjust: none</code> (CSS2.0 / CSS3)，<code>font-stretch: normal</code> (CSS3)。</p></blockquote><h4 id="⑤-Border-属性"><a href="#⑤-Border-属性" class="headerlink" title="⑤ Border 属性"></a>⑤ Border 属性</h4><blockquote><p>对于 border 来说，宽度、颜色和类型是可以被简写到一个声明里的。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">&gt;<span class="attribute">border-style</span>: solid;</span><br><span class="line">&gt;<span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br></pre></td></tr></table></figure><p>可以简写成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-Margin-和-Padding-属性"><a href="#⑥-Margin-和-Padding-属性" class="headerlink" title="⑥ Margin 和 Padding 属性"></a>⑥ Margin 和 Padding 属性</h4><blockquote><p>margin 和 padding 值的简写版本类似。下面的 CSS 声明：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&gt;<span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">&gt;<span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&gt;<span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br></pre></td></tr></table></figure><p>和下面的声明是一样的（注意，值是从 top 顺时针开始的：top、right、bottom、接着是 left）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">5px</span>;</span><br></pre></td></tr></table></figure><blockquote><h6 id="Margin-对于多个值有以下的简写规则：-重要"><a href="#Margin-对于多个值有以下的简写规则：-重要" class="headerlink" title="Margin 对于多个值有以下的简写规则： 重要"></a>Margin 对于多个值有以下的简写规则： <code>重要</code></h6></blockquote><ul><li>当只有<strong>一个</strong>值声明时，该值会用于所有<strong>四个</strong>值。</li><li>当只有<strong>两个</strong>值声明时，第一个值用于<strong>上边距</strong>和<strong>下边距</strong>，第二个值用于<strong>左边距</strong>和<strong>右边距</strong>。</li><li>当有三个值声明时，第一个值用于<strong>上边距</strong>，第二个值用于<strong>左边距</strong>和<strong>右边距</strong>，第三个值用于<strong>下边距。</strong></li><li>当有四个值声明时，其会按顺序用于上、右、下、左边距（按顺时针）。</li></ul></blockquote><h3 id="8、注释"><a href="#8、注释" class="headerlink" title="8、注释"></a>8、注释</h3><blockquote><ul><li>代码是写给自己看的,同时也是写给同事看的. 我们要确保我们的代码能够自描述、注释良好并且易于他人理解</li><li>好的代码注释应该是能够传达上下文关系以及代码目的的</li><li>而不是一味地重申一下类名或者模块名,说的就是你啊 铁子</li><li>对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 不好的栗子 */</span></span><br><span class="line">&gt;<span class="comment">/* Modal header */</span></span><br><span class="line">&gt;<span class="selector-class">.modal-header</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* 好的栗子 */</span></span><br><span class="line">&gt;<span class="comment">/* 为.modal-title和.modal-close包装元素  */</span></span><br><span class="line">&gt;<span class="selector-class">.modal-header</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><blockquote><h6 id="一个推荐的注释写法"><a href="#一个推荐的注释写法" class="headerlink" title="一个推荐的注释写法"></a>一个推荐的注释写法</h6></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* Header */</span></span><br><span class="line">&gt;内容区</span><br><span class="line">&gt;<span class="comment">/* End Header */</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="9、class命名"><a href="#9、class命名" class="headerlink" title="9、class命名"></a>9、class命名</h3><blockquote><ul><li>class 名称中只能出现小写字符和破折号（dashe）（<strong>不是下划线，也不是驼峰命名法</strong>）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，<code>.btn</code> 和 <code>.btn-danger</code>）。</li><li>避免过度任意的简写。<code>.btn</code> 代表 <em>button</em>，但是 <code>.s</code> 不能表达任何意思。</li><li>class 名称应当尽可能短，并且意义明确。</li><li>使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式的名称。</li><li>基于最近的父 class 或基本（base） class 作为新 class 的前缀。</li><li>使用 <code>.js-*</code> class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 不好的🌰 */</span></span><br><span class="line">&gt;<span class="selector-class">.t</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.red</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.header</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* 好的🌰 */</span></span><br><span class="line">&gt;<span class="selector-class">.tweet</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.important</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.tweet-header</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="10、选择器"><a href="#10、选择器" class="headerlink" title="10、选择器"></a>10、选择器</h3><blockquote><ul><li>对于通用元素使用 class ，这样利于渲染性能的优化。</li><li>对于经常出现的组件，避免使用属性选择器（例如，<code>[class^=&quot;...&quot;]</code>）。浏览器的性能会受到这些因素的影响。</li><li>选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。</li><li><strong>只有</strong>在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 不好的🌰 */</span></span><br><span class="line">&gt;<span class="selector-tag">span</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.page-container</span> <span class="selector-id">#stream</span> <span class="selector-class">.stream-item</span> <span class="selector-class">.tweet</span> <span class="selector-class">.tweet-header</span> <span class="selector-class">.username</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.avatar</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* 好的🌰 */</span></span><br><span class="line">&gt;<span class="selector-class">.avatar</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.tweet-header</span> <span class="selector-class">.username</span> &#123; ... &#125;</span><br><span class="line">&gt;<span class="selector-class">.tweet</span> <span class="selector-class">.avatar</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="11、代码组织"><a href="#11、代码组织" class="headerlink" title="11、代码组织"></a>11、代码组织</h3><blockquote><ul><li>以组件为单位组织代码段。</li><li>制定一致的注释规范。</li><li>使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。</li><li>如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。</li></ul></blockquote><h3 id="12、编辑器配置"><a href="#12、编辑器配置" class="headerlink" title="12、编辑器配置"></a>12、编辑器配置</h3><blockquote><p>将你的编辑器按照下面的配置进行设置，以避免常见的代码不一致和差异：</p><ul><li>用两个空格代替制表符（soft-tab 即用空格代表 tab 符）。</li><li>保存文件时，删除尾部的空白符。</li><li>设置文件编码为 UTF-8。</li><li>在文件结尾添加一个空白行。</li></ul></blockquote><h2 id="Ⅱ-一些关于W3C-CSS标准的经验总结"><a href="#Ⅱ-一些关于W3C-CSS标准的经验总结" class="headerlink" title="Ⅱ - 一些关于W3C CSS标准的经验总结"></a>Ⅱ - 一些关于<strong>W3C CSS标准</strong>的经验总结</h2><blockquote><ol><li>少用偏门。类似break-word断行，z-index手动分层，还有像垂直对齐等等这些偏门CSS最好少用，由于不一定所有浏览器都支持，而且极难通过W3C检测。</li><li>center不是float的值。很多老手都会把center误认为是float的值，而偏偏不是如此。center只是text-align的值。</li><li>对齐不能包括两个值。很多老手会在float或者text-align中填写两个值，比如：float:left top。这是不允许的，浏览器也无法识别。</li><li>滚动条颜色最好不要自定义。很多浏览器不能正常识别自定义颜色的滚动条，况且很多自定义颜色都不能通过W3C。</li><li>单独滚动条设置。如今经常使用overflow-x（横向滚动条）或者overflow-y（纵向滚动条），在设置这个的时候经常会发现并不是所有的客户端上都无效果，大家在设置的时候最好在body和html同时进行设置。然而这个CSS也不是CSS2.1支持的(CSS2.1支持overflow，同时定义横纵滚动条)，直到CSS3才支持这种定义方式。尽量少用。</li><li>background和color颜色相反会遭到警告。</li></ol></blockquote><h2 id="Ⅲ-一些容易忽略的细节"><a href="#Ⅲ-一些容易忽略的细节" class="headerlink" title="Ⅲ - 一些容易忽略的细节"></a>Ⅲ - 一些容易忽略的细节</h2><h3 id="1、连字符CSS选择器命名规范"><a href="#1、连字符CSS选择器命名规范" class="headerlink" title="1、连字符CSS选择器命名规范"></a>1、连字符CSS选择器命名规范</h3><blockquote><p>1.长名称或词组可以使用中横线来为选择器命名。</p><p>2.不建议使用“_”下划线来命名CSS选择器，为什么呢？</p><ul><li>输入的时候少按一个shift键；</li><li>浏览器兼容问题 （比如使用_tips的选择器命名，在IE6是无效的）</li><li>能良好区分JavaScript变量命名（JS变量命名是用“_”）</li></ul><p>这里有一篇破折号与下划线的详细讨论 中文篇：<a href="http://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html">点击查看</a></p></blockquote><h3 id="2、不要随意使用Id"><a href="#2、不要随意使用Id" class="headerlink" title="2、不要随意使用Id"></a>2、不要随意使用Id</h3><blockquote><ul><li>id在JS是唯一的，不能多次使用</li><li>而使用class类选择器却可以重复使用，另外id的优先级优先与class</li><li>所以id应该按需使用，而不能滥用。</li></ul></blockquote><h3 id="3、可以为选择器添加状态前缀"><a href="#3、可以为选择器添加状态前缀" class="headerlink" title="3、可以为选择器添加状态前缀"></a>3、可以为选择器添加状态前缀</h3><blockquote><p>有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下面是添加了“.is-”前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-class">.widthView</span> &#123;&#125;</span><br><span class="line">&gt;<span class="comment">/* 可以加个状态 */</span></span><br><span class="line">&gt;<span class="selector-class">.is-widthView</span> &#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅳ-CSS命名规范"><a href="#Ⅳ-CSS命名规范" class="headerlink" title="Ⅳ - CSS命名规范"></a>Ⅳ - CSS命名规范</h2><blockquote><p>命名永远是程序员的痛啊!!! 面对如山海般的代码,每天命名那么多变量名,实在词穷,所以就有一些’不法分子’取了各种稀奇古怪的名字,实在是让代码阅读性一降再降</p><p>这里也只能罗列出一些常见命名规则,多少能在命名的时候有所参照,防止一个意思取出了十几种名字</p></blockquote><h3 id="1、常见的CSS命名规则"><a href="#1、常见的CSS命名规则" class="headerlink" title="1、常见的CSS命名规则"></a>1、常见的CSS命名规则</h3><blockquote><ul><li>头：header</li><li>内容：content/container</li><li>尾：footer</li><li>导航：nav</li><li>侧栏：sidebar</li><li>栏目：column</li><li>页面外围控制整体佈局宽度：wrapper</li><li>左右中：left right center</li><li>登录条：loginbar</li><li>标志：logo</li><li>广告：banner</li><li>页面主体：main</li><li>热点：hot</li><li>新闻：news</li><li>下载：download</li><li>子导航：subnav</li><li>菜单：menu</li><li>子菜单：submenu</li><li>搜索：search</li><li>友情链接：friendlink</li><li>页脚：footer</li><li>版权：copyright</li><li>滚动：scroll</li><li>内容：content</li><li>标签：tags</li><li>文章列表：list</li><li>提示信息：msg</li><li>小技巧：tips</li><li>栏目标题：title</li><li>加入：joinus</li><li>指南：guide</li><li>服务：service</li><li>注册：regsiter</li><li>状态：status</li><li>投票：vote</li><li>合作伙伴：partner</li></ul></blockquote><h3 id="2、Id的命名"><a href="#2、Id的命名" class="headerlink" title="2、Id的命名"></a>2、Id的命名</h3><h4 id="①-页面结构"><a href="#①-页面结构" class="headerlink" title="① 页面结构"></a>① <strong>页面结构</strong></h4><blockquote><ul><li>容器: container</li><li>页头：header</li><li>内容：content/container</li><li>页面主体：main</li><li>页尾：footer</li><li>导航：nav</li><li>侧栏：sidebar</li><li>栏目：column</li><li>页面外围控制整体布局宽度：wrapper</li><li>左右中：left right center</li></ul></blockquote><h4 id="②-导航"><a href="#②-导航" class="headerlink" title="② 导航"></a>② 导航</h4><blockquote><ul><li>导航：nav</li><li>主导航：mainnav</li><li>子导航：subnav</li><li>顶导航：topnav</li><li>边导航：sidebar</li><li>左导航：leftsidebar</li><li>右导航：rightsidebar</li><li>菜单：menu</li><li>子菜单：submenu</li><li>标题: title</li><li>摘要: summary</li></ul></blockquote><h4 id="③-功能"><a href="#③-功能" class="headerlink" title="③ 功能"></a>③ <strong>功能</strong></h4><blockquote><ul><li>标志：logo</li><li>广告：banner</li><li>登陆：login</li><li>登录条：loginbar</li><li>注册：register</li><li>搜索：search</li><li>功能区：shop</li><li>标题：title</li><li>加入：joinus</li><li>状态：status</li><li>按钮：btn</li><li>滚动：scroll</li><li>标签页：tab</li><li>文章列表：list</li><li>提示信息：msg</li><li>当前的: current</li><li>小技巧：tips</li><li>图标: icon</li><li>注释：note</li><li>指南：guild</li><li>服务：service</li><li>热点：hot</li><li>新闻：news</li><li>下载：download</li><li>投票：vote</li><li>合作伙伴：partner</li><li>友情链接：link</li><li>版权：copyright</li></ul></blockquote><h3 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h3><blockquote><p>1.一律小写;<br>2.尽量用英文;<br>3.不加下划线;<br>4.尽量不缩写，除非一看就明白的单词。</p></blockquote><h3 id="4、CSS样式表文件命名"><a href="#4、CSS样式表文件命名" class="headerlink" title="4、CSS样式表文件命名"></a>4、CSS样式表文件命名</h3><blockquote><ul><li>主要的 master.css</li><li>模块 module.css</li><li>基本共用 base.css</li><li>布局、版面 layout.css</li><li>主题 themes.css</li><li>专栏 columns.css</li><li>文字 font.css</li><li>表单 forms.css</li><li>补丁 mend.css</li><li>打印 print.css</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端代码规范 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Echart笔记</title>
      <link href="/2022/10/12/Echart%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/12/Echart%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ-实现Echart折线图防抖自适应"><a href="#Ⅰ-实现Echart折线图防抖自适应" class="headerlink" title="Ⅰ-实现Echart折线图防抖自适应"></a>Ⅰ-实现Echart折线图防抖自适应</h2><blockquote><ol><li><p>当我需要让Echart的折线图根据当前页面大小发生变化,并且进行防抖处理节约性能</p></li><li><p>分析:</p><ol><li>利用<code>柯里化</code>与<code>高阶函数</code>的知识点写防抖函数</li><li>利用<code>Echart</code>的 <code>resize()</code>刷新函数进行适配</li></ol></li><li><p>代码示例</p><ol><li>防抖函数代码</li></ol></li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 防抖进行echart自适应</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> chartDom  传入 echarts.init(chartDom);生成的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">debounceEchartResize = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timers </span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">chartDom,interval:number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timers) <span class="built_in">clearTimeout</span>(timers);</span><br><span class="line">    timers = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 只执行最后一个定时器的 结果</span></span><br><span class="line">      chartDom.<span class="title function_">resize</span>()</span><br><span class="line">    &#125;, interval); <span class="comment">// 推迟 300 ms 在执行resize 效果 </span></span><br><span class="line">    <span class="comment">// return timer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>js调用 –&gt;本代码在React hooks 中使用</li></ol> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; tool &#125; <span class="keyword">from</span> <span class="string">&#x27;~/utils/Tool&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SaleSumInfo</span> = (<span class="params">props: IProps</span>) =&gt; &#123;</span><br><span class="line"> <span class="comment">//柯里化调用防抖自适应,在此处第一次调用,会生成timer,这样就不会因为在副作用函数中</span></span><br><span class="line">  <span class="comment">//因为重复渲染而重置</span></span><br><span class="line">  <span class="keyword">const</span> debounceResize = tool.<span class="title function_">debounceEchartResize</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//副作用函数,作用是react的生命周期</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chartDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> myChart = echarts.<span class="title function_">init</span>(chartDom);</span><br><span class="line">     <span class="comment">//形成闭包,同时防止监听事件运行两次回调函数</span></span><br><span class="line">     <span class="keyword">const</span> <span class="title function_">resizeFunc</span>=(<span class="params"></span>)=&gt;<span class="title function_">debounceResize</span>(myChart,<span class="number">300</span>)</span><br><span class="line">     <span class="comment">//创建监听事件</span></span><br><span class="line">     <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>,resizeFunc) </span><br><span class="line">      <span class="comment">//销毁的生命周期 进行监听卸载</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;resize&quot;</span>,resizeFunc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//渲染函数</span></span><br><span class="line">    <span class="keyword">return</span> ()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>)</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2022/10/12/git%E4%B8%8Evim%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
      <url>/2022/10/12/git%E4%B8%8Evim%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常用Git命令总结"><a href="#常用Git命令总结" class="headerlink" title="常用Git命令总结"></a>常用Git命令总结</h1><ul><li>git config –global user.name “你的名字” 让你全部的Git仓库绑定你的名字</li><li>git config –global user.email “你的邮箱” 让你全部的Git仓库绑定你的邮箱</li><li>git init 初始化你的仓库</li><li>git add . 把工作区的文件全部提交到暂存区</li><li>git add ./<file>/ 把工作区的<file>文件提交到暂存区</li><li>git commit -m “xxx” 把暂存区的所有文件提交到仓库区，暂存区空空荡荡</li><li>git remote add origin <a href="https://github.com/name/name_cangku.git">https://github.com/name/name_cangku.git</a> 把本地仓库与远程仓库连接起来</li><li>git push -u origin master 把仓库区的主分支master提交到远程仓库里</li><li>git push -u origin &lt;其他分支&gt; 把其他分支提交到远程仓库</li><li>git status查看当前仓库的状态</li><li>git diff 查看文件修改的具体内容</li><li>git log 显示从最近到最远的提交历史  git log –pretty=oneline(更简洁的方式显示)</li><li>git clone + 仓库地址下载克隆文件</li><li>git reset –hard + 版本号 回溯版本，版本号在commit的时候与master跟随在一起</li><li>git reflog 显示命令历史</li><li>git checkout – <file> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是Git世界的ctrl + z</li><li>git rm 删除版本库的文件</li><li>git branch 查看当前所有分支</li><li>git branch &lt;分支名字&gt; 创建分支</li><li>git checkout &lt;分支名字&gt; 切换到分支</li><li>git merge &lt;分支名字&gt; 合并分支</li><li>git branch -d &lt;分支名字&gt; 删除分支,有可能会删除失败，因为Git会保护没有被合并的分支</li><li>git branch -D + &lt;分支名字&gt; 强行删除，丢弃没被合并的分支</li><li>git log –graph 查看分支合并图</li><li>git merge –no-ff &lt;分支名字&gt; 合并分支的时候禁用Fast forward模式,因为这个模式会丢失分支历史信息</li><li>git stash 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li><li>git stash list 查看你刚刚“存放”起来的工作去哪里了</li><li>git stash apply 恢复却不删除stash内容</li><li>git stash drop 删除stash内容</li><li>git stash pop 恢复的同时把stash内容也删了</li><li>git remote 查看远程库的信息，会显示origin，远程仓库默认名称为origin</li><li>git remote -v 显示更详细的信息</li><li>git pull 把最新的提交从远程仓库中抓取下来，在本地合并,和git push相反</li><li>git rebase 把分叉的提交历史“整理”成一条直线，看上去更直观</li><li>git tag 查看所有标签，可以知道历史版本的tag</li><li>git tag <name> 打标签，默认为HEAD。比如git tag v1.0</li><li>git tag <tagName> &lt;版本号&gt; 把版本号打上标签，版本号就是commit时，跟在旁边的一串字母数字</li><li>git show <tagName> 查看标签信息</li><li>git tag -a <tagName> -m “&lt;说明&gt;” 创建带说明的标签。-a指定标签名，-m指定说明文字</li><li>git tag -d <tagName> 删除标签</li><li>git push origin <tagname> 推送某个标签到远程</li><li>git push origin –tags 一次性推送全部尚未推送到远程的本地标签</li><li>git push origin :refs/tags/<tagname> 删除远程标签<tagname></li><li>git config –global color.ui true 让Git显示颜色，会让命令输出看起来更醒目</li><li>git add -f <file> 强制提交已忽略的的文件</li><li>git check-ignore -v <file> 检查为什么Git会忽略该文件</li></ul><h1 id="vim常用指令"><a href="#vim常用指令" class="headerlink" title="vim常用指令"></a>vim常用指令</h1><h2 id="VIM-进入和退出命令"><a href="#VIM-进入和退出命令" class="headerlink" title="VIM 进入和退出命令"></a>VIM 进入和退出命令</h2><blockquote><p>常用命令是ESC，然后:wq（保存并退出），:q!(不保存并强制退出），i进入vim模式。另外还有其它的，我可能都不会用到。。。<br>按ESC键 跳到命令模式，然后：</p></blockquote><ol><li><strong>:w 保存文件但不退出vi</strong></li><li><strong>:w file 将修改另外保存到file中，不退出vi</strong></li><li><strong>:w! 强制保存，不推出vi</strong></li><li><strong>:wq 保存文件并退出vi</strong></li><li><strong>:wq! 强制保存文件，并退出vi</strong></li><li><strong>q: 不保存文件，退出vi</strong></li><li><strong>:q! 不保存文件，强制退出vi</strong></li><li><strong>:e! 放弃所有修改，从上次保存文件开始再编辑</strong></li></ol><h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p><h2 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h2><p>在命令行窗口中输入以下命令即可</p><p>vim 直接启动vim</p><p>vim filename 打开vim并创建名为filename的文件</p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>打开单个文件</p><p>vim file</p><p>同时打开多个文件</p><p>vim file1 file2 file3 …</p><p>在vim窗口中打开一个新文件</p><p>:open file</p><p>在新窗口中打开文件</p><p>:split file</p><p>切换到下一个文件</p><p>:bn</p><p>切换到上一个文件</p><p>:bp</p><p>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</p><p>:args</p><p>打开远程文件，比如ftp或者share folder</p><p>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></p><p>:e \qadrive\test\1.txt</p><h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–</p><h2 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h2><p>% 括号匹配</p><h2 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h2><p>i 在当前位置生前插入</p><p>I 在当前行首插入</p><p>a 在当前位置后插入</p><p>A 在当前行尾插入</p><p>o 在当前行之后插入一行</p><p>O 在当前行之前插入一行</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>/text　　查找text，按n健查找下一个，按N健查找前一个。</p><p>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</p><p>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</p><p>:set ignorecase　　忽略大小写的查找</p><p>:set noignorecase　　不忽略大小写的查找</p><p>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</p><p>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</p><p>:set nohlsearch　　关闭高亮搜索显示</p><p>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</p><p>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</p><p>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>ra 将当前字符替换为a，当期字符即光标所在字符。</p><p>s/old/new/ 用old替换new，替换当前行的第一个匹配</p><p>s/old/new/g 用old替换new，替换当前行的所有匹配</p><p>%s/old/new/ 用old替换new，替换所有行的第一个匹配</p><p>%s/old/new/g 用old替换new，替换整个文件的所有匹配</p><p>:10,20 s/^/  /g 在第10行知第20行每行前面加四个空格，用于缩进。</p><p>ddp 交换光标所在行和其下紧邻的一行。</p><h2 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h2><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<Esc>，这里的Esc是必须的，否则命令不生效。</p><p>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</p><p>b 向后移动一个单词 2b 向后移动2个单词</p><p>e，同w，只不过是光标停在单词尾部</p><p>ge，同b，光标停在单词尾部。</p><p>^ 移动到本行第一个非空白字符上。</p><p>0（数字0）移动到本行第一个字符上，</p><p><HOME> 移动到本行第一个字符。同0健。</p><p>$ 移动到行尾 3$ 移动到下面3行的行尾</p><p>gg 移动到文件头。 = [[</p><p>G（shift + g） 移动到文件尾。 = ]]</p><p>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</p><p>F 同f，反向查找。</p><p>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</p><p>Ctrl + e 向下滚动一行</p><p>Ctrl + y 向上滚动一行</p><p>Ctrl + d 向下滚动半屏</p><p>Ctrl + u 向上滚动半屏</p><p>Ctrl + f 向下滚动一屏</p><p>Ctrl + b 向上滚动一屏</p><h2 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h2><p>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。</p><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p>x 删除当前字符</p><p>3x 删除当前光标开始向后三个字符</p><p>X 删除当前字符的前一个字符。X=dh</p><p>dl 删除当前字符， dl=x</p><p>dh 删除前一个字符</p><p>dd 删除当前行</p><p>dj 删除上一行</p><p>dk 删除下一行</p><p>10d 删除当前行开始的10行。</p><p>D 删除当前字符至行尾。D=d$</p><p>d$ 删除当前字符之后的所有字符（本行）</p><p>kdgg 删除当前行之前所有行（不包括当前行）</p><p>jdG（jd shift + g）  删除当前行之后所有行（不包括当前行）</p><p>:1,10d 删除1-10行</p><p>:11,$d 删除11行及以后所有的行</p><p>:1,$d 删除所有行</p><p>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</p><h2 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h2><p>yy 拷贝当前行</p><p>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</p><p>p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</p><p>shift+p 在当前行前粘贴</p><p>:1,10 co 20 将1-10行插入到第20行之后。</p><p>:1,$ co $ 将整个文件复制一份并添加到文件尾部。</p><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p><p>ddp交换当前行和其下一行</p><p>xp交换当前字符和其后一个字符</p><h2 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h2><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</p><p>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</p><p>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</p><p>:1, 10 m 20 将第1-10行移动到第20行之后。</p><h2 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h2><p>:wq 保存并退出</p><p>ZZ 保存并退出</p><p>:q! 强制退出并忽略所有更改</p><p>:e! 放弃所有修改，并打开原来文件。</p><h2 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h2><p>:split或new 打开一个新窗口，光标停在顶层的窗口上</p><p>:split file或:new file 用新窗口打开文件</p><p>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</p><p>Ctrl+ww 移动到下一个窗口</p><p>Ctrl+wj 移动到下方的窗口</p><p>Ctrl+wk 移动到上方的窗口</p><p>关闭窗口</p><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。</p><p>:q 如果是最后一个被关闭的窗口，那么将退出vim。</p><p>ZZ 保存并退出。</p><p>关闭所有窗口，只保留当前窗口</p><p>:only</p><p>录制宏</p><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p><h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><p>:!command</p><p>:!ls 列出当前目录下文件</p><p>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</p><p>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</p><p>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p><h2 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h2><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p><p>3,5 s/^/#/g 注释第3-5行</p><p>3,5 s/^#//g 解除3-5行的注释</p><p>1,$ s/^/#/g 注释整个文档。</p><p>:%s/^/#/g 注释整个文档，此法更快。</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help <Esc> 特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<Esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</p><h2 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h2><p>. 重复前一次命令</p><p>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</p><p>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</p><p>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p><p>Vim教程<br>在Unix系统上<br>$ vimtutor<br>在Windows系统上<br>:help tutor</p><p>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p>]]></content>
      
      
      <categories>
          
          <category> 前端笔记整合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git详细笔记</title>
      <link href="/2022/10/12/Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/12/Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git详细学习"><a href="#Git详细学习" class="headerlink" title="Git详细学习"></a>Git详细学习</h1><h1 id="Ⅰ-Git操作"><a href="#Ⅰ-Git操作" class="headerlink" title="Ⅰ-Git操作"></a>Ⅰ-Git操作</h1><h2 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h2><blockquote><p>该处是用来提交时当作签名使用的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;我的用户名&quot;</span><br><span class="line">git config --global user.email &quot;我的邮箱&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除配置信息</span></span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><h2 id="二、Git工作流程与区域"><a href="#二、Git工作流程与区域" class="headerlink" title="二、Git工作流程与区域"></a>二、Git工作流程与区域</h2><h3 id="1、区域"><a href="#1、区域" class="headerlink" title="1、区域"></a>1、区域</h3><ol><li><p>工作区</p><blockquote><p>平时写代码的文件目录</p></blockquote></li><li><p>暂存区</p><blockquote><p>git add 后提交暂存的地方</p></blockquote></li><li><p>版本库</p><blockquote><p>git commit 后给你生成版本的地方,注意push是提交到远程仓库而不是版本库,请勿混淆</p></blockquote></li></ol><h3 id="2、工作流程"><a href="#2、工作流程" class="headerlink" title="2、工作流程"></a>2、工作流程</h3><blockquote><p>每个项目都有一个Git目录(.git)他是Git用来保存元数据和对象数据库的地方.该目录非常重要,每次克隆镜像仓库的时候,实际拷贝的就是这个目录里的数据</p></blockquote><h5 id="①、在工作目录中修改某些文件"><a href="#①、在工作目录中修改某些文件" class="headerlink" title="①、在工作目录中修改某些文件"></a>①、在工作目录中修改某些文件</h5><blockquote><p>从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录,这些文件实际上都是从Git目录中的压缩对象数据库中提取出来的,接下去就可以在工作目录中对这些文件进行编辑</p></blockquote><h5 id="②、保存到暂存区域-对暂存区做快照"><a href="#②、保存到暂存区域-对暂存区做快照" class="headerlink" title="②、保存到暂存区域,对暂存区做快照"></a>②、保存到暂存区域,对暂存区做快照</h5><blockquote><p>暂存区域只不过是个简单的文件,一般都放在Git目录中,有时候人们会把这个区域的文件叫做索引文件,不过标准说法还是叫暂存区域</p></blockquote><h5 id="③、提交更新"><a href="#③、提交更新" class="headerlink" title="③、提交更新"></a>③、提交更新</h5><blockquote><p>将保存区在暂存区域的文件快照永久转储到本地数据库(Git目录)中</p></blockquote><p>我们可以从文件所处位置来判断状态:如果是Git目录中保存着的特定版本文件,就属于提交版本;如果做了修改并已放入暂存区域,就属于已暂存状态;如果自上次去除后,做了修改但还没有放到暂存区域,就是已修改状态</p><h2 id="三、对象详解-底层命令"><a href="#三、对象详解-底层命令" class="headerlink" title="三、对象详解(底层命令)"></a>三、对象详解(底层命令)</h2><h3 id="1、git对象"><a href="#1、git对象" class="headerlink" title="1、git对象"></a>1、git对象</h3><blockquote><ol><li>key:val 组成的键值对(key是val相应的hash)</li></ol><p>​        键值对在git内部是blob类型(git特有)</p><ol start="2"><li>存储数据文件内容,也称为数据对象</li></ol></blockquote><h5 id="①-直接写入git对象方法与读取-存入”-git-objects”"><a href="#①-直接写入git对象方法与读取-存入”-git-objects”" class="headerlink" title="① 直接写入git对象方法与读取(存入”.git/objects”)"></a>① 直接写入git对象方法与读取(存入”.git/objects”)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将打印内容写入对象(git数据库)并且返回其相应哈希值</span></span><br><span class="line">echo &quot;写入的对象内容&quot; | git hash-object -w --stdin </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取内容并不能直接<span class="built_in">cat</span>读取,因为git存入时已经加密,需要如下代码 -p:内容  -t:类型</span></span><br><span class="line">git cat-file -p 存入对象的哈希值(此值可以由上一步得到) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件写入git对象,即我们常见的版本控制中出现的</span></span><br><span class="line">git hash-object -w ./test.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看Git存储的数据  返回其文件夹内的所有哈希文件</span></span><br><span class="line">find .git/objects -type f </span><br></pre></td></tr></table></figure><h3 id="2、树对象"><a href="#2、树对象" class="headerlink" title="2、树对象"></a>2、树对象</h3><blockquote><p>树对象是存储键值 作用为控制版本,如我们的版本前回退 就是在操作这个对象的(指向改变)</p><p>作用就是生成快照</p><p>这个也是git的必杀特性,因为他的切换分支与版本都很快 只是指针切换</p></blockquote><h4 id="构建树对象"><a href="#构建树对象" class="headerlink" title="构建树对象"></a>构建树对象</h4><blockquote><p>我们可以通过 update-index , write-tree , read-tree 等命令来构建树对象并且塞到暂存区</p></blockquote><h5 id="①-利用-update-index-命令-创建暂存区"><a href="#①-利用-update-index-命令-创建暂存区" class="headerlink" title="① 利用 update-index 命令 创建暂存区"></a>① 利用 <code>update-index</code> 命令 创建暂存区</h5><blockquote><p>利用 <code>update-index</code> 命令 为test.txt文件的首个版本创建一个暂存区,并通过<code>write-tree</code>命令生成树对象</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1生成一个树对象</span></span><br><span class="line">git update-index --add --cacheinfo 100664(文件状态码:普通文件) 哈希值 对应文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成快照(树对象)</span></span><br><span class="line">git write-tree</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2 将第一个树对象加入第二个树对象,使其成为新的树对象</span></span><br><span class="line">git read-tree -prefix=bak 哈希值(树对象的)  </span><br><span class="line">git write-tree</span><br></pre></td></tr></table></figure><h5 id="②-查看暂存区当前样子"><a href="#②-查看暂存区当前样子" class="headerlink" title="② 查看暂存区当前样子"></a>② 查看暂存区当前样子</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -s</span><br></pre></td></tr></table></figure><h3 id="3、提交对象"><a href="#3、提交对象" class="headerlink" title="3、提交对象"></a>3、提交对象</h3><blockquote><ol><li>通过上述两个对象操作后,你会发现你已经生成了不同项目的快照,但是问题是:如果想重用这些快照,你必须记住所有三个 SHA-1(快照)哈希值 .但是,你也完全不知道是谁保存了这些快照,在什么时刻保存的,以及为什么保存这些快照.而以上这些,正是提交对象(commit object)能为你保存的基本信息</li><li>我们可以通过调用commit-tree命令创建一个提交对象,为此需要指定一个树对象的SHA-1值,为此需要指定一个树对象的SHA-1值 , 以及该提交的父提交对象(如果有的话,第一次将暂存区做快照就没有父对象)</li><li>真正的一个版本其实就是提交对象</li></ol></blockquote><h5 id="①-创建提交对象"><a href="#①-创建提交对象" class="headerlink" title="① 创建提交对象"></a>① 创建提交对象</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;first commit&quot; |git commit-tree 树对象的哈希值</span><br></pre></td></tr></table></figure><p>②指定一个树对象的SHA-1值 , 以及该提交的父提交对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;second commit&quot; | git commit-tree 提交的树对象哈希值 -p 父亲树对象哈希值</span><br></pre></td></tr></table></figure><h2 id="四、高层命令"><a href="#四、高层命令" class="headerlink" title="四、高层命令"></a>四、高层命令</h2><h3 id="1、git-add"><a href="#1、git-add" class="headerlink" title="1、git add  ."></a>1、git add  .</h3><blockquote><ol><li><p>会将工作目录的修改,保存成git对象 <code>先到版本库,再到暂存区</code>,而不是直接到暂存区</p></li><li><p>在工作目录修改几个文件,就会生成几个git对象(一个文件对应一个git文件)</p></li><li><p>同一个文件,每次修改再add的时候都会生成一个新的git对象,是<code>增量</code>而不是覆盖</p></li><li><p>所以说git是绝对安全的,就算我只存到暂存区没有提交 git也会给我保存</p></li><li><p>只有后面提交的时候,才会根据暂存区内容给我生成树对象并存入版本区,然后加上我们的提交信息,才生成提交对象存入版本库</p></li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">相当于以下两个命令集合</span></span><br><span class="line">git hash-object -w 文件名(修改了多少个工作目录中的文件,就要被执行几次)</span><br><span class="line">git update-index ...</span><br></pre></td></tr></table></figure><h3 id="2、git-commit-m-“注释内容”"><a href="#2、git-commit-m-“注释内容”" class="headerlink" title="2、git  commit -m “注释内容”"></a>2、git  commit -m “注释内容”</h3><blockquote><p>将暂存区提交到版本库</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git write-tree</span><br><span class="line">git commit-tree</span><br></pre></td></tr></table></figure><blockquote><p>跳过暂存区存入(之前add过的,直接提交)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3、git-init"><a href="#3、git-init" class="headerlink" title="3、git init"></a>3、git init</h3><blockquote><p>初始化仓库 初始化后,在当前目录下出现一个名为.git的文件夹</p></blockquote><h3 id="4、git-status"><a href="#4、git-status" class="headerlink" title="4、git status"></a>4、git status</h3><blockquote><p>查看文件的状态</p></blockquote><h3 id="5、git-diff"><a href="#5、git-diff" class="headerlink" title="5、git diff"></a>5、git diff</h3><ol><li><p>当前做的那些更新没有暂存?</p><p>命令:<code>git diff</code>(不加参数直接输入git diff)</p></li><li><p>有哪些更新已经暂存起来准备好了下次提交</p><p>命令:<code>git diff --cached</code>或者<code>git diff --staged(1.6.1以上版本)</code></p></li></ol><h3 id="6、git-log"><a href="#6、git-log" class="headerlink" title="6、git log"></a>6、git log</h3><blockquote><ol><li><p><code>git log</code>(不带参数)</p><p><code>空格键</code>往下翻页 <code>b</code>向上翻页 <code>q</code>退出日志查阅</p></li><li><p>git log –oneline </p><p>将日志信息拍成一行显示</p></li><li><p>git reflog</p><p>所有的日志信息</p></li><li><p>git log –oneline –decorate –graph –all</p><p>查看所有的分支信息命令</p></li></ol></blockquote><h3 id="7、git-rm"><a href="#7、git-rm" class="headerlink" title="7、git rm"></a>7、git rm</h3><blockquote><p>删除工作目录对应的文件,再将修改添加到暂存区(如同删除后给你用了 <code>git add 文件名</code>)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除命令</span></span><br><span class="line">git rm 文件名 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接提交修改,因为<span class="built_in">rm</span>命令帮你提交到暂存区了</span></span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure><h3 id="8、git-mv"><a href="#8、git-mv" class="headerlink" title="8、git mv"></a>8、git mv</h3><blockquote><p>将工作目录中的文件进行重命名,再将修改添加到暂存区</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv 原文件名  新文件名</span><br></pre></td></tr></table></figure><h2 id="五、配别名"><a href="#五、配别名" class="headerlink" title="五、配别名"></a>五、配别名</h2><blockquote><p>Git并不会在你输入部分命令时自动推断出你想要的命令,如果不想每次都输入完整的Git命令,可以通过git config 文件来轻松为每一个命令设置一个别名</p><p>此处运行后将会写入你的配置文件,可以进入配置文件直接删除</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.自定义命令 &quot; `git` 命令后面的指令 &quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如配置查看分支信息 <span class="string">&quot;git log --oneline --decorate --graph --all&quot;</span></span></span><br><span class="line">git config --global alias.logbranch &quot;log --oneline --decorate --graph --all&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置切换分支</span></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用方式</span></span><br><span class="line">git logbranch</span><br></pre></td></tr></table></figure><h2 id="六、分支"><a href="#六、分支" class="headerlink" title="六、分支"></a>六、分支</h2><blockquote><ol><li><p>前言:</p><p>几乎所有的版本控制系统都以某种形式支持分支.使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线.在很多版本控制系统中,这是略微低效的过程–常常需要完全创建一个源代码目录的副本,对于大项目来说,这会耗费很多时间,而Git的分支模型极其的高校轻量,是Git的必杀特性,也正因为这一特性,是的Git从众多版本控制系统中脱颖而出</p></li><li><p>分支的本质:</p><p><code>Git的分支,其实本质上是提交对象</code>,,所有的分支都有机会被HEAD引用(<code>HEAD一个时刻只会指向一个分支</code>),当我们有新的提交的时候 HEAD会携带当前持有的分支向前移动</p><p>Git的默认分支名字是master,在多次提交后,你其实已经有一个指向最后那个提交对象的master分支.他会在每次的提交操作中自动向前</p><p>注意:Git的”master”分支并不是一个特殊分支.她就跟其他分支完全没有区别.之所以几乎每个仓库都有master分支,是因为<code>git init</code>命令默认创建它,并且大多数人懒得区改动它</p></li><li><p>分支的原理:</p><ol><li><p><code>.git/refs</code>目录中保存了分支及其对应的提交对象</p></li><li><p>当运行类似于<code>git branch (branchname)</code>这样的命令时,Git会取得当前所在分支最新提交对应的SHA-1值,并将其加入你想要创建的任何新分支中</p></li><li><p>当你执行<code>git branch (branchname)</code>时,Git如何知道最新提交的SHA-1值呢?答案是HEAD文件</p><p><code>HEAD文件</code>是一个符号引用(stmbolic reference),指向目前所在的分支.所谓符号医用,意味着它并不像普通引用那样包含一个SHA-1值.它时一个指向其他引用的指针</p></li></ol></li></ol></blockquote><h3 id="1、git-branch"><a href="#1、git-branch" class="headerlink" title="1、git branch"></a>1、git branch</h3><blockquote><ol><li><p>git branch(不加参数)</p><p>作用:<code>显示所有分支</code>信息</p></li><li><p>git branch 分支名</p><p>作用:<code>创建分支</code></p></li><li><p>git branch -v</p><p>作用:查看每一个分支最后一次提交</p></li><li><p>git branch -d(-D强制删除) 分支名</p><p>作用:<code>删除分支</code>,小d需要你这个分支是干净的才能删除(如已合并)</p></li><li><p>git branch –merged </p><p>作用:查看那些分支已经合并到当前分支</p><p>在这个列表中的分支名字前没有*号的分支通常可以使用<code>git branch -d</code> 删除掉</p></li><li><p>git branch –no-merged</p><p>作用:查看所有包含未合并工作的分支</p><p>尝试使用<code>git branch -d</code>命令删除在这个列表中的分支时会失败,如果真的想要删除分支并丢掉哪些工作,可以使用<code>-D</code> 选项爱强制删除它</p></li><li><p>git log –oneline –decorate –graph –all</p><p>作用:查看所有的分支信息命令</p></li><li><p>git branch 分支名 commitHash</p><p>作用:新建一个分支,并且使分支指向对应的提交对象(版本穿梭<code>可以替代撤销与重置</code>)</p></li></ol></blockquote><h3 id="2、git-checkout-分支名"><a href="#2、git-checkout-分支名" class="headerlink" title="2、git checkout 分支名"></a>2、git checkout 分支名</h3><blockquote><p>作用:<code>切换分支</code>  checkout还有其他作用,后面会提到</p><p>它会动三个地方:HEAD(指针) 暂存区 工作目录</p></blockquote><blockquote><ol><li><p><code>注意</code>:分支切换会改变你工作目录中的文件,所以在切换分支时,一定要注意你的工作目录里的文件会被改变,如果时切换到一个比较旧的分支,你的工作目录会回复到该分支最后一次提交的样子,如果Git不能干净利落的完成这个任务,它将禁止切换分支</p></li><li><p><code>坑</code>:在切换分支时, 如果当前分支上由未暂存的修改(<code>第一次</code>) 或者 有未提交的暂存<code>(第一次</code>) 分支可以切换成功,但是这种操作可能会污染其他分支</p><p>ps:<code>第一次</code>–当前分支如果已经提交过一次,将不让你切换,但是第一次没有提交过,git会帮你保存文件 但是它并不知道新增修改是属于哪个分支,所以会带回当前分支</p></li><li><p>最佳操作方式:<code>每次在切换分支前,需要提交一下当前分支(先使用status查看状态)</code></p></li></ol></blockquote><h3 id="3、git-checkout-b-“新的分支名”"><a href="#3、git-checkout-b-“新的分支名”" class="headerlink" title="3、git checkout -b “新的分支名”"></a>3、git checkout -b “新的分支名”</h3><blockquote><p>创建并进入该分支,类似于上面两个命令集合</p></blockquote><h3 id="4、模拟实战流程"><a href="#4、模拟实战流程" class="headerlink" title="4、模拟实战流程"></a>4、模拟实战流程</h3><blockquote><ol><li><p>需要解决主程序的的一个小BUG,所以使用<code>git  checkout -b &quot;iss_bug&quot;</code>新建分支并在这个分支进行bug调修</p></li><li><p>当你再<code>iss_bug</code>分支上开发到一半,这时,在主程序发现了一个紧急BUG需要你放下这个重要性为次要的bug进行修改.你老板都给你打了紧急电话,所以你需要先将写到一半的bug进行保存提交(<code>commit</code>提交或者储存  到暂存区,并不是提交合并到主分支,也不是push提交),确定status是干净的时候,切换回主分支,再用第一步的方法创建<code>hot_bug</code>分支(这时候<code>hit_bug</code>的版本是master没有进行<code>iss_bug</code>调修的版本),进行修复</p></li><li><p>当你将紧急bug修复后,进行提交,确定status干净后切换回master分支,进行合并:代码如下</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hit_bug</span><br></pre></td></tr></table></figure><ol start="4"><li>修改完后再查看status(这是个好习惯,防止偶尔记忆混淆造成不必要的麻烦),再切换至普通bug分支<code>iss_bug</code>进行修改,成功后切换回去合并</li><li>如果出现冲突,去出现冲突的文件手动修改(决定保留那部分代码),再进行<code>git add</code>表示冲突解决,在进行提交 </li></ol></blockquote><h3 id="5、合并分支"><a href="#5、合并分支" class="headerlink" title="5、合并分支"></a>5、合并分支</h3><blockquote><p>命令: <code>git merge branchname</code>(分支名)</p><p>注意:合并分支时要先切换到<code>主要分支</code>(即下面的被合并分支),在这个分支上进行合并新分支,使得这个分支进行版本更新</p><ol><li><p>快进合并–&gt;不会产生冲突</p><p>​        指被合并分支并没有进行修改,停留在原地,只有新分支进行修改更新,更        新完成后进行合并,原版本相当于直接前进版本,称为快进合并</p></li><li><p>典型合并–&gt;有可能产生冲突</p><p>​        指被合并分支在新分支进行开发时,本身也进行修改开发,可能会改动到同        一代码或者文件而产生重复修改</p></li><li><p>解决冲突:<code>打开冲突的文件</code>  进行修改 ,修改完成后进行:<code>add标记修改完成</code>,然后commit进行提交</p></li></ol></blockquote><blockquote><p><code>git 在pull或者合并分支</code>的时候有时会遇到一个第一段是黄色,下面文字是青色(偏蓝色)。可以不管(直接下面3,4步)，如果要输入解释的话就需要:</p><p>1.按键盘字母 i 进入insert模式</p><p>2.修改最上面那行黄色合并信息,可以不修改</p><p>3.按键盘左上角”Esc”</p><p>4.输入”:wq”,注意是冒号+wq,按回车键即可</p></blockquote><h2 id="七、存储"><a href="#七、存储" class="headerlink" title="七、存储"></a>七、存储</h2><blockquote><ol><li><p>需求背景:</p><p>有时,当你在项目的一部分上已经工作了一段时间后,所有东西都进入了混乱的状态,而这时你想要切换到另一个分支做一点别的事情.问题是,你不想仅仅因为过会儿回到这一点而做了一半的工作创建一次提交</p></li><li><p>解决:</p><p>针对这个问题的答案是 <code>git stash</code> 命令(当然,直接提交<code>commit</code>也可以,这个是用来不想生成提交对象而用)</p></li><li><p>原理:</p><p>git切换分支之所以保留你的未提交的修改文件,是因为它不想你因为误操作使得之前代码报废所以会当你status不干净时组织你切换分支(<code>ps</code>:如果是第一次创建的文件没有追踪过,它不认识是属于那份分支将会带到你切换后的分支造成污染),</p><p>而你将其保存到栈上(<code>ps</code>:换句话说将这部分内容抽取到一个类似共有的栈上,你在哪个分支都能够通过命令取到),git就知道你这个内容已经储存并不会造成切换分支使得你写的代码丢失,便不会阻止你切换分支或者切换带文件污染分支</p></li></ol></blockquote><h3 id="1、git-stash"><a href="#1、git-stash" class="headerlink" title="1、git stash"></a>1、git stash</h3><blockquote><p><code>git stash</code>命令会将未完成的修改保存到一个栈上,而你可以在任何时候重新应用这些改动(<code>git stash apply</code>),</p><p><code>注意!!!!!</code>:使用前你要先<code>git add .</code>,否则你会发现,你执行此命令后,没有追踪的部分全部消失了</p></blockquote><h3 id="2、git-stash-list"><a href="#2、git-stash-list" class="headerlink" title="2、git stash list"></a>2、git stash list</h3><blockquote><p>查看存储</p></blockquote><h3 id="3、git-stash-pop"><a href="#3、git-stash-pop" class="headerlink" title="3、git stash pop"></a>3、git stash pop</h3><blockquote><p>来应用储藏然后立即从栈上扔掉它 <code>这是最推荐的使用</code></p></blockquote><h3 id="4、git-stash-apply-stash-2"><a href="#4、git-stash-apply-stash-2" class="headerlink" title="4、git stash apply stash@{2}"></a>4、git stash apply stash@{2}</h3><blockquote><p>如果不指定一个储藏,git认为指定栈顶<code>不常用</code></p></blockquote><h3 id="5、git-stash-drop-“储藏的名字”"><a href="#5、git-stash-drop-“储藏的名字”" class="headerlink" title="5、git stash drop “储藏的名字”"></a>5、git stash drop “储藏的名字”</h3><blockquote><p>加上要储藏的名字移除他 <code>不常用</code></p></blockquote><h3 id="6、git-stash-clear"><a href="#6、git-stash-clear" class="headerlink" title="6、git stash clear"></a>6、git stash clear</h3><blockquote><p>在查看存储后,运行此命令  清空stash栈</p></blockquote><h2 id="八、撤销与重置"><a href="#八、撤销与重置" class="headerlink" title="八、撤销与重置"></a>八、撤销与重置</h2><blockquote><p>特别是重置部分理解即可(用到了再去查),撤销尽量可以掌握</p></blockquote><h3 id="Ⅰ-撤销"><a href="#Ⅰ-撤销" class="headerlink" title="Ⅰ- 撤销"></a>Ⅰ- 撤销</h3><h4 id="1、git-commit-–amend"><a href="#1、git-commit-–amend" class="headerlink" title="1、git commit –amend"></a>1、git commit –amend</h4><blockquote><ol><li><p>这个命令会将暂存区中的文件提交,修订提交(<code>不是撤销而是重新提交</code>)</p></li><li><p>如果自上次提交以来你还未做任何修改(如:在上次提交后马上执行此命令),那么快照会保持不变,而你修改的只是提交信息</p></li><li><p>如果你提交后发现忘记了暂存某些需要的修改,可以像下面这样操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;错误的注释&quot; #或者commit了错误的修改</span><br><span class="line">git add &quot;文件名或者.&quot;  #重新add正确的文件</span><br><span class="line">git commit --amend#进行重新提交</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交 (第二次提交将会替代第一次提交)</p></li><li><p>可以修改上次提交的文件与注释</p></li></ol></blockquote><h4 id="2、git-reset"><a href="#2、git-reset" class="headerlink" title="2、git reset"></a>2、git reset</h4><blockquote><ol><li>一般我们写完代码后,是这样提交的:</li></ol><ul><li>git add . //添加追踪所有文件</li><li>git commit -m “feat(前端-Git学习详细笔记):更新撤销commit操作” //添加commit提交信息</li></ul><ol start="2"><li>但是commit写完提交信息后,突然想到还有一个地方代码没改到/保存,如果放到下一个commit却不合适(同一个功能修改,分成两个commit),原因详见下方的 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">版本控制工具的使用基本原则</a> </li><li>执行此命令命令:<code>git reset --soft HEAD^</code></li></ol><ul><li>HEAD^的意思是上一个版本，也可以写成HEAD~1</li><li>如果你进行了2次commit，想都撤回，可以使用HEAD~2</li><li>详见下方 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#reset%E4%B8%89%E9%83%A8%E6%9B%B2">reset三部曲</a></li></ul><p>作用:将文件从<code>暂存区中撤回</code>到工作目录中(仅仅是撤回commit操作，你写的代码仍然保留)</p></blockquote><h4 id="3、git-checkout"><a href="#3、git-checkout" class="headerlink" title="3、git checkout"></a>3、git checkout</h4><blockquote><p>是的,你没看错,这个是切换分支的命令,但是他也能用来<code>撤销文件修改</code></p><p>命令:<code>git checkout --文件名</code></p><p>将在工作目录中对文件的修改撤销</p><p><code>注意</code>:这是一个危险的命令,这很重要.你对那个文件做的任何修改都会消失–你只是拷贝了另一个文件(原来版本的文件)来覆盖它.除非你确实秦楚不想要那个文件了,否则不要使用这个命令</p></blockquote><h3 id="Ⅱ-重置reset"><a href="#Ⅱ-重置reset" class="headerlink" title="Ⅱ - 重置reset"></a>Ⅱ - 重置reset</h3><blockquote><p>注意:<code>--hard</code>标记是<code>reset</code>命令唯一的<code>危险用法</code>,也是Git真正的销毁数据的几个仅有操作之一.其他任何形式的<code>reset</code>调用都可以轻松撤销,但是<code>--hard</code>选项不能,因为它强制覆盖了工作目录中的文件.</p><p>如在这种特殊情况:我们的Git数据库中的一个提交内还留有该文件的几个版本,我们可以通过<code>reflog</code>来找回它,但若是该文件还未提交,Git仍会覆盖他导致它无法恢复</p></blockquote><h4 id="reset三部曲"><a href="#reset三部曲" class="headerlink" title="reset三部曲"></a>reset三部曲</h4><blockquote><p>第一部:git reset –soft HEAD~(等于之前的–amend,后面如果跟随数字,就是回退几个版本,默认1个)</p><p>​    移动HEAD (但带着分支一起移动,与checkout不同(它只动HEAD))  –&gt;相当于回到你没有 [ commit ]的时候,代码仍在</p><p>第二部:git reset –mixed HEAD~</p><p>​    移动HEAD 并且动了了暂存区</p><p>第三部:git reset –hard HEAD~</p><p>​    移动HEAD 并且动了了暂存区 动了工作目录 ( 你的提交的代码也会没掉 )</p></blockquote><h3 id="Ⅲ-错误的git-push提交成功后如何撤销回退"><a href="#Ⅲ-错误的git-push提交成功后如何撤销回退" class="headerlink" title="Ⅲ -  错误的git push提交成功后如何撤销回退"></a>Ⅲ -  错误的git push提交成功后如何撤销回退</h3><blockquote><p>我们在使用Git进行版本控制时，有可能会出现这种情况。git push后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。</p><p>而要撤销,就要用到上面所学的 <code>git reset</code></p></blockquote><h4 id="1、错误场景示范"><a href="#1、错误场景示范" class="headerlink" title="1、错误场景示范"></a>1、错误场景示范</h4><blockquote><p>Ⅰ- 当我撰写 [ commit ] 信息没注意到,以为是对的时候直接提交 –&gt; 因为本人提交笔记时喜欢按 [ ↑ ] 找到之前的提交信息进行修改</p><img src="A_Git详细学习笔记中的图片/image-20210813153403664.png" alt="image-20210813153403664" style="zoom:67%;" /> <p>Ⅱ- 此时可以看到,错误的 [ commit ] 已经提交了 (当然,适用场景不只是commit ,也可错误代码之类的)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155746112.png" alt="image-20210813155746112"> </p></blockquote><h4 id="2、回退操作"><a href="#2、回退操作" class="headerlink" title="2、回退操作"></a>2、回退操作</h4><blockquote><p>咱们操作稳重一点,使用git reset –soft HEAD~就好了(如果回退后代码也不想要,可以用<code>git stash</code>,暂存,达到代码也回退的效果)</p></blockquote><h5 id="①-git-reflog"><a href="#①-git-reflog" class="headerlink" title="① git reflog"></a>① git reflog</h5><blockquote><p>commits，它在git中扮演了一个重要角色，我们平常用的一些操作git clone ,git commit 都会产生commits，通俗的讲这个就是版本号，但是git reset并不会产生commits（不是不会产生，而是会产生 但是都是一样的），我们可以先看看自己项目中的commits，使用如下命令:<code>git reflog</code></p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154309057.png" alt="image-20210813154309057"> </p></blockquote><h5 id="②-git-reset-–soft-HEAD"><a href="#②-git-reset-–soft-HEAD" class="headerlink" title="②  git  reset –soft HEAD~"></a>②  git  reset –soft HEAD~</h5><blockquote><p>运行此代码后,我们的 [ HEAD ] 指向了上一个 [ commits ]</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154448889.png" alt="image-20210813154448889"> </p></blockquote><h5 id="③-查看缓存"><a href="#③-查看缓存" class="headerlink" title="③  查看缓存"></a>③  查看缓存</h5><blockquote><ul><li><p>此时你可以用<code>stash staus</code>查看,会发现,之前提交的代码已经放回缓存区了</p></li><li><p>如果你不想要此次提交所有代码,可以使用<code>git stash</code> ,然后再去清空即可(当然,本人此处还是需要的,所以要留下)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154839981.png" alt="image-20210813154839981"> </p></li></ul></blockquote><h5 id="④-重新撰写-commit-信息"><a href="#④-重新撰写-commit-信息" class="headerlink" title="④ 重新撰写 [ commit ]信息"></a>④ 重新撰写 [ commit ]信息</h5><blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154928064.png" alt="image-20210813154928064"> </p></blockquote><h5 id="⑤-强制提交"><a href="#⑤-强制提交" class="headerlink" title="⑤ 强制提交"></a>⑤ 强制提交</h5><blockquote><p>如果你重新撰写 [ commit ] 后马上重新push,你会发现无法提交: 因为我们当前落后远程一个版本!</p><p>所以此时直接强制提交即可,就能覆盖远程提交记录</p><blockquote><p><code>git push -f</code></p></blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155049169.png" alt="image-20210813155049169"> </p></blockquote><h4 id="3、成功展示"><a href="#3、成功展示" class="headerlink" title="3、成功展示"></a>3、成功展示</h4><blockquote><ul><li>在网站工作台首页能看到已经将更改后的 [ coommit ] 强制推送上来了</li></ul><p> 也许你会奇怪:为啥工作台上还能看到? 其实已经删了!!!你看下方</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155614570.png" alt="image-20210813155614570"> </p><ul><li>但是你查看提交记录,会发现之前错误的commit已经被覆盖</li></ul><img src="A_Git详细学习笔记中的图片/image-20210813155339300.png" alt="image-20210813155339300" style="zoom:80%;" /></blockquote><h2 id="九、数据恢复"><a href="#九、数据恢复" class="headerlink" title="九、数据恢复"></a>九、数据恢复</h2><blockquote><p>在你使用Git的时候,你可能会意外丢失一次提交:</p><p>①通常这是因为你强制删除了正在工作的分支,但是最后你却需要这个分支;②抑或是你硬重置了一个分支,放弃了你想要的提交.</p><p>如果这些事情已经发生,该如何找回你的提交呢?</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p>推荐方法最好是<code>直接看恢复</code>,上面实例时当你使用硬重置回当初未删除版本进行恢复,出现的一系列问题解决</p></blockquote><blockquote><ol><li>假设你已经提交了五次,而现在,我们将master分支硬重置到了第三次提交来找回当时删除的分支.但是这时候你会发现一个事情:</li></ol><p>现在顶部的两个提交已经丢失了-没有分支指向这些提交(因为你将指针移到了第三个,那么前面两个就找不到了)</p><ol start="2"><li>你现在已经得到并且恢复当时第三次还存在的的提交了(<code>恢复方法在下面,恢复文件到这步,下面3、4是回到最新版本</code>)</li></ol><p>现在准备回到当初最新的版本时,你发现你进行打印竟然没有前面两次提交信息(你需要他的哈希值进行版本穿梭或者重置),你需要最新一次提交的哈希值,但是你估计想不起来了,对吗?</p><ol start="3"><li><p>最方便,也是最常用的方法,是使用一个名叫<code>log reflog</code>的工具(前面高层命令提过),当你在工作时,Git会默默记录每一次你改变的HEAD时它的值,每一次你提交或者改变分支,引用日志都会被刷新</p></li><li><p>如果<code>git reflog</code>显示的内容你觉得不足够多,可以执行<code>git log -g</code>,这个命令会以标准日志的格式输出引用日志</p></li></ol></blockquote><h3 id="恢复-推荐的"><a href="#恢复-推荐的" class="headerlink" title="恢复 推荐的"></a>恢复 <code>推荐的</code></h3><blockquote><ol><li><p>通过<code>git reflog</code>找到你需要的文件还未删除的版本哈希值,那个就是你丢失的提交,你可以通过创建一个新的分支指向这个提交来恢复它.</p><p>例如:你可以创建一个名为<code>recover-branch</code>的分支执行这个提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch recover-branch 当前需要恢复(之前丢失的)的提交哈希值</span><br></pre></td></tr></table></figure></li><li><p>现在有一个名为<code>recover-branch</code>的分支是你的<code>master</code>分支曾经指向的地方(即当时你删除该需要的文件的前的那个版本),这样你在这次提交的版本后,也能通过切换这个分支得到曾丢失的文件</p></li><li><p>这个分支功能能帮你做很多东西,善用分支,Git最强功能</p></li></ol></blockquote><h2 id="十、打tag"><a href="#十、打tag" class="headerlink" title="十、打tag"></a>十、打tag</h2><blockquote><p>Git可以给历史中的某一次提交打上标签,表示重要.比较有代表性的是人们会用这个功能来<code>标记发布节点</code>(v1.0等等)</p></blockquote><h3 id="1、列出标签"><a href="#1、列出标签" class="headerlink" title="1、列出标签"></a>1、列出标签</h3><blockquote><p>命令:<code>git tag</code> 或者 <code>git tag -l &#39;v1.*&#39;</code></p><p>​    前者列出所有,后者列出以<code>v1.</code>开头的所有</p></blockquote><h3 id="2、创建标签"><a href="#2、创建标签" class="headerlink" title="2、创建标签"></a>2、创建标签</h3><blockquote><p>git使用两种主要类型的标签:轻量标签 与 附注标签</p></blockquote><h5 id="①轻量标签"><a href="#①轻量标签" class="headerlink" title="①轻量标签"></a>①轻量标签</h5><blockquote><p>轻量标签很像一个不会改变的的分支(他只是一个特定提交的引用),直接在提交前使用命令即可给当前分支打上标签</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者下面的</span></span><br><span class="line">git tag v1.0 提交对象哈希</span><br></pre></td></tr></table></figure><h5 id="②附注标签"><a href="#②附注标签" class="headerlink" title="②附注标签"></a>②附注标签</h5><blockquote><p>附注标签是存储在Git数据库中的一个完整对象.他们是可以被校验的,其中包含打标签者的名字、电子邮件地址、日期时间;通常<code>建议创建复制标签</code>,这样你可以拥有以上所有信息,但如果只是想用一个临时标签,或者由于某些原因不想表村那些信息,轻量标签也是可用的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0</span><br><span class="line">git tag -a v1.0 提交对象哈希</span><br><span class="line">git tag -a v1.0 提交对象哈希 -m &quot;我的注释信息&quot;</span><br></pre></td></tr></table></figure><h3 id="3、查看特定标签"><a href="#3、查看特定标签" class="headerlink" title="3、查看特定标签"></a>3、查看特定标签</h3><blockquote><p><code>git show</code> 可以显示任意类型的对象(git对象 树对象 提交对象 tag对象)</p><p>命令: <code>git show tagname</code></p></blockquote><h3 id="4、删除标签"><a href="#4、删除标签" class="headerlink" title="4、删除标签"></a>4、删除标签</h3><blockquote><ol><li><p>删除标签 要删除你在本地仓库上的标签,可以使用命令 <code>git tag -d &lt;tagname&gt;</code>如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0</span><br></pre></td></tr></table></figure></li><li><p>应该注意上述命令并不会从任何远程仓库中移出这个标签,你必须使用<code>git push &lt;tamote&gt;:refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库,如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin是你配置的远程仓库地址别名,你可以直接用远程仓库地址</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="5、捡出标签"><a href="#5、捡出标签" class="headerlink" title="5、捡出标签"></a>5、捡出标签</h3><blockquote><ol><li><p>如果说你想查看某个标签所指向的文件版本,可以使用<code>git checkout</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tagname</span><br></pre></td></tr></table></figure></li><li><p>虽然说这会使得你的仓库处于”分离 头指针(deacthed HEAD)”状态.在”分离头指针”状态下,如果你做了某些更改然后提交它们,标签不会发生变化,但你的新提交将不属于任何分支,并且将无法访问,除非访问确切的提交哈希,因此你如果需要进行更改–比如说你需要<code>修复旧版本</code>的错误–这通常需要创建一个新的分支(捡出后创建,就会默认将当前捡出的版本作为新分支的第一版本-前面分支提到过)</p><p>这样就可以修改到旧版本的代码(如同vue的尤雨溪在vue3.x会更新vue1.0版本生态)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b version(新的分支)</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="Ⅱ-代码风格"><a href="#Ⅱ-代码风格" class="headerlink" title="Ⅱ-代码风格"></a>Ⅱ-代码风格</h1><h2 id="1、Eslint"><a href="#1、Eslint" class="headerlink" title="1、Eslint"></a>1、Eslint</h2><blockquote><p>ESlint是一个开源的JavaScript代码检查工具,由红宝书作者创建</p><p>初衷是为了让程序员可以创建自己的检测规则.ESLint的所有规则都被设计成可插入的</p><p>ESLint使用Node.js编写,这样既可以有一个快速的运行环境同时也便于安装</p><p>此处引入概念,具体学习之后将开新的笔记</p></blockquote><h2 id="2、commit提交规范"><a href="#2、commit提交规范" class="headerlink" title="2、commit提交规范"></a>2、commit提交规范</h2><blockquote><ol><li><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">参考自阮一峰老师的文章</a></p></li><li><p>Header</p></li></ol><p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p><p><strong>（1）type</strong></p><p><code>type</code>用于说明 commit 的类别，只允许使用下面几个标识。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">feat：新功能（feature）。</span><br><span class="line">fix/to：修复bug，可以是<span class="variable constant_">QA</span>发现的<span class="variable constant_">BUG</span>，也可以是研发自己发现的<span class="variable constant_">BUG</span>。</span><br><span class="line">fix：产生diff并自动修复此问题。适合于一次提交直接修复问题</span><br><span class="line">to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</span><br><span class="line">docs：文档（documentation）。</span><br><span class="line">style：格式（不影响代码运行的变动）。</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）。</span><br><span class="line">perf：优化相关，比如提升性能、体验。</span><br><span class="line">test：增加测试。</span><br><span class="line">chore：构建过程或辅助工具的变动。</span><br><span class="line">revert：回滚到上一个版本。</span><br><span class="line">merge：代码合并。</span><br><span class="line">sync：同步主线或分支的<span class="title class_">Bug</span>。</span><br></pre></td></tr></table></figure></blockquote><p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>（2）scope</strong></p><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>（3）subject</strong></p><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><blockquote><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul></blockquote></blockquote><h1 id="Ⅲ-远程操作"><a href="#Ⅲ-远程操作" class="headerlink" title="Ⅲ-远程操作"></a>Ⅲ-远程操作</h1><blockquote><p>三个必须懂的概念</p><ol><li>本地分支</li></ol><p>  工作目录中的分支</p><ol start="2"><li>远程跟踪分支</li></ol><p>  当你往远程分支<code>push</code>(还有克隆)的时候会创建远程跟踪分支</p><ol start="3"><li>远程分支</li></ol><p>  指保存在git网站上的那个远程仓库中的分支</p></blockquote><h3 id="1、团队协作流程"><a href="#1、团队协作流程" class="headerlink" title="1、团队协作流程"></a>1、团队协作流程</h3><blockquote><ol><li><p>项目经理初始化远程仓库</p><p> 一定要初始化一个空的仓库:再github上操作</p></li><li><p>项目经理创建本地仓库</p><ol><li><code>git remote 别名 仓库地址</code></li><li><code>git --init</code>,然后将源码复制进来</li><li>修改用户名 修改邮箱(双账号的才需要这步)</li><li><code>git  add</code> 和 <code>git commit</code></li></ol></li><li><p>项目经理推送到本地仓库到远程仓库</p><ol><li>清理window凭据</li><li><code>git push 别名 分支</code>(输入账号密码;推完之后会附带生成远程跟踪分支) </li></ol></li><li><p>项目邀请成员&amp;&amp;成员接受邀请</p><p> 在git网站上操作</p></li><li><p>成员克隆远程仓库</p><p> <code>git clone 仓库地址</code></p><p> 只有在克隆的时候 本地分支master 和 远程跟踪分支别名/master 是有同步关系的(可以直接pull或者push后面不用加origin)</p><p> 原因是,每次你push的时候是你远程跟踪分支替换掉(同步)你的远程分支，如果你想要新分支能直接push，需要本地分支去追踪远程追踪分支</p></li><li><p>成员做出贡献</p><ol><li>修改源代码文件</li><li><code>git add -&gt; commit -&gt; push</code></li></ol></li><li><p>项目经理更新修改</p><ol><li><code>git fetch 别名</code>(将修改同步到远程跟踪分支上)</li><li>git merge 远程跟踪分支</li></ol></li></ol></blockquote><h3 id="2、远程库"><a href="#2、远程库" class="headerlink" title="2、远程库"></a>2、远程库</h3><blockquote><p>正常的数据推送 和 拉取步骤</p><ol><li>确保本地分支已经跟踪了远程跟踪分支</li><li>拉取上传数据： git <code>pull</code> or <code>push</code></li></ol></blockquote><h4 id="Ⅰ-远程跟踪分支"><a href="#Ⅰ-远程跟踪分支" class="headerlink" title="Ⅰ-远程跟踪分支"></a>Ⅰ-远程跟踪分支</h4><blockquote><p>流程与释义:</p><ol><li><p><code>远程跟踪分支</code>是远程分支状态的引用。它们是你不能移动的本地分支。当你做任何网络通信操作时，它们会自动移动</p></li><li><p>它们以（remote）/(branch)形式命名，如果你想要看你最后一次与远程仓库origin时master分支的状态，可以查看origin/master分支</p></li><li><p>当<code>克隆</code>一个仓库时,它通常会自动的创建一个跟踪<code>origin/master</code>的master分支（所以你可以不跟踪直接pull与push后面不跟origin）</p></li><li><p>当我克隆之后，别人新建了一个分支push上去，我这时候想要或者并且跟踪这个新分支，我需要先<code>git fetch origin</code>获取下来，获取下来后想要切换并且跟踪这个分支时使用命令<code>git checkout --track 远程跟踪分支名(origin/分支名)</code></p></li></ol></blockquote><h5 id="做跟踪"><a href="#做跟踪" class="headerlink" title="做跟踪:"></a>做跟踪:</h5><blockquote><ol><li><p>克隆仓库时,会自动为master做跟踪</p></li><li><p>本地没有分支,要新建分支且追踪</p></li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track 远程跟踪分支(remote/分支名)</span><br></pre></td></tr></table></figure><ol start="3"><li>本地已经创建了分支,</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u 远程跟踪分支(remote/分支名)</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅱ-本地分支怎么跟踪远程跟踪分支"><a href="#Ⅱ-本地分支怎么跟踪远程跟踪分支" class="headerlink" title="Ⅱ-本地分支怎么跟踪远程跟踪分支"></a>Ⅱ-本地分支怎么跟踪远程跟踪分支</h4><blockquote><ol><li><p>当克隆的时候 会自动生成一个master本地分支（已经跟踪了对应的远程跟踪分支）</p></li><li><p>在新建其他分支时，可以指定想要跟踪的远程跟踪分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 远程跟踪分支名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">简写形式</span></span><br><span class="line">git checkout --track 远程跟踪分支名(origin/分支名)</span><br></pre></td></tr></table></figure></li><li><p>将一个已经存在的本地分支 改成 一个跟踪分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u 远程跟踪分支名</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="Ⅲ-冲突"><a href="#Ⅲ-冲突" class="headerlink" title="Ⅲ-冲突"></a>Ⅲ-冲突</h4><blockquote><ol><li>git本地操作会不会有冲突？</li></ol><p>  典型合并的时候（如新建分支合并时）</p><ol start="2"><li>git远程协作的时候会不会有冲突</li></ol><p>  <code>push</code>与<code>pull</code></p></blockquote><blockquote><p>解决流程：</p><ol><li><p>假设你修改了a.js的代码，已经<code>add &amp;&amp;commit</code>（必须先这样才能提交，才能触发冲突）</p></li><li><p>但是这时别人也改了a.js同一行代码并且已经push上去了，你这时候进行push将会报错</p></li><li><p>这时候你需要先将其pull下来，这时候你会发现你的git将会给你提示，并且在本地的a.js中文件代码中，保留了你们两个的代码（并且会给你标注出来）</p></li><li><p>这时候一定要去与<code>与你冲突的开发人员交流</code>,讨论保留哪一个人的代码，或者进行修改（直接在你pull后的本地目录中修改），修改完成后使用<code>git add .</code>标记解决冲突然后<code>push</code>提交，这样别人pull的时候git就知道这部分时保留哪部分代码，直接覆盖（即在一个地方更改然后标记提交即可）</p></li><li><p>如果你发生冲突<code>不进行沟通</code>，将别人代码<code>直接注释掉</code>，让自己代码能跑，那么–真的很爽</p></li></ol><p>  但是别人功能可能就炸了，这时候你会被暴打:smirk:</p><p>  因为你解决冲突后（git add .）别人pull的时候并不会提示冲突，因为你用<code>add</code>标记解决了冲突，git认出来后会直接默认<code>覆盖</code>他的代码，不知不觉，你可能就毁了另外一个程序员美好的一天（莫名其妙的BUG导致加班），如果他没反应过来，可能就是两天甚至…，你到时候住院的时间也与这个成正比:smirk:</p></blockquote><h4 id="Ⅳ-pull-request-流程"><a href="#Ⅳ-pull-request-流程" class="headerlink" title="Ⅳ- pull request 流程"></a>Ⅳ- pull request 流程</h4><blockquote><p>​    <code>如果你想要参加某个项目，但是并没有推送权限</code>，这时候可以对这个项目进行”派生“（<code>Fork</code>),派生是指GitHub将在你的空间创建一个完全属于你的项目副本,且你对其有推送权限.通过这种方式,项目的管理者不再需要忙着把用户添加到贡献者列表并给予它们推送权限.人们可以派生这个项目,将修改推送到派生出的项目副本中,并通过创建合并请求(pull request)让它们改动进入原版本库</p><p>基本流程:</p><ol><li>自己在git网站上fork的项目到自己空间中,下面的操作都是基于这个fork的项目</li><li>从master分支中创建一个新的分支</li><li>提交一些修改来改进项目</li><li>将这个分支推送到git上</li><li>创建一个<code>合并</code>请求(在网站上点击发送信息)</li><li>在网站上进行讨论,并且根据实际情况继续修改</li><li>项目的拥有者合并或者关闭你的合并请求</li></ol><p>注意:</p><p> 每次在发起新的<code>Pull Request</code>时 要去拉去最新的原仓库的代码 而不是自己fork的那个仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;源仓库名字（自己定义）&gt; &lt;仓库地址链接&gt;</span><br><span class="line">git fetch 远程仓库名字</span><br><span class="line">git merge 对应的远程跟踪分支</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="Ⅳ-版本控制工具的使用基本原则"><a href="#Ⅳ-版本控制工具的使用基本原则" class="headerlink" title="Ⅳ-版本控制工具的使用基本原则"></a>Ⅳ-版本控制工具的使用基本原则</h1><h2 id="1、精准的提交"><a href="#1、精准的提交" class="headerlink" title="1、精准的提交"></a>1、精准的提交</h2><p>每次提交都是一个小儿完整的功能或者一个BUG的修复。不应该出现多个功能点一块提交或者多个BUG一起修复的情况。如果一旦发现提交的代码有问题，可以方便的会滚到改动之前的正确状态，不会影响到其他协作者开发进程。</p><h2 id="2、频繁的提交"><a href="#2、频繁的提交" class="headerlink" title="2、频繁的提交"></a>2、频繁的提交</h2><p>尽可能频繁的提交你的改动到远程仓库，这样，可以避免将来合并代码的时候产生大量的冲突以至于难以解决。同时，也可以让其他同事比较快的共享你的改动。</p><h2 id="3、不要提交不完整的功能"><a href="#3、不要提交不完整的功能" class="headerlink" title="3、不要提交不完整的功能"></a>3、不要提交不完整的功能</h2><p>如果你正在开发的新功能比较庞大，那么可以讲这个功能尽可能拆分为几个逻辑模块，并且要保证分次提交的逻辑模块不会影响到整个系统的正确性。如果你只是因为临时的一些事情需要切到别的分支或者是临时需要中断开发（比如说下班）,那么应该使用<code>Stash</code>储藏功能来保存你的更改。   –&gt;<a href="#%E4%B8%83%E3%80%81%E5%AD%98%E5%82%A8">相关知识点部分我跳转</a></p><h2 id="4、提交前进行测试"><a href="#4、提交前进行测试" class="headerlink" title="4、提交前进行测试"></a>4、提交前进行测试</h2><p>不要想当然的认为自己的代码是正确的，提交之前应该经过充分的测试才能提交，即使是提交到本地仓库，也应该进行测试，因为这些代码在未来会被推送到远程共享给你的同事。</p><h2 id="5、高质量的提交注释"><a href="#5、高质量的提交注释" class="headerlink" title="5、高质量的提交注释"></a>5、高质量的提交注释</h2><p>每次提交都应该包含完整的注释。团队成员应当遵循统一的提交规则，一般应当明确的体现出提交的类型以及具体的事情，例如 feat: add message list;</p><h2 id="6、遵循统一的流程规范"><a href="#6、遵循统一的流程规范" class="headerlink" title="6、遵循统一的流程规范"></a>6、遵循统一的流程规范</h2><p>Git 可以支持很多不同的工作流程：长期分支、功能分支、合并以及 rebase、git-flow 等等。选择什么样的开发流程要取决如下一些因素：项目开发的类型，部署模式和（可能是最重要的）开发团队成员的个人习惯。不管怎样，选择什么样的流程都需要得到所有开发成员的一致认可，并且一直遵循它。</p><h1 id="Ⅴ-实际遇到的问题与解决Mark"><a href="#Ⅴ-实际遇到的问题与解决Mark" class="headerlink" title="Ⅴ- 实际遇到的问题与解决Mark"></a>Ⅴ- 实际遇到的问题与解决Mark</h1><h2 id="1、将本地已有的一个项目上传到新建的git仓库的方法"><a href="#1、将本地已有的一个项目上传到新建的git仓库的方法" class="headerlink" title="1、将本地已有的一个项目上传到新建的git仓库的方法"></a>1、将本地已有的一个项目上传到新建的git仓库的方法</h2><p>将本地已有的一个非git项目上传到新建的git仓库的方法一共有两种。</p><h3 id="Ⅰ-克隆-拷贝"><a href="#Ⅰ-克隆-拷贝" class="headerlink" title="Ⅰ-  克隆+拷贝"></a>Ⅰ-  克隆+拷贝</h3><blockquote><p>第一种方法比较简单，直接用把远程仓库拉到本地，然后再把自己本地的项目拷贝到仓库中去。然后push到远程仓库上去即可。<strong>此方法适用于本地项目不是一个git仓库的情况。</strong></p><p>具体步骤如下：</p><h4 id="1、首先克隆"><a href="#1、首先克隆" class="headerlink" title="1、首先克隆"></a>1、首先克隆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git <span class="built_in">clone</span> git@github.com:yuanmingchen/tensorflow_study.git</span><br></pre></td></tr></table></figure><h4 id="2、然后复制自己项目的所有文件到刚刚克隆下来的仓库中"><a href="#2、然后复制自己项目的所有文件到刚刚克隆下来的仓库中" class="headerlink" title="2、然后复制自己项目的所有文件到刚刚克隆下来的仓库中"></a>2、然后复制自己项目的所有文件到刚刚克隆下来的仓库中</h4><h4 id="3、最后push到远程仓库上面去："><a href="#3、最后push到远程仓库上面去：" class="headerlink" title="3、最后push到远程仓库上面去："></a>3、最后push到远程仓库上面去：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git push -u origin master</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-强行合并两个仓库"><a href="#Ⅱ-强行合并两个仓库" class="headerlink" title="Ⅱ-  强行合并两个仓库"></a>Ⅱ-  强行合并两个仓库</h3><blockquote><p>第二种方法就是先将本地的项目初始化为一个git仓库，然后再强行合并本地仓库和远程仓库，由于这两个仓库是完全不同的两个仓库，所以直接pull都会报错，需要在pull的时候假加上–allow-unrelated-histories才可以pull成功。<strong>此方法适用于本地项目已经是一个git仓库的情况。</strong></p><p>具体步骤如下：</p><h4 id="1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下："><a href="#1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下：" class="headerlink" title="1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下："></a>1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git init</span><br></pre></td></tr></table></figure><h4 id="2、把当前目录下的已有文件全部加到刚刚新建的git仓库中："><a href="#2、把当前目录下的已有文件全部加到刚刚新建的git仓库中：" class="headerlink" title="2、把当前目录下的已有文件全部加到刚刚新建的git仓库中："></a>2、把当前目录下的已有文件全部加到刚刚新建的git仓库中：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git add .</span><br></pre></td></tr></table></figure><h4 id="3、保存刚刚加入的文件，并书写保存信息："><a href="#3、保存刚刚加入的文件，并书写保存信息：" class="headerlink" title="3、保存刚刚加入的文件，并书写保存信息："></a>3、保存刚刚加入的文件，并书写保存信息：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git commit -m <span class="string">&quot;push current files&quot;</span></span><br></pre></td></tr></table></figure><h4 id="4、将本地仓库与远程仓库关联起来："><a href="#4、将本地仓库与远程仓库关联起来：" class="headerlink" title="4、将本地仓库与远程仓库关联起来："></a>4、将本地仓库与远程仓库关联起来：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git remote add origin git@github.com:yuanmingchen/tensorflow_study.git</span><br></pre></td></tr></table></figure><h4 id="5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）："><a href="#5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）：" class="headerlink" title="5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）："></a>5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h4 id="6、把本地仓库的内容push到远程仓库："><a href="#6、把本地仓库的内容push到远程仓库：" class="headerlink" title="6、把本地仓库的内容push到远程仓库："></a>6、把本地仓库的内容push到远程仓库：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git push -u origin master</span><br></pre></td></tr></table></figure><p>然后就ok了。</p></blockquote><h3 id="Ⅲ-其他git命令"><a href="#Ⅲ-其他git命令" class="headerlink" title="Ⅲ- 其他git命令"></a>Ⅲ- 其他git命令</h3><blockquote><p>最后附上git的一些其他命令：<br>1、删除已将关联的远程主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure><p>2、查看所有本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git branch -a</span><br></pre></td></tr></table></figure><p>3、新建一个分支，名字叫xf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git branch xf</span><br></pre></td></tr></table></figure><p>4、切换分支到xf分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git checkout xf</span><br></pre></td></tr></table></figure><p>5、把远程分支的代码pull到本地分支：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>如：取回origin主机的master分支，与本地的xf分支合并，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git pull origin master:xf</span><br></pre></td></tr></table></figure><p>6、推送当前的分支，git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>PS:注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。<br>如：把本地的xf分支推送到origin主机的master分支，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git push origin xf:master</span><br></pre></td></tr></table></figure></blockquote><h2 id="2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号"><a href="#2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号" class="headerlink" title="2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号"></a>2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号</h2><blockquote><p>此解决方案由百度多个方案结合而来,截取对我有用部分</p></blockquote><h3 id="Ⅰ-需求分析"><a href="#Ⅰ-需求分析" class="headerlink" title="Ⅰ- 需求分析"></a>Ⅰ- 需求分析</h3><blockquote><p>本人注册一个GitHub账户，用来分享本人自己的开源项目或者代码，同时，公司注册了一个GitHub账户，用来分享公司的开源项目。如果按照单个ssh公钥生成的方法则会把之前的公钥覆盖掉，这样将导致其中一方在下一次上传代码，本机和GitHub无法映射成功。</p><p>解决这个问题首先要明确如何生成单个ssh公钥。<br>ssh生成单个公钥命令：<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>。<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成ssh公钥</a><br>上述命令会在当前<code>~/.ssh</code>目录下生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。其中<code>id_rsa</code>是私钥文件，<code>id_rsa_.pub</code>是公钥文件。<br><code>id_rsa</code>和<code>id_rsa_.pub</code>文件都是通过一个邮箱号生成的，同一个公钥文件不可以配置两个不同GitHub账户（已测试）。<br>那么两个GitHub账户就需要两个不同的邮箱号，来生成两组不同的公钥文件。</p></blockquote><h3 id="Ⅱ-解决方案思路"><a href="#Ⅱ-解决方案思路" class="headerlink" title="Ⅱ- 解决方案思路"></a>Ⅱ- 解决方案思路</h3><blockquote><p>命令：<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f ~/.ssh/id_rsa_example</code><br>示例：分别以<a href="mailto:&#x37;&#x39;&#x31;&#x38;&#49;&#x35;&#53;&#x36;&#x37;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#x37;&#x39;&#x31;&#x38;&#49;&#x35;&#53;&#x36;&#x37;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a>和<a href="mailto:&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#x73;&#111;&#x66;&#x74;&#x40;&#x73;&#x69;&#x6e;&#97;&#46;&#99;&#x6e;">&#x67;&#x61;&#x6c;&#x61;&#x78;&#x79;&#x73;&#111;&#x66;&#x74;&#x40;&#x73;&#x69;&#x6e;&#97;&#46;&#99;&#x6e;</a>两个邮箱在<code>~/.ssh</code>目录下生成两级不同的公钥文件。<br><a href="mailto:&#55;&#x39;&#49;&#56;&#49;&#53;&#53;&#x36;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#55;&#x39;&#49;&#56;&#49;&#53;&#53;&#x36;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>邮箱：<code>ssh-keygen -t rsa -C &quot;791815567@qq.com&quot; -f ~/.ssh/id_rsa_me</code><br><a href="mailto:&#x67;&#97;&#x6c;&#97;&#x78;&#x79;&#x73;&#111;&#x66;&#x74;&#64;&#115;&#105;&#110;&#x61;&#x2e;&#x63;&#110;">&#x67;&#97;&#x6c;&#97;&#x78;&#x79;&#x73;&#111;&#x66;&#x74;&#64;&#115;&#105;&#110;&#x61;&#x2e;&#x63;&#110;</a>邮箱：<code>ssh-keygen -t rsa -C &quot;galaxysoft@sina.cn&quot; -f ~/.ssh/id_rsa_galaxysoft</code><br>生成过程可参考<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成单个ssh公钥</a> 这篇文章。<br>执行完成后，会以<code>~/.ssh</code>目录下看<a href="mailto:&#x37;&#x39;&#x31;&#x38;&#49;&#x35;&#x35;&#x36;&#x37;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;">&#x37;&#x39;&#x31;&#x38;&#49;&#x35;&#x35;&#x36;&#x37;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a>邮箱对应的私钥文件<code>id_rsa_me</code>、公钥文件<code>id_rsa_me.pub</code>和<a href="mailto:&#103;&#97;&#108;&#x61;&#x78;&#x79;&#115;&#x6f;&#102;&#116;&#64;&#115;&#105;&#x6e;&#x61;&#x2e;&#99;&#x6e;">&#103;&#97;&#108;&#x61;&#x78;&#x79;&#115;&#x6f;&#102;&#116;&#64;&#115;&#105;&#x6e;&#x61;&#x2e;&#99;&#x6e;</a>邮箱对应的私钥文件<code>id_rsa_galaxysoft</code>、公钥文件<code>id_rsa_galaxysoft.pub</code><br>分别在两个GitHub账户中添加对应的公钥信息即可，可参考<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成单个ssh公钥</a> 这篇文章</p></blockquote><h3 id="Ⅲ-生成新ssh-key"><a href="#Ⅲ-生成新ssh-key" class="headerlink" title="Ⅲ- 生成新ssh key"></a>Ⅲ- 生成新ssh key</h3><blockquote><p>如果我们电脑上已经存在了一个ssh key，那么我们需要在我们电脑上生成第二个你想在本电脑上使用的id_rsa，使用命令：<code>ssh-keygen -t rsa -C &quot;你的github注册邮箱&quot;</code>。</p><p>下图红色标注部分会提示你把新生成的id_rsa存放到哪里，此处默认会存放在c盘的用户名下的.ssh文件夹下（即你第一个github用户ssh key存放的目录），因此我们需要输入路径/c/Users/DodoMonster/.ssh（注意此路径是你的系统盘下用户目录安放ssh密钥的目录，请使用自己电脑上相对应的目录），最后我以“id_rsa_me”重新命名了ssh key防止默认与已有的ssh key重复。</p><blockquote><p>在输入了路径后，会提示你输入提交项目时输入的验证密码，不输则表示不用密码，这是为了防止别人随便在你的项目上push东西，所以最好还是输入以下你的密码。回车，再重复输入确认回车即可。</p></blockquote></blockquote><h3 id="Ⅳ-添加新ssh-key"><a href="#Ⅳ-添加新ssh-key" class="headerlink" title="Ⅳ- 添加新ssh key"></a>Ⅳ- 添加新ssh key</h3><blockquote><p>默认SSH只会读取id_rsa，所以为了让SSH识别新的私钥，需要将其添加到SSH agent<br>使用命令：<code>ssh-add ~/.ssh/id_rsa_me</code>(后面的是自己取的名字)</p><p>如果报错：Could not open a connection to your authentication agent.无法连接到ssh agent<br>可执行<code>ssh-agent bash</code>命令后再执行<code>ssh-add</code>命</p><p>然后将公钥添加到git账号中 <a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p></blockquote><h3 id="Ⅴ-配置config文件"><a href="#Ⅴ-配置config文件" class="headerlink" title="Ⅴ- 配置config文件"></a>Ⅴ- 配置config文件</h3><blockquote><p>查看.ssh文件中是否存在config文件</p><p>如果已存在则直接编辑config文件，命令：<code>vim config</code> #这是linux的命令，进入了vim界面后按<code>a或i或A或I</code>进入编辑模式，编辑完成后按esc键输入<code>:wq</code> 保存文件退出</p><p>如果不存在则需要创建config文件，命令：<code>touch config</code>，再对config文件进行编辑</p><p>对config文件进行配置填写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Default 第一个账号(123456@xxxx.com)</span></span><br><span class="line"></span><br><span class="line">Host gsgit</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_me</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="comment">#second 第二个账号（38894403@xxxx.com）</span></span><br><span class="line">    </span><br><span class="line">Host mygit</span><br><span class="line">     HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>其中Host 后的名字可以随意方便自己记忆，但HostName必须为<code>github.com(或者其它git地址)。</code></p></blockquote></blockquote><h3 id="Ⅵ-测试是否配置成功"><a href="#Ⅵ-测试是否配置成功" class="headerlink" title="Ⅵ- 测试是否配置成功"></a>Ⅵ- 测试是否配置成功</h3><blockquote><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ssh -T git@zc</span><br></pre></td></tr></table></figure><p>出现欢迎语则为配置成功。</p><p>注意：配置完成后，在连接Host不是github.com的github仓库时，远程库的地址要对应地做一些修改：</p><p>而并非原来的<a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">git <span class="built_in">clone</span> git@gitee.com:hongjilin/cx.git</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">//改为</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">git <span class="built_in">clone</span> git@mygit:hongjilin/cx.git</span></span><br></pre></td></tr></table></figure><p>这样每次连接都会使用id_rsa_me与服务器进行连接。</p><p>配置至此，大功告成！</p></blockquote><h3 id="Ⅶ-问题Mark"><a href="#Ⅶ-问题Mark" class="headerlink" title="Ⅶ- 问题Mark"></a>Ⅶ- 问题Mark</h3><blockquote><p>当我切换到另外一个账号提交时 commit的提交者仍寻找全局配置中的username作为签名 而不是当前本地库绑定提交账号的用户名(所以我用公司账号的<code>.ssh</code>配置绕过了组织检测,但是署名却用的是个人账户)</p><p>别小看这个BUG,挺恐怖的,下面举个我的栗子:</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210621172453710.png" alt="image-20210621172453710"></p><p>到这时候你可能觉得好像也没啥吧?但是我个人账号不是公司组织里面的(也不好解释)、计算公司个人绩效时也无法统计、之前版本还无法用搜索条件查找我个人账号(因为本身个人账号就不是组织里面的)的提交…..问题可大可小</p><p>所以此处<code>Mark</code>,留待后续学习生活解决</p></blockquote><h4 id="此问题解决"><a href="#此问题解决" class="headerlink" title="此问题解决"></a>此问题解决</h4><blockquote><p>之前只是将此问题Mark,但是未将解决方式具体写下,现将其更新</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210621171934972.png" alt="image-20210621171934972"></p><p>或者可以直接写个python小脚本来修改:如果根据该仓库clone时的账号来进行切换是否更合理,这是个好办法… </p></blockquote><h2 id="3、commit报错无法提交"><a href="#3、commit报错无法提交" class="headerlink" title="3、commit报错无法提交"></a>3、commit报错无法提交</h2><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; running pre-commit hook: lint-staged</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Preparing...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[FAILED] warning: LF will be replaced by CRLF <span class="keyword">in</span> sh.exe.stackdump.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[FAILED] The file will have its original line endings <span class="keyword">in</span> your working directory.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Running tasks...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED] Skipped because of previous git error.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Applying modifications...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED]   × lint-staged failed due to a git error.</span></span><br><span class="line"></span><br><span class="line"> × lint-staged failed due to a git error.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Cleaning up...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED]   × lint-staged failed due to a git error.</span></span><br><span class="line"> Any lost modifications can be restored from a git stash:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">pre-commit hook failed (add --no-verify to bypass)</span></span><br></pre></td></tr></table></figure><p>解决方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">执行npm run lint， 根据提示修改错误（推荐）</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">git commit -m <span class="string">&quot;&quot;</span> --no-verify 绕过了lint的检查</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="4、Git提交时出现-合并提示-Merge-branch-39-master-39-of-之解决方法"><a href="#4、Git提交时出现-合并提示-Merge-branch-39-master-39-of-之解决方法" class="headerlink" title="4、Git提交时出现(合并提示)Merge branch &#39;master&#39; of ...之解决方法"></a>4、Git提交时出现(<code>合并提示</code>)<code>Merge branch &#39;master&#39; of ...</code>之解决方法</h2><blockquote><p>多人协作开发项目，在上传代码时通常会先pull一下远程代码，使本地与远程同步更新，但是如果远程此时与自己代码存在冲突，在解决冲突后提交有时会出现“Merge branch ‘master’ of …”这条信息。这是因为pull其本质是fetch+Merge的结合。通常会分为以下两种情况：</p><p>1.如果远程分支超前于本地分支，并且本地也没有commit操作，此时pull会采用’fast-forward’模式，该模式不会产生合并节点，也即不产生”Merge branch ‘master’ of …”信息。</p><p>2.如果本地有commit提交，此时若存在冲突，pull拉取代码时远程和本地会出现分叉，会进行分支合并，就会产生”Merge branch ‘master’ of …”信息。</p><p><strong>解决方法</strong></p><blockquote><p>使用<code>git pull --rebase</code>命令，如果没有冲突,则会直接合并，如果存在冲突，手动解决冲突即可，不会再产生那条多余的信息。如果你不想每次都rebase，可以在git bash里执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;git config --global pull.rebase <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>这个配置就是告诉git在每次pull前先进行rebase操作。</p></blockquote></blockquote><h3 id="①-可能出现的相关报错error-Cannot-pull-with-rebase"><a href="#①-可能出现的相关报错error-Cannot-pull-with-rebase" class="headerlink" title="① 可能出现的相关报错error:Cannot pull with rebase"></a>① 可能出现的相关报错<code>error:Cannot pull with rebase</code></h3><blockquote><ol><li>git 执行<code>git pull –rebase</code>后报错误如下：</li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: cannot pull with rebase: Your index contains uncommitted changes.</span><br><span class="line">error: please commit or stash them.</span><br></pre></td></tr></table></figure><ol start="2"><li><p>原因：如果有未提交的更改，是不能git pull的</p></li><li><p>解决：</p></li></ol><ul><li>先执行<code>git stash</code>    –&gt;#可用来暂存当前正在进行的工作</li><li>再执行<code>git pull –-rebase</code></li><li>最后再执行<code>git stash pop</code>  –&gt;#从Git栈中读取最近一次保存的内容</li></ul><ol start="4"><li>截图示例</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210705115521085.png" alt="image-20210705115521085"></p></blockquote><h3 id="②-防止冲突的有效操作"><a href="#②-防止冲突的有效操作" class="headerlink" title="② 防止冲突的有效操作"></a>② <em>防止冲突的有效操作</em></h3><blockquote><p>不要直接用<code>git pull</code>拉取,而是分开操作,先拉取代码(拉取后可以先查看冲突部分取解决).随后再去合并</p><ol><li><code>git fetch 别名</code>(将修改同步到远程跟踪分支上)</li><li>git merge 远程跟踪分支</li></ol></blockquote><h2 id="5、Git删除误提交的大文件历史记录"><a href="#5、Git删除误提交的大文件历史记录" class="headerlink" title="5、Git删除误提交的大文件历史记录"></a>5、Git删除误提交的大文件历史记录</h2><blockquote><ol><li>应用场景:在我们日常使用Git的时候，一般比较小的项目，我们可能不会注意到.git 这个文件。其实.git文件主要用来记录每次提交的变动，当我们的项目越来越大的时候，我们发现.git文件越来越大。很大的可能是因为提交了大文件，如果你提交了大文件，那么即使你在之后的版本中将其删除，但是<code>实际上记录中的大文件仍然存在</code>。</li><li>原因分析:为什么呢？仔细想一想，虽然你在后面的版本中删除了大文件，但是Git是有版本倒退功能的吧，那么如果大文件不记录下来，git拿什么来给你回退呢？</li><li>导致的问题:.git文件越来越大导致的问题是–每次拉项目都要耗费大量的时间，并且每个人都要花费那么多的时间。</li><li>git给出了解决方案，使用git branch-filter来遍历git history tree, 可以永久删除history中的大文件，达到让.git文件瘦身的目的。</li></ol><p>下面给出步骤（以下步骤非常危险，<code>操作需谨慎!</code>,最好最好不要在公司项目中使用）</p></blockquote><h3 id="Ⅰ-列出仓库中最大的几个对象及其文件名"><a href="#Ⅰ-列出仓库中最大的几个对象及其文件名" class="headerlink" title="Ⅰ-列出仓库中最大的几个对象及其文件名"></a>Ⅰ-列出仓库中最大的几个对象及其文件名</h3><blockquote><p>列出所有仓库中的对象（包括SHA值、大小、路径等），并按照大小降序排列，列出TOP 5(本人示例,你也可多展示)</p><ol><li>命令示例</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all --objects | grep <span class="string">&quot;<span class="subst">$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 5 | awk -F &#x27; &#x27;  &#x27;&#123;print $1&#125;&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%88%97%E5%87%BA%E4%BB%93%E5%BA%93%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E5%90%8D.png" alt="image-20210508171542001"></p></blockquote><h3 id="Ⅱ-将某文件从历史记录中删除"><a href="#Ⅱ-将某文件从历史记录中删除" class="headerlink" title="Ⅱ-将某文件从历史记录中删除"></a>Ⅱ-将某文件从历史记录中删除</h3><blockquote><p>既然文件找到了(此处删除<code>杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg</code>)，那么得将该文件从历史记录中删除，执行以下命令：</p><ol><li>命令示例:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --branches -- <span class="string">&quot;杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210508171916951.png" alt="image-20210508171916951"></p></blockquote><h3 id="Ⅲ-重写所有-commit，将该文件从-Git-历史中完全删除"><a href="#Ⅲ-重写所有-commit，将该文件从-Git-历史中完全删除" class="headerlink" title="Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除"></a>Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除</h3><blockquote><p>上面的命令执行后只是从历史记录中移除，还没有完全删除它，我们需要重写所有 commit，将该文件从 Git 历史中完全删除：</p><ol><li>代码示例:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch  &quot;杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg&quot;&#x27;</span> -- --all</span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%88%A0%E9%99%A4%E6%88%AA%E5%9B%BE.png"></p><ol start="3"><li>补充注意点:</li></ol><p>  如果你像我一样,工作区有新写的内容没有追踪与提交导致无法进行删除操作时,千万不要直接暂存<code>stash</code>,否则这些没有暂存的内容就没了,要记得先<code>git add .</code></p></blockquote><h3 id="Ⅳ-把该文件的引用完全删除"><a href="#Ⅳ-把该文件的引用完全删除" class="headerlink" title="Ⅳ-把该文件的引用完全删除"></a>Ⅳ-把该文件的引用完全删除</h3><blockquote><p>上面的命令执行后，此时历史记录中已经没有该文件了，此时是真正删除了它。 不过我们运行 filter-branch 产生的日志还是会对该文件有引用，所以我们还需要运行以下几条命令，把该文件的引用完全删除：</p><ol><li>命令示例:</li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p> <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510183253770.png" alt="image-20210510183253770"></p><ol start="3"><li>果真编程其实殊途同归,该学的都得学,这里就暴露的Linux没学好的弊端,所以暗下决心,争取今年内将linux系统学习一遍</li></ol></blockquote><h3 id="Ⅴ-强制提交"><a href="#Ⅴ-强制提交" class="headerlink" title="Ⅴ-强制提交"></a>Ⅴ-强制提交</h3><blockquote><p>现在我们再看 .git 文件的大小明显变小了，少了那个大文件，说明我们之前误提交的大文件已经删除了。 最后一步就是 push 代码了，不过就是需要强制 push</p><ol><li>命令示例</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4.jpg"></p></blockquote><h3 id="Ⅵ-远程仓库GC"><a href="#Ⅵ-远程仓库GC" class="headerlink" title="Ⅵ-远程仓库GC"></a>Ⅵ-远程仓库GC</h3><blockquote><p>网上所能百度的方法中都没有说到要进行远程存储库GC,但是本人操作后发现,明明命令行中运行了<code>git gc</code>,但你的远程仓库仍然会非常庞大甚至更加庞大,也许你本地已经删减至几十兆,但是远程仓库已经”爆仓”达到<code>1300+兆</code>,详见<code>问题7</code></p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510180757993.png" alt="image-20210510180757993"></p></blockquote><h3 id="Ⅶ-删除前后-git大小对比"><a href="#Ⅶ-删除前后-git大小对比" class="headerlink" title="Ⅶ-删除前后.git大小对比"></a>Ⅶ-删除前后<code>.git</code>大小对比</h3><blockquote><p>本人此时测试删除的文件正好为10M,成功删除</p><ol><li>删除前截图</li></ol> <img src="A_Git详细学习笔记中的图片/删除大文件前大小.png" style="zoom:67%;" /><ol start="2"><li>删除后截图</li></ol> <img src="A_Git详细学习笔记中的图片/删除大文件后大小.png" style="zoom:67%;" /><ol start="3"><li>删除多个文件后</li></ol>  <img src="A_Git详细学习笔记中的图片/image-20210508182039450.png" alt="image-20210508182039450" style="zoom:67%;" /></blockquote><h2 id="6、git出现文件夹后面跟-数字问题"><a href="#6、git出现文件夹后面跟-数字问题" class="headerlink" title="6、git出现文件夹后面跟@+数字问题"></a>6、git出现文件夹后面跟<code>@+数字</code>问题</h2><blockquote><ol><li><p>问题出现场景:本人欲将两个仓库代码合到一个仓库中,但是原本文件夹内还有.git，导致这些文件夹push后变成了子模块</p></li><li><p>问题场景图例–&gt;具体出问题时并没有截图,此处截图提交时差别(原本应该是一大堆V1.0的文件,结果只有一个文件夹,后面跟着哈希值)</p></li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510171915185.png" alt="image-20210510171915185"></p><ol start="3"><li>解决思路</li></ol><blockquote><p>删除原来的子文件夹的.git  –&gt;<code>rm -r .git</code>,当然也可以手动删除</p><p>删除本地git缓存  –&gt;<code>git rm -r --cached fileName</code></p><p>重新add，push </p></blockquote><ol start="4"><li>解决结果截图</li></ol>  <img src="A_Git详细学习笔记中的图片/image-20210510172159472.png" alt="image-20210510172159472" style="zoom:67%;" /></blockquote><h2 id="7、远程仓库过大导致无法push"><a href="#7、远程仓库过大导致无法push" class="headerlink" title="7、远程仓库过大导致无法push"></a>7、远程仓库过大导致无法push</h2><blockquote><p>问题出现场景:在前两天本人发现笔记仓库过大 已经达到600M的时候,本人花了一些时间将无用的大文件删除(详见<code>问题5</code>),并且减小到了100M+,然后推送上了gitee上,但是今天push的时候突然报错仓库过大无法推送</p><ol><li><p>问题报错截图<img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510180415796.png" alt="image-20210510180415796"></p></li><li><p>本人就产生很大的疑惑,明明我本地仓库才100+M,<code>.git</code>文件也才86M,但是远程仓库竟然达到了恐怖的1300M+(当时急于寻找解决方案,没有截图)</p></li></ol><p>  本人推测(不确定,也找不到人问,朋友都没经历过这个情况,所以引出记录待定,如果有小伙伴知道了希望可以发在评论区或者私信我)</p><ol><li><p>当时我是将多条命令一起复制进去运行,可能导致<code>git gc</code>命令没有运行到(可能性极小,但还是留下悔恨的泪水)</p></li><li><p>也许本地的gc命令只是清理了本地仓库的,远程也要清理,但这个并不重要,知道了这个点后我们能进行解决了</p><p> <img src="A_Git详细学习笔记中的图片/image-20210510180539437.png" alt="image-20210510180539437" style="zoom:50%;" /><img src="A_Git详细学习笔记中的图片/image-20210510181407805.png" alt="image-20210510181407805" style="zoom:67%;" /></p></li><li><p>问题解决:</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510180757993.png" alt="image-20210510180757993"></p><p>GC后内存<img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510181329197.png" alt="image-20210510181329197"></p></li><li><p>GC详解</p></li></ol><blockquote><p>Git的底层并没有采用 CVS、SVN 底层所采用的那套增量式文件系统，而是采用一套自行维护的存储文件系统。当文件变动发生提交时，该文件系统存储的不是文件的差异信息，而是文件快照，即整个文件内容，并保存指向快照的索引。这种做法，提高 Git 分支的使用效率；但也容易导致代码仓库中内容重复程度过高，从而仓库体积过大。当遇到这种情况时，或者需要将仓库推送到远程主机时，就需要Git中的gc（garbage collect）功能，也就是<code>垃圾回收功能</code>。</p><p>大体来说，当运行 “git gc” 命令时，Git会收集所有松散对象并将它们存入 packfile，合并这些 packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。 此外，Git还会将所有引用 (references) 并入一个单独文件。</p><p>就细节而言，Git做了这几件事：</p><p>pack_refs 过程<br>reflog expire 过程<br>repack 过程<br>prune 过程<br>rerere 过程</p><p>pack_refs 过程相当于执行”git pack-refs –all –prune”，它会将$GIT_DIR/refs目录下的所有heads和tags打包成一个文件并保存为$GIT_DIR/packed-refs下。</p><p>reflog expire 过程相当于执行”git reflog expire –all”，它会将删除所有超过期限而且没有被refs涉及的reflog条目。</p><p>repack 过程相当于执行”git repack -d -l”，一般情况下还会包括”-A”选项，它会将所有未被包含在一个pack的松散对象连结成一个pack，也会将现有的pack重新组织为一个新的更有效率的pack，并删除冗余的pack（如果她们中存在不可达的松散对象，会先把这些对象释放出来）。</p><p>prune 过程相当于执行”git prune –expire”，他会删除所有过期的、不可达的且未被打包的松散对象。</p><p>rerere 过程相当于执行”git rerere gc”，这种情形下似乎没什么用。</p><p>所以本人推测应该是进行了<code>问题5</code>操作后还需要<code>进行一次GC操作</code></p></blockquote></blockquote><h2 id="8、Git-GUI中文乱码问题解决方法"><a href="#8、Git-GUI中文乱码问题解决方法" class="headerlink" title="8、Git GUI中文乱码问题解决方法"></a>8、Git GUI中文乱码问题解决方法</h2><blockquote><p>当我们使用Git GUI的查看代码的时候，有时候会出现中文乱码：</p><ol><li>解决方案1:直接在<code>GIT GUI</code>中操作</li></ol><p>  **<img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210701180547401.png" alt="image-20210701180547401"> </p><ol start="2"><li>解决方案2:命令行</li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure><ol start="3"><li>解决方案3:直接修改配置文件</li></ol><blockquote><p>在软件的安装目录下，在<code>Git\mingw32\etc\gitconfig</code>文件末尾添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;[gui]encoding=utf-8</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="9、Git-切换远程仓库地址"><a href="#9、Git-切换远程仓库地址" class="headerlink" title="9、Git 切换远程仓库地址"></a>9、Git 切换远程仓库地址</h2><blockquote><p>在公司开发中,也许会遇到公司项目地址迁移的问题(本人就遇到了) : 比如从码云gitee上将项目迁移到gitLab上,那么我们本地怎么切换远程仓库地址呢? 很简单!</p><ol><li>切换远程仓库地址</li></ol><ul><li><p><strong>方式一：修改远程仓库地址</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin URL <span class="comment">#更换远程仓库地址，URL为新地址。一步到胃</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方式二：先删除远程仓库地址，然后再添加</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin <span class="comment">#删除现有远程仓库</span></span><br><span class="line">git remote add origin url <span class="comment">#添加新远程仓库</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>查看远程仓库地址</li></ol><blockquote><p>没错,改完了,很简单是吧,但是你怎么确定自己是否修改成功了呢?</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  <span class="comment">#查看远程仓库的地址</span></span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>截图示例</li></ol><blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Git%E5%88%87%E6%8D%A2%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt="Git 切换远程仓库地址"></p></blockquote></blockquote><h2 id="10、如何撤销-commit-提交"><a href="#10、如何撤销-commit-提交" class="headerlink" title="10、如何撤销 commit 提交"></a>10、如何撤销 commit 提交</h2><blockquote><ol><li>一般我们写完代码后,是这样提交的:</li></ol><ul><li>git add . //添加追踪所有文件</li><li>git commit -m “feat(前端-Git学习详细笔记):更新撤销commit操作” //添加commit提交信息</li></ul><ol start="2"><li>但是commit写完提交信息后,突然想到还有一个地方代码没改到/保存,如果放到下一个commit却不合适(同一个功能修改,分成两个commit),原因详见上方的 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">版本控制工具的使用基本原则</a> </li><li>执行此命令命令:<code>git reset --soft HEAD^</code></li></ol><ul><li>HEAD^的意思是上一个版本，也可以写成HEAD~1</li><li>如果你进行了2次commit，想都撤回，可以使用HEAD~2</li><li>详见 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#reset%E4%B8%89%E9%83%A8%E6%9B%B2">reset三部曲</a></li></ul><p>作用:将文件从<code>暂存区中撤回</code>到工作目录中(仅仅是撤回commit操作，你写的代码仍然保留)</p></blockquote><h2 id="11、错误的git-push提交成功后如何撤销回退"><a href="#11、错误的git-push提交成功后如何撤销回退" class="headerlink" title="11、错误的git push提交成功后如何撤销回退"></a>11、错误的git push提交成功后如何撤销回退</h2><blockquote><p>我们在使用Git进行版本控制时，有可能会出现这种情况。git push后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。</p><p>而要撤销,就要用到上面所学的 <code>git reset</code></p></blockquote><h3 id="1、错误场景示范-1"><a href="#1、错误场景示范-1" class="headerlink" title="1、错误场景示范"></a>1、错误场景示范</h3><blockquote><p>Ⅰ- 当我撰写 [ commit ] 信息没注意到,以为是对的时候直接提交 –&gt; 因为本人提交笔记时喜欢按 [ ↑ ] 找到之前的提交信息进行修改</p><img src="A_Git详细学习笔记中的图片/image-20210813153403664.png" alt="image-20210813153403664" style="zoom:67%;" /> <p>Ⅱ- 此时可以看到,错误的 [ commit ] 已经提交了 (当然,适用场景不只是commit ,也可错误代码之类的)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155746112.png" alt="image-20210813155746112"> </p></blockquote><h3 id="2、回退操作-1"><a href="#2、回退操作-1" class="headerlink" title="2、回退操作"></a>2、回退操作</h3><blockquote><p>咱们操作稳重一点,使用git reset –soft HEAD~就好了(如果回退后代码也不想要,可以用<code>git stash</code>,暂存,达到代码也回退的效果)</p></blockquote><h4 id="①-git-reflog-1"><a href="#①-git-reflog-1" class="headerlink" title="① git reflog"></a>① git reflog</h4><blockquote><p>commits，它在git中扮演了一个重要角色，我们平常用的一些操作git clone ,git commit 都会产生commits，通俗的讲这个就是版本号，但是git reset并不会产生commits（不是不会产生，而是会产生 但是都是一样的），我们可以先看看自己项目中的commits，使用如下命令:<code>git reflog</code></p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154309057.png" alt="image-20210813154309057"> </p></blockquote><h4 id="②-git-reset-–soft-HEAD-1"><a href="#②-git-reset-–soft-HEAD-1" class="headerlink" title="②  git  reset –soft HEAD~"></a>②  git  reset –soft HEAD~</h4><blockquote><p>运行此代码后,我们的 [ HEAD ] 指向了上一个 [ commits ]</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154448889.png" alt="image-20210813154448889"> </p></blockquote><h4 id="③-查看缓存-1"><a href="#③-查看缓存-1" class="headerlink" title="③  查看缓存"></a>③  查看缓存</h4><blockquote><ul><li><p>此时你可以用<code>stash staus</code>查看,会发现,之前提交的代码已经放回缓存区了</p></li><li><p>如果你不想要此次提交所有代码,可以使用<code>git stash</code> ,然后再去清空即可(当然,本人此处还是需要的,所以要留下)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154839981.png" alt="image-20210813154839981"> </p></li></ul></blockquote><h4 id="④-重新撰写-commit-信息-1"><a href="#④-重新撰写-commit-信息-1" class="headerlink" title="④ 重新撰写 [ commit ]信息"></a>④ 重新撰写 [ commit ]信息</h4><blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154928064.png" alt="image-20210813154928064"> </p></blockquote><h4 id="⑤-强制提交-1"><a href="#⑤-强制提交-1" class="headerlink" title="⑤ 强制提交"></a>⑤ 强制提交</h4><blockquote><p>如果你重新撰写 [ commit ] 后马上重新push,你会发现无法提交: 因为我们当前落后远程一个版本!</p><p>所以此时直接强制提交即可,就能覆盖远程提交记录</p><blockquote><p><code>git push -f</code></p></blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155049169.png" alt="image-20210813155049169"> </p></blockquote><h3 id="3、成功展示-1"><a href="#3、成功展示-1" class="headerlink" title="3、成功展示"></a>3、成功展示</h3><blockquote><ul><li>在网站工作台首页能看到已经将更改后的 [ coommit ] 强制推送上来了</li></ul><p>也许你会奇怪:为啥工作台上还能看到? 其实已经删了!!!你看下方</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155614570.png" alt="image-20210813155614570"> </p><ul><li>但是你查看提交记录,会发现之前错误的commit已经被覆盖</li></ul><img src="A_Git详细学习笔记中的图片/image-20210813155339300.png" alt="image-20210813155339300" style="zoom:80%;" /></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
